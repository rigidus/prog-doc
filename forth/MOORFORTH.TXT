s/#ADV#/<center><h3>/g
s/#ENDA#/<\/h3><\/center>/g
\7.НОВОСТИ\СТАРЫЕ НОВОСТИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE
\7.НОВОСТИ\СТАРЫЕ НОВОСТИ\О РЕАЛИЗАЦИИ FORTH ВООБЩЕ\О FORTH ОТ АВТОРА
\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE
ТЕКСТ
PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE
 CHARLES H.MOORE
 written ~ June 1970
***
ЧАРЛЬЗ Х.МУР
 ПРОГРАММИРОВАНИЕ ПРОБЛЕМНО-ОРИЕНТИРОВАННОГО ЯЗЫКА
 Написано ок. июня 1970
***
ПРИМЕЧАНИЕ ПЕРЕСКАЗЧИКА
 Это не перевод, я слишком плохо знаю английский.
Это, скорее, построчный пересказ.
Причем, абсолютно сырой - почти без вычитки и редактирования.
Поэтому я оставил и исходный английский текст.
Единственно, подправил оглавление и переставил перепутанные абзацы в 7-й главе.
<ol><li>Стиль книги очень архаичен.
Современным программистам многое покажется непонятным и странным.
<li>Мысли Мура в некоторых местах до неприличия совпадают с моими.
Поэтому, я, возможно где и передернул (в смысле - поторопился принять желаемое за действительное).
<li>Книга так и не ответила на самый главный для меня вопрос: откуда взялись идеи, лежащие в основе устройства FORTH?
(Позднее я нашел их в работе Дейкстры).
Некоторых компьютерных баек тех времен и здравых, и местами замечательных, идей хватило только на первые две главы.
В третьей главе, вдруг, откуда ни возмись, является FORTH сразу во всей своей красе.
Сам Мур, понимая, что здесь у него образовался пробел, долго извиняется необходимостью забежать вперед и зациклить изложение.
Однако, и после этого продолжает всерьез обсуждать только частности, хотя, иногда, и изящно реализованные.
Автор, правда, еще в некоторых местах пытается рассуждать задним числом, но довольно бессвязно.
<li>Буквально воспринимать изложенные здесь идеи - значит подрывать общепринятые устои современного программирования.
В том числе, в области современного FORTH.
Поэтому советую успокаиваться при чтении мыслью, что, мол, все это давно устарело и отмерло за ненадобностью.
Тем более, что, во многом, особенно в мелочах, так оно и есть.
<li>Вообще же, интересны не столько конкретные технические идеи (хотя, тому, кто будет писать свой FORTH, они будут полезны), сколько выбор автором вопросов для рассмотрения и занятая им позиция.</ol>/Gudleifr, март 2012/

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\0.PREFACE / ПРЕДИСЛОВИЕ
ТЕКСТ
PREFACE
 This is an unpublished book I wrote long ago.
Just after I'd written the first versions of Forth.
Perhaps it explains the motivation behind Forth.
There is some interest in it, and publishing is no longer relevant since I can post it on my website.
I have a typescript that I recovered from Forth, Inc long ago.
I had typed it on my Smith-Corona portable, complete with overstrikes and annotations.
It is illegible enough to discourage a casual reader, so I'm re-keying it in HTML.
***
ПРЕДИСЛОВИЕ
 Это - неопубликованная книга, которую я написал давно.
Сразу после того, как я написал первые версии FORTH.
Возможно, это - обоснование FORTH задним числом.
Она интересна, но не опубликовывать же ее, поэтому я выкладываю ее на сайте.
Имеется машинописный текст, сохранившийся в Forth, Inc.
Я напечатал его на моей портативной Smith-Corona, с множеством правок.
Он был настолько неразборчив, что мне пришлось перенабрать его на компьютере.
***
This is useful, since I used to be a good typist and that skill has deteriorated.
My fingers can use the exercise and I'm curious if I can reduce my error rate.
***
Кроме того, я нашел это упражнение полезным для моего стареющего навыка машинописи.
***
I'm making minimal changes to the text; just enough to fit HTML.
The language remains quaint, ungrammatical or unclear.
Any remaining typos are modern.
***
Никаких правок, кроме требуемых правилами HTML не производилось.
Языковые погрешности оставлены без изменений.
Добавлены опечатки.
***
/Chuck Moore, 2011 / Чак Мур, 2011/

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\1. INTRODUCTION / ВВЕДЕНИЕ
ТЕКСТ
I'm not sure why you're reading this book.
It's taken me a while to discover why I'm writing it.
Let's examine the title: Programming a Problem-Oriented-Language.
The key word is programming.
I've written many programs over the years.
I've tried to write good programs, and I've observed the manner in which I write them rather critically.
My goal has been to decrease the effort required and increase the quality produced.
In the course of these observations, I've found myself making the same mistakes repeatedly.
Mistakes that are obvious in retrospect, but difficult to recognise in context.
I thought that if I wrote a prescription for programming, I could at least remind myself of problems.
And if the result is of value to me, it should be of value to others; if what I say is new to you, you may learn something of value; if I cover familiar ground, you at least get a new point of view.
***
Я не знаю, зачем вы читаете эту книгу.
Зачем тогда я ее пишу?
Давайте прочтем название: "Программирование проблемно-ориентированного языка".
Ключевое слово здесь "программирование".
Я написал много программ за эти годы.
Я пробовал писать хорошие программы, и я достаточно критически относился к своему стилю.
Хотелось уменьшить затраты на писание и повысить качество написанного.
Заметил, что определенные ошибки совершаю неоднократно.
Ошибки, очевидные при повторном чтении программы, но трудно избегаемые в контексте писания.
Я подумал, что мог бы составить сам для себя предписание, напоминающее об этих проблемах.
И если оно будет полезно для меня, то должно быть полезно и другим: если вы не знакомы с предметом - узнаете что-то новое, если знакомы - познакомитесь с новой точкой зрения.
***
I've also been distressed at the lack of concern from others about problems I consider significant.
It amounts to a general indifference to quality; a casual attitude of confidence that one's programs are pretty good, in any case as good as necessary.
I'm convinced this confidence is misplaced.
Moreover this attitude is reinforced by the massive trend to high-level languages and a placid acceptance of their inefficiencies: What's the use of designing a really good algorithm if the compiler's going to botch it up anyway?
***
Также, меня волнует общее пренебрежение некоторыми существенными проблемами.
Это - безразличие к качеству, вера в то, что работающая программа хороша уже сама по себе.
Я убежден, что эта вера неуместна.
Ситуация усугубляется увлечением неэффективными языками высокого уровня.
Зачем писать хороший алгоритм, если компилятор его все равно испортит?
***
So I've written a book about programming.
I have no great taste for debating over a one-way communication link and no real interest in convincing you that I'm right in what I say.
So you'll probably find that I'm being brusk.
I'm quite likely to state bluntly something you may take issue with.
Please do! My intention is to document an approach I've found useful, and perhaps to stimulate critical interest in programming.
If you care enough to take issue, I'm delighted.
***
Так что, я написал книгу по программированию.
Я не имею никакого особенного стремления непременно вас убедить.
Возможно, это грубо.
Возможно, вам многое не понравится.
Пожалуйста!
Я хочу документировать подход, который я нашел полезным, и, возможно, стимулировать его применение в программировании.
Если вы заинтересуетесь, я буду рад.
***
Back to the title.
What about Problem-Oriented-Language?
I didn't start out to write about that; and I'm not sure that I'm qualified to do so.
But I discovered that in order to justify what I was doing and identify the appropriate circumstances for doing it, the term became essential.
***
Вернемся к названию.
Что за проблемно-ориентированный язык?
Я не уверен, что термин выбран правильно.
Но я обнаружил, что он очень подходит для обозначения того, что я делал.
***
A problem-oriented-language is a language tailored to a particular application.
To avoid that uniquely clumsy term, I'll usually substitute application language as synonymous.
Very often such a language isn't recognised for what it is.
For instance, if your program reads a code in column 80 to identify an input card, you are implementing an application language.
A very crude one, a very awkward one; mostly because you hadn't given the matter any thought.
Recognising the problem, I'm sure you can design a better solution. This book will show you how.
***
Проблемно-ориентированный язык - язык, созданный для решения специфической задачи.
Синоним - прикладной язык.
Очень часто никто даже не замечает, как такой язык появляется.
Например, если ваша программа читает символ в 80-й колонке перфокарты, чтобы идентифицировать входные данные, вы используете прикладной язык.
Очень сырой и очень неуклюжий.
Главным образом потому, что вы об этом не думали.
Я уверен, что разобравшись в проблеме, вы можете предложить лучшее решение.
Эта книга покажет вам, как.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\1. INTRODUCTION / ВВЕДЕНИЕ\1.1. THE BASIC PRINCIPLE / ОСНОВНОЙ ПРИНЦИП
ТЕКСТ
We have a large number of subjects to talk about.
I'm going to throw before you a lot of techniques that you may be able to use.
This is basically the result of the nature of a digital computer: a general purpose tool for processing information.
A computer can do anything.
I hope that your realize that, providing you allow me to define "anything", I can prove this.
I mean real, incontrovertible, mathematical-type proof.
A computer cannot do everything.
I can prove this, too.
But most important, with only you and I to program it, a computer can not even do very much.
This is of the nature of an empirical discovery.
***
Обсудить надо многое.
Я собираюсь предложить вам для использования много методов.
Они основываются на свойствах цифрового компьютера - инструмента для обработки информации.
Компьютер может что-то делать.
Я надеюсь, что вы позволите мне уточнить это "что-то" и обосновать мои слова.
Я подразумеваю - обосновать строго, математически.
Компьютер не может делать все.
Это я тоже могу доказать.
Но наиболее важно, что многого мы с вами просто не можем запрограммировать.
Это эмпирический факт.
***
So to offer guidance when the trade-offs become obscure, I am going to define the Basic Principle:
 KEEP IT SIMPLE
 As the number of capabilities you add to a program increases, the complexity of the program increases exponentially.
The problem of maintaining compatibility among these capabililties, to say nothing of some sort of internal consistency in the program, can easily get out of hand.
You can avoid this if you apply the Basic Principle.
You may be acquainted with an operating system that ignored the Basic Principle.
***
Итак я определяю Основной Принцип:<br>
#ADV#ПУСТЬ БУДЕТ ПРОСТО#ENDA#
При увеличении возможностей программы ее сложность растет по экспоненте.
Согласованность составляющих или даже внутренняя логика программы может легко выйти из-под контроля.
Основной Принцип нужен для того, чтобы избежать этой проблемы.
Все знакомы с операционной системой, которая его игнорировала.
***
It is very hard to apply.
All the pressures, internal and external, conspire to add features to your program.
After all, it only takes a half-dozen instructions; so why not?
The only opposing pressure is the Basic Principle, and if you ignore it, there is no opposing pressure.
***
К ней очень трудно приноровиться.
Большая часть вашей программы нужна для соблюдения соглашений операционной системы и соглашений вашего языка.
В конце концов, требуется всего полдюжины операций, так зачем же писать лишнее?
Единственная ваша возможность противостоять росту сложности под давлением внешних соглашений - Основной Принцип.
***
In order to help you apply the Basic Principle, I'm going to tell you how many instructions you should use in some routines.
And how large a program with certain capabilities should be.
These numbers are largely machine independent; basically they measure the complexity of the task.
They are based upon routines I have used in my programs, so I can substantiate them.
Let me warn you now that I'll be talking about programs that will fit comfortably in 4K words of core.
***
Чтобы облегчить применение Основного Принципа, я собираюсь предложить вам несколько инструкций.
Увеличит ли их применение размер программы?
Нет, размер программы зависит только от сложности задачи.
За это я могу поручиться, т.к. проверил на себе.
Все, о чем мы будем говорить, прекрасно поместится в 4k слов ОЗУ.
***
The Basic Principle has a corollary:
 DO NOT SPECULATE!
 Do not put code in your program that might be used.
Do not leave hooks on which you can hang extensions.
The things you might want to do are infinite; that means that each one has 0 probability of realization.
If you need an extension later, you can code it later - and probably do a better job than if you did it now.
And if someone else adds the extension, will they notice the hooks you left?
Will you document that aspect of your program?
***
Основной Принцип имеет следствие:
#ADV#НЕ ПРЕДПОЛАГАЙТЕ!#ENDA#
Не пишите код, который может пригодиться когда-то в будущем.
Не оставляйте заплаток для будущих расширений.
Вещей, которые вы можете захотеть сделать, бесконечное множество; это означает, что каждая из них имеет нулевую вероятности осуществления.
Если вам что-то понадобится позже, вы это и запрограммируете позже - и, вероятно, лучше, чем сделали бы это теперь.
И если кто-нибудь будет расширять вашу программу, он заметит оставленные вами для этого заплатки?
Все ли из них вы аккуратно задокументируете?
***
The Basic Principle has another corollary:
 DO IT YOURSELF!
 Now we get down the the nitty-gritty.
This is our first clash with the establishment.
The conventionsl approach, enforced to a greater or lesser extent, is that you shall use a standard subroutine.
I say that you should write your own subroutines.
Before you can write your own subroutine, you have to know how.
This means, to be practical, that you have written it before; which makes it difficult to get started.
But give it a try.
After writing the same subroutine a dozen times on as many computers and languages, you'll be pretty good at it.
If you don't plan to be programming that long, you won't be interested in this book.
***
Основной Принцип имеет еще следствие:
#ADV#СДЕЛАЙТЕ ЭТО САМИ!#ENDA#
Теперь мы спускаемся на уровень практики.
Это - наш первый вызов сообществу.
Общепринято, что вы должны использовать стандартные подпрограммы.
Я говорю, что вы должны писать ваши собственные подпрограммы.
Конечно, вы должны уметь это делать.
Т.е. надо научиться, а это трудно.
Хотя бы, попытайтесь.
По прошествии лет перебора языков и компьютеров станет легче.
Если вы не собираетесь уделять программированию столько времени, эта книга не для вас.
***
What sort of subroutines do you write for yourself?
I have acquired respect for SQRT subroutines.
They're tricky things; seem to attract a lot of talent.
You can use the library routine to good advantage.
Input subroutines now.
They seem to have crawled out from under a rock.
I somehow can't agree that the last word was said 15 years ago when FORMAT statements were invented.
***
Какие подпрограммы вы должны писать сами?
Я уважаю подпрограмму SQRT.
Она написана хитро и талантливо.
Вы можете использовать библиотечные подпрограммы с большим успехом.
А подпрограммы ввода?
Они тупы до безобразия.
Я не могу поверить, что последнее слово в этом вопросе было сказано изобретением 15 лет назад оператора FORMAT.
***
As I will detail later, the input routine is the most important code in your program.
After all, no one sees your program; but everyone sees your input.
To abdicate to a system subroutine that hasn't the slightest interest in your particular problem is foolish.
The same can be said for output subroutine and disk-access subroutine.
***
Как я разъясню позднее, подпрограммы ввода - наиболее важный код вашей программы.
В конце концов, никто не видит вашу программу, но каждый видит ваш ввод.
И разрешать заниматься этим стандартным подпрограммам - глупо.
Тот же самое можно сказать о подпрограммах вывода и доступа к диску.
***
Moreovere, the task is not that great as to deter you.
Although it takes hundreds of instructions to write a general purpose subroutine, you can do what you need with tens of instructions.
In fact, I would advise against writing a subroutine longer that a hundred instructions.
***
Более того, задача не такая уж и сложная.
Хотя требуются сотни инструкций, чтобы написать общую подпрограмму, вам - для написания частной - понадобятся только десятки.
Я, вообще, против написания подпрограмм длиннее сотни инструкций.
***
So if you want to read double-precision, complex integers; don't rely on the COBOL input subroutine, or wait till the manufacturer revises it.
It's a lot easier to write your own.
***
Так, если вам нужны комплексные целые двойной точности, придется либо написать свою подпрограмму, либо подождать, пока производители COBOL до подобного дорастут.
Проще самому.
***
But suppose everyone wrote their own subroutines?
Isn't that a step backward; away from the millenium when our programs are machine independent, when we all write in the same language, maybe even on the same computer?
Let me take a stand: I can't solve the problems of the world.
With luck, I can write a good program.
***
Но что будет, если каждый будет писать свои подпрограммы?
Это шаг назад; скоро миллениум, когда программы станут машинно независимы, когда все мы будем писать на одном и том же языке, возможно, даже на одном и том же компьютере?
Что сказать?
Я не могу решить все проблемы мира.
Если повезет, я могу написать хорошую программу.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\1. INTRODUCTION / ВВЕДЕНИЕ\1.2. PREVIEW / ОБЗОР
ТЕКСТ
I'm going to tell you how to write a program.
It is a specific program; that is, a program with a specific structure and capabilities.
In particular, it is a program that can be expanded from simple to complex along a well defined path, to handle a wide range of problems, likewise varying from simple to complex.
One of the problems it considers is exactly the problem of complexity.
How can you control your program so that it doesn't grow more complicated than your application warrants?
First I'll define "input", and mention some general rules of programming that apply to all programs, whether they have input or not.
Actually we will be almost exclusively concerned with input, so I've not much to say about programs lacking input.
***
Я собираюсь рассказать вам, как написать программу.
Это - определенная программа; т.е. программа с определенной структурой и возможностями.
В частности, это - программа, которая может быть строго определенным способом расширена до целого комплекса, и, соответственно, стать способной решать комплексные проблемы.
Одна из проблем, которые придется рассмотреть - проблема сложности.
Как вы можете управлять вашей программой так, чтобы она осталась простой?
Сначала я попробую абстрагироваться от проблем ввода.
Правда, так как эти проблемы очень важны, долго рассматривать программы без ввода не получится.
***
By admitting input, a program acquires a control language by which a user can guide the program through a maze of possibilities.
Naturally, this increases the flexibility of the program, it also requires a more complex application to justify it.
However it is possible to achieve a considerable simplification of the program, by recognising that it needs a control language as a tool of implementation.
***
Допуская ввод, программа получает язык, позволяющий пользователю управлять ее работой.
Естественно, это увеличивает гибкость программы, но требуют ли этого условия применения программы?
Есть возможность достичь значительного упрощения программы, используя ввод для управления ее выполнением.
***
The next step is a problem-oriented-language.
By permitting the program to dynamically modify its control language, we mark a qualitative change in capability.
We also change our attention from the program to the language it implements.
This is an important, and dangerous, diversion.
For it's easy to lose sight of the problem amidst the beauty of the solution.
***
Следующий шаг - проблемно-ориентированный язык.
Разрешая программе динамически изменять свой язык управления, мы получаем качественное изменение способностей.
Так мы переключаем наше внимание с программы на язык управления.
Это и важно, и опасно.
Здесь очень легко потерять из виду проблему, увлекшись красотой решения.
***
In a sense, our program has evolved into a meta-language, which describes a language we apply to the application.
But having mentioned meta-language, I want to explain why I won't use the term again.
You see things get pretty complicated, particularly on a philosophic level.
To precisely describe our situation requires not 2 levels of language - language and meta-language - but a least 4 levels.
To distinguish between these levels requires subtle arguments that promote not clarity but confusion.
Moreover, the various levels can often be interchanged in practice, which reduces the philosophic arguments to hair-splitting.
***
В некотором смысле, наша программа превратилась в метаязык, описывающий язык, на котором написано приложение.
Но метаязык термин для нас неподходящий.
Мы тут не философией занимаемся.
Для точного описания нашей ситуации двух уровней - язык и метаязык - не хватит, нужно не меньше четырех.
Разделить их очень трудно.
Кроме того, в различных случаях, встречающихся на практике, уровни могут перепутываться очень замысловато.
***
A problem-oriented-language can express any problem I've encountered.
And remember, we're not concerned with the language, but with the program that makes the language work.
By modifying the language we can apply the same program to many applications.
However there are a class of extensions to the language that constitute another qualitative change.
They don't increase the capacity of the program, but the increase the capability of the language.
That is, they make the language more expressive.
We will consider some such extensions in Chapter 8.
I gathered them together chiefly because they share the common property that I don't quite comprehend their potential.
For example, I think the language applies the concepts of English.
***
Проблемно-ориентированный язык может описать любую проблему, из тех, с которыми я сталкивался.
И помните, мы занимаемся не языком, но программой, которая реализует язык.
Изменяя язык, мы можем применять ту же самую программу для других целей.
Однако имеется класс расширений языка, которые дают новое качество.
Они не увеличивают применимость программы, но расширяют способности языка.
Делают язык более выразительным.
Мы рассмотрим некоторые из таких расширений в Главе 8.
Я собрал их вместе, в основном, потому, что одинаково их недопонимаю.
Например, я думаю, что язык нужно обсуждать в концепциях человеческих языков.
***
Finally, I want to describe a process whereby you can implement this program in machine language.
That is, a bootstrap technique whereby a basic program can modify and expand itself.
***
Наконец, я хочу описать процесс реализации программы на языке машины.
Т.е. процесс загрузки и саморазвертывания программы.
***
I hope you find the ideas I describe of value to you.
In particular, I hope that you will agree that the program I describe has a certain inevitability; that it must do certain things, it must do them in a certain order, and that a certain set of conventions yield an optimal solution.
***
Я надеюсь, что вам понравятся изложенные идеи.
В частности, я надеюсь, что Вы согласитесь, что программа, которую я описываю, в каком-то смысле оптимальна, т.к. следует объективным закономерностям.
***
I've gone to some lengths to simplify.
I hope that you don't find too many violations of the Basic Principle, for it's much easier to elaborate upon a program than it is to strip it to basics.
You should feel free to build upon my basic routines, provided that you recognise that you are adding a convenience.
If you confuse what is expedient with what is necessary, I guarantee your program will never stop growing.
***
Пытаясь говорить просто, я затянул свои объяснения.
Я надеюсь, что вы не сочтете это злостным нарушением Основного Принципа.
Легче было сказать обо всем этом сейчас, чем возвращаться потом.
Если вам действительно удобно, вы можете использовать мои подпрограммы.
Но, если вы путаете то, что полезно, с тем, что необходимо, ваши программы будут расти бесконечно.
***
You will notice a lack of flow-charts.
I've never liked them, for they seem to include a useless amount of information - either too little or too much.
Besides they imply a greater rigidity in program structure than usually exists.
I will be quite specific about what I think you should do and how you should do it.
But I will use words, and not diagrams.
I doubt that you would give a diagram the attention it deserved, anyway.
Or that I would in preparing it.
***
Я не использую блок-схемы.
Я никогда не любил их, поскольку считаю, что они местами избыточны, а местами недостаточны.
Кроме того, они подразумевают большую жесткость в структуре программы, чем существует реально.
Я буду давать конкретные рекомендации, но я буду использовать слова, а не блок-схемы.
Блок-схемы лишь отняли бы время - и у меня, и у вас.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\2. PROGRAMS WITHOUT INPUT / ПРОГРАММЫ БЕЗ ВВОДА
ТЕКСТ
The simplest possible program is one that has no input.
That is a somewhat foolish statement, but if you'll give me a chance to explain we can establish some useful definitions.
First consider the word "input".
I want to use it in a specific sense:
 * Input is information that controls a program.
 In particular, I do not consider as input:
 * Moving data between media within the computer. For instance,
 ** copying tape onto disk, or disk into core.
 * Reading data into the computer. This is really a transfer between media:
 ** from card to core.
***
Самая простая возможная программа - та, которая не имеет никакого ввода.
Это - дурацкое заявление, но если вы дадите мне шанс, я попытаюсь объяснить, чтобы затем дать полезные определения.
Сначала рассмотрите слово "ввод".
Я хочу использовать его в определенном смысле:
 * Ввод - информация, которая управляет программой.
 В частности, я не рассматриваю как ввод:
 * Перемещение данных между устройствами компьютера. Например,
 ** копирование ленты на диск, или диска в ОЗУ.
 * Считывание данных. Это - опять обмен между устройствами. Например,
 ** с перфокарты в ОЗУ.
***
However, data very often has input mixed with it - information that identifies or disposes of the data.
For example, a code in col. 80 might identify a card.
It is input, the rest of the card probably data.
Many programs have input of a kind I shall disregard: operating systems use control cards to specify which files to assign, which subroutines to collect, etc.
Such information is definitely input to the operating system.
Although it may affect the operation of your program, ignore it because it is not under your control - unless your program is the operating system itself.
***
Однако, при считывании данных может осуществляться и управление - для опознания данных или указания способа их использования.
Например, литера в 80-й колонке может идентифицировать перфокарту.
Это - ввод, остальная часть карты, вероятно, данные.
Множество программ имеют ввод вида, который я буду игнорировать: например, операционные системы используют управляющие карты, чтобы определить, какие файлы и подпрограммы нужно использовать, и т.д.
Такая информация - определенно ввод для операционной системы.
Но для вашей программы они не ввод, хотя они и влияют на ее работу.
***
In order to sharpen your recognition of input, let me describe a program that has input.
Consider a program that fits a smooth curve through measured data points.
It needs a lot of information in order to run: the number of data points, the spacing between points, the number of iterations to perform, perhaps even which function to fit.
This information might be built into the program; if it is not, it must be supplied as input.
The measured data itself, the object of the entire program, is not input; but must be accompanied by input in order to to intelligible.
***
Чтобы уточнить понятие ввода, позвольте мне привести пример программы.
Рассмотрим программу, которая строит кривую по нескольким точкам.
Требуется ввести много параметров: число точек, единица квантования, число итераций и т.д.
Эта информация могла бы быть включена в программу; если этого не было сделано, ее надо ввести.
Координаты точек - не ввод, но они должны быть снабжены вводом, чтобы было можно их интерпретировать.
***
A program that has no input may be extremely complex.
Lacking input simply means the program knows what to do without being told.
That built into the code is all the information needed to run.
If you are willing to re-compile the program, you can even modify it without input.
***
Программа, которая не имеет никакого ввода, может быть чрезвычайно сложна.
Отсутствие ввода просто означает, что программа знает, что делать без того, чтобы спрашивать об этом.
Вся необходимая для этого информация уже присутствует в коде.
Если вы желаете заново пресобрать программу, вы можете эту информацию изменить.
***
But I'll be viewing programs from the input side.
I'll be ranking programs according to the complexity of their input and I plan to demonstrate that a modest increase in the complexity of input can provide a substantial decrease in the complexity of the program.
From this point of view, a program with no input is simple.
***
Я буду рассматривать программы, отталкиваясь от их ввода.
И я покажу, что небольшое усложнение ввода может обеспечивать существенное уменьшение сложности программы.
С этой точки зрения, программа без ввода проста.
***
Since I'm going to be talking about input, a program without input leaves me nothing to talk about.
But I want to make some points about programs in general, so I'll make them here.
For one thing, we will be climbing a tree.
When we reach the higher branches we'll have enough trouble keeping our balance without worrying about the roots.
***
Так что о программах без ввода, вроде бы, и говорить не стоит.
Однако, я хочу сделать некоторые замечания.
Не хочется оставлять в тылу неясные моменты.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\2. PROGRAMS WITHOUT INPUT / ПРОГРАММЫ БЕЗ ВВОДА\2.1. CHOOSING A LANGUAGE / ВЫБОР ЯЗЫКА
ТЕКСТ
We shall be less interested in computer language than most programmers.
For 3 reasons: First, we will eventually define our own application-oriented language.
How we implement that language is of lesser concern.
Second, you probably aren't in a position to pick a language.
Your installation probably has reduced your choice to nil.
Third, we won't be talking about problems at the language level.
This last comment deserves elaboration.
I assume that you are already a competent programmer.
I'm not interested in teaching you how a computer works, or how a language conceals the computer.
I want to talk about problems common to all programs in a machine-independent and language-independent manner.
I will leave to you the details of implementation.
I am not going to write a program, I am going to show you how to write a program.
***
Мы будем меньше заинтересованы выбором языка, чем большинство программистов.
По трем причинам: Во-первых, мы, в конце концов, определим наш собственный проблемно-ориентированный язык.
На чем он будет базироваться - уже второй вопрос.
 Во-вторых, вы, скорее всего, не свободны в выборе языка.
Ваша практика, вероятно, уже уменьшила ваш выбор до нуля.
 В-третьих, мы не будем говорить о проблемах, возникающих на уровне языка.
 О последнем - по-подробнее.
Я предполагаю, что вы уже компетентный программист.
Я не буду учить вас, как работает компьютер, или, как язык скрывает компьютер.
Я буду говорить о машинно-независимых и языково-независимых проблемах.
Детали реализации я оставлю вам.
Я не собираюсь писать программу, я покажу вам, как писать программу.
***
I hope that you are a good enough programmer to think in computerese.
That is, as someone discusses their application, you interpret it in terms of computer operations: a loop here, a calculation there, a decision...
The details are largely irrelevant, the gross structure of the program is of concern.
***
Я надеюсь, что вы достаточно хороший программист, чтобы думать по-компьютерному.
То есть сразу переводите сказанное в термины действий компьютера: здесь - цикл, там - вычисление, выбор...
Детали несущественны, но, в основном, структура программы т.о. вырисовывается.
***
As you put more thought into the problem, you begin to relate it to your particular machine: this data comes off tape, that loop is stopped by..., this is really a 3-way branch. you modify the problem as required by your particular hardware configuration.
***
Углубляясь в проблему, начинаете привязываться к своему компьютеру: эти данные с ленты, это останов цикла..., это - ветвление на три альтернативы.
Вы переводите проблему на язык своей машины.
***
Finally, you must translate your program into a particular language.
You encounter a new class of problem: your FORTRAN won't run that loop backwards, COBOL doesn't have a 3-way branch, you couldn't access the data that way...
Current languages put more constraints on this last coding process than they should.
***
Наконец, вы переводите программу окончательно.
Появились новые проблемы: FORTRAN не имеет нужного цикла, COBOL - ветвления на три, доступ к некоторым данным невозможен...
Существующие языки очень сильно ограничивают процесс окончательного кодирования своими структурами.
***
I'll have a bit more to say about languages, but mostly we'll stay at the most abstract level - talking computerese.
We won't be talking in meta-language exclusively.
I may tell you to load an index-register or to jump on negative and you'll have to translate that into the equivalent for your computer and language.
***
Я не буду обсуждать эти тонкости, но останусь на уровне общего компьютерного жаргона.
Мы не будем говорить и исключительно на метаязыке.
Я могу указать вам на необходимость загрузить что-то в индексный регистр или перейти, если значение отрицательно, а уж вы переводите это на свой язык.
***
Now let's look at the major failing of higher-level languages.
In attempting to achieve machine-independence and to be applicable to a wide range of applications, they only give you acess to a fraction of the capabilities of your computer.
If you compare the number of loop control instructions on your computer to the number of loop constructs in your language, you'll see what I mean.
***
Теперь давайте посмотрим на главный минус языков высокого уровня.
В попытке достичь независимости от машины и как можно большей универсальности, они дают доступ к очень небольшой доле возможностей компьютера.
Если вы сравните число инструкций цикла вашего компьютера с числом конструкций цикла вашего языка, вы поймете.
***
Let me indulge in a 1-sentence characterizatioдn of 3 popular languages to illustrate their restricted capabilities:
 * FORTRAN is great at evaluating complicated algebraic expressions.
 * COBOL is great a processing packed decimal data.
 * ALGOL is great a providing loops and conditional statements.
 Each language can be very efficient at its sort of job.
But if you want conditional loops involving complicated decimal expressions you have a problem.
We are going to be concerned with efficiency.
We are going to do some things that if we don't do efficiently, we can't do at all.
Most of these things will not fit in the framework of a higher-level language.
Some will; others will demand controlled use of the hardware that a compiler doesn't permit.
For example, upon entering a FORTRAN subroutine it may save the registers it uses.
If you didn't need to save them you've wasted time and space.
An ALGOL subroutine may expect registers available that you have reserved; then you have to save them.
It may well cost you more effort to interface with the compiler than it saves you in return.
***
Разделаюсь с тремя наиболее популярными языками в одну строчку:
 * FORTRAN - хорошо считает сложные выражения.
 * COBOL - хорошо обрабатывает упакованные десятичные данные.
 * ALGOL - имеет развитые структуры управления.
 Каждый язык эффективно справляется со своей работой.
Но если вам надо все разом, у вас проблема.
Нас волнует эффективность.
Если нельзя сделать что-то эффективно, лучше вообще не делать.
Большинство нужных нам вещей на языках высокого уровня не реализовать.
Часто они требуют прямого доступа к аппаратуре, которого компилятор дать не может.
Например, при входе в FORTRAN-подпрограмму регистры сохраняются.
Это не нужно, если на них никто не покушается.
В ALGOL - наоборот.
Подобные неудобства не оправдываются простотой вызовов подпрограмм.
***
Moreover, none of these languages are very good at moving things around.
Most statements are data transfers - count them in your latest program.
There is a profound philosophical truth concealed in how much we can accomplish by moving numbers around.
If we can move several things with one instruction, or put the same register several places - we can't afford not to.
***
Кроме того, все эти языки грешат лишними пересылками данных.
Посчитайте сами: большинство операторов в программе - перемещения (присваивания).
Целая философия заключается в том, чего можно достичь, просто перемещая данные.
Если мы можем перемещать несколько значений одной инструкцией или копировать регистр сразу в несколько мест - мы не должны отказываться от таких возможностей.
***
You will have to code in assembler!
Not the whole program, if you insist, but the important parts that we'll be concentrating on.
You might be able to do some of these in FORTRAN, but it simply isn't worth the effort.
I'll show you where higher-level subroutines can go, and I think you'll agree there is good reason to restrict them to that function.
***
Вы будете должны писать на языке ассембера!
Не всю программу, но те важнейшие части, которые мы будем обсуждать.
Вы можете реализовать некоторые из них на FORTRAN, но это не окупит усилий.
Я покажу, где можно будет обойтись высокоуровнеми подпрограммами, и вы увидите, что этим и стоит ограничиться.
***
I recognise the drawbacks of assembler and chafe at them as much as anyone.
I don't like to punch and debug 10 times as many cards either.
But I will in order to get the performance I need.
By the way, I will use the word "compiler" to include assembler; we will compile an assembly language program.
***
Меня, как и всех вас, раздражают недостатки языка ассемблера.
Я, как и все, не люблю перенабивать по 10 раз огромное количество перфокарт.
Но он здесь необходим для дела.
Между прочим, я буду, для общности, называть ассемблер компилятором.
***
Later I'll show you how to write a program in a forgotten language: machine language.
By that I mean sitting at the console and entering absolute, binary instructions with the switches.
Depending on the hardware and software available, and the nature of your application, it may just be the best language of all.
***
Позже я покажу вам, как писать программы на забытом языке: в кодах.
Щелкать тумблерами на пульте прямого доступа в память.
Иногда так будет удобнее всего.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\2. PROGRAMS WITHOUT INPUT / ПРОГРАММЫ БЕЗ ВВОДА\2.2. CHOOSING A COMPUTER / ВЫБОР КОМПЬЮТЕРА
ТЕКСТ
Of course I don't expect that you're in a position to choose a computer.
Nor am I going to discuss hardware at all.
But I do have a mental image of the kind of computer, and explaining it may help you understand some of my comments.
***
Конечно я не надеюсь, что вы можете свободно выбрать себе компьютер.
И при этом я не собираюсь обсуждать аппаратные средства вообще.
Но я хочу описать некоторые общие идеи.
***
Most applications can be programmed very nicely on a small computer: say 4K of 16-bit words with a typical instruction set, floating-point hardware if needed.
If, that is, the computer is augmented with random access secondary memory, which I will call disk.
The capacity of disk is unimportant, even a small disk providing plenty for our purposes, and is determined by the application.
However, it is important to be able to copy the disk onto another disk, or tape, for back-up.
Thus I envisage a small computer with 2 secondary memories, and of course a keyboard or card-reader and printer or scope for input and output.
***
Большинство из обсуждаемого может быть вполне запрограммировано на маленьком компьютере: ОЗУ в 4k 16-битных слов, типичный набор инструкций, аппаратные средства поддержки вычислений с плавающей точкой, если необходимо.
Дополнительную память, которой может быть оснащен компьютер, буду обобщенно называть диском.
Емкость диска для нас практически несущественна.
Однако, важна способность копировать его на ленту или другой диск.
Т.о. я имею виду компьютер с двумя накопителями, клавиатурой или устройством для чтения перфокарт для ввода и принтером или экраном для вывода.
***
Instead of running applications in serial on a small computer, you can run them in parallel on a large one.
I see no advantage, for the amount of core and disk you can afford to use for a single application is about that available on a small computer.
You don't gain speed, you suffer from a complex operating system, and you have a enormous capital investment.
But the configuration I have in mind remains the same: 4K of core, secondary memory and input/output device.
***
Безразлично, будете ли вы запускать приложения последовательно на маленьком компьютере или параллельно - на мощном.
Безразлично, насколько велики ОЗУ и диск.
Разница не в скорости, а в потребной операционной системе и стоимости компьютера.
Нужно, по-прежнему, 4k ОЗУ, диски и устройства ввода/вывода.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\2. PROGRAMS WITHOUT INPUT / ПРОГРАММЫ БЕЗ ВВОДА\2.3. ARRANGEMENT AND FORMATTING / МЕЛОЧЕВКА
ТЕКСТ
Now I'm goiong to tell you how to write a program.
Independent of language or computer.
Things you ought to be doing already, but probably aren't because on one ever told you to.
Little things.
But if you don't do them you won't have a good program; and we're going to write a good program.
Remember the Basic Principle! If you didn't read the Introduction, do it now.
***
Теперь я готов объяснять, как писать программу.
Независимо от языка или компьютера.
Но, вероятно, не совсем так, как вы ожидали.
Начнем с мелочевки.
Без нее не будет хорошей программы, которую мы хотим.
Помните Основной Принцип!
Если вы не читали Введение, сделайте это сейчас.
***
Declare all variables.
Even in FORTRAN when you don't have to.
Everyone likes to know what parameters you are using, presumably need to use; likes to count them, to see if they could use fewer; is annoyed if you slip one in without mentioning it.
***
Объявите все переменные.
Даже в FORTRAN, где это не обязательно.
Это здорово помогает при чтении программы, сразу видно, что и как вы используете.
***
Define everything you can before you reference it.
Even in FORTRAN when you don't have to.
Why not?
You don't like to read a program backwards either.
'Everything you can' means everything except forward jumps.
You better not have many forward jumps.
***
Определяйте ссылки до того, как их использовать.
Даже в FORTRAN, где это не нужно.
Почему нет?
Никто не любит читать задом наперед.
Скачки вперед лучше свести к минимуму.
***
Make variables as GLOBAL as possible.
Why not?
You can save some space and clarify your requirements.
For instance, how many Is, Js and Ks do you need?
In most cases a single copy in COMMON would suffice (you have to declare them, remember, and may as well put them in COMMON); you can redefine it locally if you must; and it is of interest that you must.
***
Делайте переменные по возможности GLOBAL.
Почему нет?
Вы можете экономить место и имена.
Например, сколько I, J, и K Вам нужно?
В большинстве случаев достаточно иметь их в единственном экземпляре, засунутом в COMMON блок.
***
Indent!
High-level languages, even modern assemblers, fail to insist that you start in column x.
But you do!
The unbelievable appeal of a straight left margin!
Paper is 2-dimensional.
Use it!
If you indent all statements inside a loop, it's obvious at a glance the extent of the loop.
If you indent conditionally executed statements you'll find that nested conditions sort themselves out - automatically.
If you indent little statements you wish you didn't have to include (I = I) you'll find they intrude less as you glance through the listing.
Always indent the same amount, 3 spaces/level is good.
Be consistant and be accurate.
Sloppy indenting is obvious.
***
Делайте отступы!
Современные языки высокого уровня совсем не требуют, чтобы вы начинали строку в колонке x.
Но вы делайте именно так!
Это красиво!
Бумага двумерная.
Используйте это!
И циклы сразу видны.
И - ветвления.
И ошибки виднее.
Всегда используйте одинаковый шаг отступов (3 сойдет).
Будьте педантичны.
Небрежность наказуема.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\2. PROGRAMS WITHOUT INPUT / ПРОГРАММЫ БЕЗ ВВОДА\2.4. MNEMONICS / ИМЕНА
ТЕКСТ
You will find as you read, that I have strong opinions on some subjects and no opinion of others.
Actually I have strong opinions on all, but sometimes I can't make up my mind which to express.
Fortunately it leaves you some decisions to make for yourself.
***
Вы заметите, что насколько я уверен относительно одних вещей, настолько же неуверен относительно других.
Точнее, может и уверен, но доходчиво выразить не получается.
Это оставляет вам пространство для проявления самостоятельности.
***
Use words with mnemonic value.
Unfortunately what is mnemonic to you may not be mnemonic to me; and I'm the one who judges.
Also unfortunately, mnemonic words tend to be long, which conflicts with:
***
Используйте осмысленные слова.
К сожалению, осмысленность всеми понимается по-своему; но я всегда прав.
Также, к сожалению, чем слова осмысленнее, тем они длиннее, это противоречит следующему абзацу.
***
Use short words.
You don't want to type long words, and I don't want to read them.
In COBOL this means avoid dashes and avoid qualification, though both can be useful upon occassion.
***
Используйте короткие слова.
Длинные лень писать и читать.
В COBOL это означает, надо избегать составных слов (хотя, они иногда и полезны).
***
So let me suggest a compromise: abbreviate in some consistant fashion and stick to your own rules.
I can probably figure out the rules you're using.
You might even mention them in a comment.
***
Предлагаю компромисс: придумайте свою систему сокращений и строго ее придерживайтесь.
Если система не очень заумная, к ней и другие привыкнут.
Можете, на всякий случай, описать ее в комментариях.
***
Use words with the correct grammatical connotations: nouns for variables, verbs for subroutines, adjectives for...
Do not use clever words (GO TO HELL).
Their cuteness wears off very fast and their mnemonic value is too subjective.
Besides they offer an unwanted insight into your personality.
***
Используйте слова в правильной форме: существительные для переменных, глаголы для подпрограмм, прилагательные для...
Не используйте бессмысленные слова (GO TO HELL).
Их очарование быстро проходит, а смысла не прибывает.
К тому же, их применение отдает эксгибиционизмом.
***
Use comments sparingly!
(I bet that's welcome.)
Remember that program you looked through - the one with all the comments?
How helpful were all those comments?
How soon did you quit reading them?
Programs are self-documenting, even assembler programs, with a modicum of help from mnemonics.
It does no good to say:
***
Комментируйте экономно!
(Держу пари, вы этого ждали).
Припомните последнюю виденную откомментированную программу?
Большая была польза от комментариев?
Как скоро вам надоело их читать?
Осмысленные имена помогают сократить комментарии до минимума.
Поэтому нельзя писать:
***
LA B . Load A with B
***
In fact it does positive bad: if I see comments like that I'll quit reading them - and miss the helpful ones.
What comments should say is what the program is doing.
I have to figure out how it's doing it from the instructions anyway.
A comment like this is welcome:
***
Привыкнув к дурацким комментариям, я могу пропустить и полезные.
Комментарий должен описывать действие программы по-человечески.
Действие в компьютерных терминах уже описано самой инструкцией.
Должно быть что-то вроде:
***
COMMENT SEARCH FOR DAMAGED SHIPMENTS
***
Mnemonics apply to variables and labels (You can even get mnemonic value in FORTRAN statement numbers).
Where possible you should apply them to registers also.
You may do well to assign several names to the same entity, to indicate its current use.
However, don't waste effort naming things that don't need names.
If you need a counter, use I, J, K; to assign a big name (EXC-CNTR) to an insignificant variable is no help.
***
Нужно давать осмысленные имена переменным и меткам (Осмысленные номера строк в FORTRAN?).
Осмысленные имена регистров?
Можно даже придумать несколько имен одной вещи, чтобы обозначить цель ее текущего использования.
Правда, есть вещи, которые не нуждаются в именах.
Счетчики? I, J и K; придумывать какое-нибудь EXC-CNTR смысла нет.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\2. PROGRAMS WITHOUT INPUT / ПРОГРАММЫ БЕЗ ВВОДА\2.5 ROUTINES AND SUBROUTINES / ПОДПРОГРАММЫ
ТЕКСТ
There are two words I need to establish precise definitions for: A subroutine is a set of instructions that return from whence they came.
A routine is a set of instructions that return to some standard place.
To put it another way, you jump to a routine, you call a subroutine.
The difference is retained in higher-level languages: GO TO versus CALL or ENTER.
***
Я ввел два термина, которые нельзя путать: подпрограмма - возвращает управление туда, откуда ее вызвали.
Программа - возвращает управление в стандартное место.
Иначе говоря, подпрограмму вызывают, а к программе переходят.
На языке высокого уровня: CALL или ENTER против GO TO.
***
So what?
Subroutines suffer from nesting.
If you call a subroutine from within a subroutine you must somehow save the original return address.
I'm sure you can rattle-off a dozen hardware/software ways of doing this.
They're all expensive.
***
И что?
Для подпрограмм требуется поддержка рекурсиии.
Вызывая подпрограмму из подпрограммы, вы должны где-то сохранить адрес возврата.
Я уверен, что вы знаете много аппаратных и программных способов это сделать.
Все они дороги.
***
If you jump somewhere, not intending to come back, you can save trouble, time and space.
But only if you really never come back.
To simulate a subroutine call is worse than ever.
***
Переход к программе, т.о. экономит место и время.
Но только, если вам действительно никуда не надо возвращаться.
Вызывать программу как подпрограмму еще более накладно.
***
Higher-level languages conceal this by nesting automatically.
The best solution is to nest if you must, but only when you must, and never to save the same address more than once.
That is, upon entering a subroutine, save the return address if you intend to call other subroutines.
When you're finally ready to return, then un-nest.
***
Языки высокого уровня скрывают и автоматизируют весь механизм сохранения адреса.
Лучше было бы это делать только в том случае, если действительно необходимо из подпрограммы вызвать новую подпрограмму.
***
Obvious?
Perhaps.
But it's usually done wrong!
Sometimes the problem only arises with recursive subroutine calls; depending on hardware.
It always arises with re-entrant programming.
***
Очевидно?
Возможно.
Но как часто это делается неправильно!
Часто возникает проблема в случае рекурсивных вызовов.
***
So we can get in and out of routines and subroutines.
How do we pass parameters?
Again, there are as many answers as computers, languages and programmers.
We shall standardize: you pass what you can in registers; the rest via a push-down stack.
***
Так что можно брать за основу и программы, и подпрограммы.
Как мы передаем параметры?
Опять, очень много вариантов.
Стандартно: то, что влезает - в регистрах, остальное - через стек.
***
It is extremely important for routines to be able to communicate efficiently.
I hope you are aware of the cost of a FORTRAN subroutine call.
I consider it a basic flaw in the language.
We will be moving among so many subroutines that failing to minimize overhead could easily halve our running speed.
***
Наша цель - эффективная связь программ.
Я надеюсь, что вы знаете сколько весит FORTRAN вызов.
Я считаю это основным недостатком данного языка.
У нас будет очень много подпрограмм, значит, вызывать их надо будет быстро.
***
You must also consider the value of a subroutine.
It isolates a logical function and it eliminates repeated instructions.
The first is acceptable only at minimal cost.
The second only if space is saved: a 1-instruction subroutine is ridiculous; a 2-instruction must be called from 3 places to break even.
Be careful!
***
Важен также вопрос о необходимости подпрограм.
Обособить в подпрограмму расчет некой законченной функции или использовать подпрограмму для избежания повторения одинакового кода?
Первое приемлемо только при минимальной стоимости.
Второе тоже может быть невыгодгно: подпрограмма из одной инструкции смешна; из двух - должна вызываться минимум из трех мест, чтобы оправдаться.
Будьте осторожны!
***
Finally, it is important to use registers efficiently.
Assign registers for specific purposes and use them consistently.
Re-assign registers if you must to avoid conflicts.
Do not move data from one register to another; see that it is where it belongs in the first place.
***
Наконец, важно использовать эффективно регистры.
Назначьте регистрам определенные применения и будьте последовательны.
Переназначте, чтобы избежать конфликтов.
Не перемешайте данные из одного регистра в другой; берите значение со старого места.
***
When I say register, I'm obviously thinking assembler.
However, you will have to simulate the function of registers with subscripts, etc. in other languages, and the same considerations apply.
***
Когда я говорю регистр, я очевидно подразумеваю язык ассемблера.
Однако, вы можете моделировать регистры массивом.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ
ТЕКСТ
A program without input is a program with a single task.
A program with input may have many tasks, which it will perform as directed by its input.
Thus I consider input to be control information, and the control information to define a control language.
We shall have a problem in this chapter, for we are discussing a loop.
Each element of the loop depends on its predecessor and successor, and we have nowhere to start.
I have done the best I could, but am obliged to refer to things before I define them.
Especially in the next section where I try to justify some of the details we'll encounter immediately after.
***
Программа без ввода - программа для одной задачи.
Программа с вводом может решать много задач - столько, сколько сушествует вариантов ввода.
Я полагаю, что ввод используется для управления программой, и существует язык управления.
Проблема этой главы в ее зацикленности.
Непонятно с чего начать.
Я сделал, что мог, но ссылки вперед остались.
Особенно в следующем разделе.
***
This chapter is full of details, more than I anticipated when I started it.
Although I'm surprised there's so much to say, I think it's all of value.
I only caution you not to get lost in the details; the structure, the concept of the program are what is important.
***
Эта глава полна неожиданными для меня деталями.
Но они нужны.
Я только предостерегаю вас, не потерять за деревьями леса; структура, концепция программы - вот, что важно.
***
To set the stage, let me briefly outline how our program must operate.
You are sitting at a keyboard typing input.
You type a string of characters that the computer breaks into words.
It finds each word in a dictionary, and executes the code indicated by the dictionary entry, perhaps using parameters also supplied by the entry.
The process of reading words, identifying them and executing code for them is certainly not unusual.
I am simply trying to systematize the process, to extract the inevitable functions and see that they are efficiently performed.
***
Как наша программа должна работать?
Вы сидите за клавиатурой, набиваете ввод.
Вы напечатаете строку, которую компьютер разбивает на слова.
Он находит каждое слово в словаре, и выполняет код, прописанный в словарной статье, возможно используя параметры, также указанные в статье.
Процесс чтения слов и их интерпретации, конечно не является чем-то необычным.
Я просто попробую разбить этот процесс на краеугольные функции и выполнить их наиболее эффективно.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.1. NOUNS AND VERBS / СУЩЕСТВИТЕЛЬНЫЕ И ГЛАГОЛЫ
ТЕКСТ
I've mentioned the dictionary and we'll soon examine the details required to implement it.
But first I'd like to talk a bit about individual entries to try and give you a feel for what we're doing.
We're going to read words from your input, find them in the dictionary, and execute their code.
A particular kind of word is a literal, a word that identifies itself:
***
Я упомянул словарь, и мы скоро его рассмотрим.
Но сначала я хотел бы поговорить немного об отдельных словарных статьях.
Мы будем читать вводимые слова, находить их в словаре, и выполнять их код.
Специфический вид слова - литерал, слово, которое обозначает само себя:
***
1 17 -3 .5
***
We won't find such words in the dictionary, but we can identify them by their appearance.
Such words act as if they were in the dictionary, and the code executed for them places them on a push-down stack.
Other words act upon arguments found on this stack, for example:
***
Мы не будем хранить такие слова в словаре, но мы можем идентифицировать их по их виду.
Такие слова действуют, как будто бы они есть в словаре, и у них есть код, пропихивающий их значение в стек.
Некоторые другие слова работают со значениями на стеке:
***
+ add the last 2 numbers placed on the stack, leave the sum there.
 , type the number on top of the stack, and remove it from the stack.
 If we type a phrase such as:
***
+ сложить два верхних значения на стеке, оставить там вместо них сумму.
 , напечатать число на вершине стека и удалить его из стека.
 Например:
***
1 17 + ,
***
We are saying: put 1 onto the stack, 17 onto the stack, add them, and type their sum.
Each word performs its specific, limited function; independently of any other word.
Yet the combination of words achieves something useful.
In fact if we type:
***
Т.е. поместить на стек 1, затем - 17, сложить их и напечатать сумму.
Каждое слово исполняет свою ограниченную функцию независимо от любого другого слова.
В целом же, получается что-то полезное.
Например:
***
4837 758 + -338 + 23 + 4457 + -8354 + ,
***
we can even do something non-trivial: each number is added to the sum of its predecessors, and the result typed.
This is basically the value of our program.
It lets us combine simple operations in a flexible way to accomplish a task.
***
Надо же, каждое новое число добавляется к накопленной сумме его предшественников, и, в конце, результат печатается.
В этом - основная ценность нашей программы.
Мы можем комбинировать слова, чтобы в итоге получить решение задачи.
***
Let's look more closely at the words we used above.
They fall into 2 distinct classes; English even provides names for them:
 * Nouns place arguments onto the stack.
 * Verbs operate upon arguments on the stack.
***
Давайте рассмотрим употребленные слова.
В человеческом языке мы бы назвали их:
 * существительными - те, что кладут значения на стек;
 * глаголами - те, что работают со значениями на стеке.
***
All words cause code to be executed.
However in the case of nouns, the code does very little: simply place a number on the stack.
Verbs are considerably more varied in their effects.
They may do as little as add 2 arguments, or as much as type out a result - which requires a great deal of code.
***
Все слова имеют код исполнения.
Однако, в случае существительных, код делает очень немного: просто размещает число на стеке.
Глаголы значительно разнообразнее.
Они складывают значения, печатают их,.. или, что там еще прописано в их коде.
***
In effect, nouns place arguments onto the stack in anticipation of verbs that will act upon them.
The word anticipation is a good one.
In order to keep our verbs simple, we promise that their arguments are available.
We could define a verb that reads the next word and uses it as an argument; but in general we don't.
It is not the business of a verb to provide its own arguments; we use nouns to provide arguments before we execute the verb.
In fact, this substantially simplifies our program.
***
Конечно, существительные готовят аргументы для глаголов.
Но глаголы этого не ждут.
Они надеются, что аргументы для них уже подготовлены.
Мы могли бы определить глагол, который читает следующее слово и использует его как аргумент; но не стали так делать.
Это - не дело глагола, заботиться о своих аргументах; для этого перед ними помещаются существительные.
На самом деле, это существенно упрощает нашу программу.
***
We can extend the characterization of entries a little further.
Verbs have different numbers of arguments:
 * Unary verbs modify the number on the stack.
 * Binary verbs combine 2 arguments to leave a single result.
***
Мы можем продолжить классификацию слов.
Глаголы имеют различное число аргументов:
 * одноместные глаголы изменяют значение на стеке;
 * двухместные глаголы берут два аргумента, и кладут на их место результат.
***
Arithmetic operations are binary, arithmetic functions are usually unary.
However, there are more verbs than we can usefully catagorize.
For example, the verb "," that types the stack is not unary, since it removes the number from the stack.
Although it does have a single argument.
Another way of distinguishing verbs is:
 * Destructive verb removes its arguments from the stack.
 * Non-destructive verb leaves its arguments on the stack.
***
Арифметические операции - двухместные, функции, обычно, одноместные.
Однако, разновидностей глаголов намного больше.
Например, глагол ",", который печатает значение, не одноместный, так как удаляет значение из стека.
Хотя он и имеет единственный аргумент.
Можно классифицировать и с другого конца:
 * разрушающий глагол удаляет аргументы из стека;
 * неразрушающий - нет.
***
Unary and binary verbs, as well as the type verb ",", are destructive.
The verb DUP, which I define to duplicate the top of the stack, is non-destructive.
In general verbs are destructive.
In fact, I deliberately define verbs to be destructive in order to simplify the task of remembering which are and which aren't.
I recommend that you do the same.
Literals are nouns.
We can define other words as nouns; words that use their parameter field to place numbers onto the stack:
 * Constants place the contents of their parameter field onto the stack.
 * Variables place the address of their parameter field onto the stack.
 For example, if PI is a constant, it places 3.14 onto the stack. Thus:
***
Одноместные и двухместные глаголы, как и глаголы типа ",", являются разрушающими.
Глагол DUP, дублирующий вершину стека, является неразрушающим.
Чаще глаголы разрушающие.
Я сделал так специально, чтобы не мучиться с запоминанием, которые какие.
И вам советую.
Литералы - существительные.
Мы можем определять и другие существительные; слова, которые используют свое поле параметра, чтобы размещать значение на стеке:
 * константы размещают значение из поля параметра;
 * переменные размещают адрес поля параметра.
Например, если PI константа, кладущая 3.14 на стек, то:
***
1. PI 2. * / ,
***
reads: place 1. onto the stack, place 3.14 onto the stack, place 2. onto the stack, multiply (2. and PI), divide (1. by 2PI), and type.
Constants are particularly useful when you're using code numbers.
It lets you give names to numbers that might otherwise be hard to remember.
***
- кладем 1. на стек, кладем 3.14 на стек, кладем 2. на стек, умножаем (2. на PI), делим (1. на произведение), печатаем.
Константы особенно полезны, когда вы используете числовые коды.
Имена легче запомнить, чем значения.
***
However the most important nouns by far are literals and variables.
A variable gives a name to a location and not to a value, as elementary programming texts laboriously explain.
However, what higher-level languages conceal is that variables may be used in 2 distinct ways:
 * To name a location from which a value is to be taken.
 * To name a location into which a value is to be stored.
***
Важных существительных немного - литералы да переменные.
Переменная выдает адрес, а не значение, как и положено в теории программирования.
Однако, языки высокого уровня скрывают, что переменные могут использоваться двувмя разными способами:
 * дать адрес, откуда взять значение;
 * дать адрес, куда записать значение.
***
A constant automatically performs the first; and inherently prevents the second (you can't store a value into a constant, for you don't know where the constant came from).
Rather than try to distinguish function by context, as compilers do, we shall define 2 verbs that act upon variables:
 @ replace the address on the stack with its contents.
 = Store into the address on the stack, the value just beneath it on the stack.
 Thus if I type, where X is a variable,
***
Константы способны только на первое (и прячут адрес, чтобы предотвратить второе).
Вместо того, чтобы, как компиляторы, понимать переменную в зависимости от контекста, мы определим для них два глагола:
 @ - заменить адрес на стеке значением по этому адресу;
 = - записать по адресу на вершине стека, значение, лежащее на стеке под ним.
 Т.о., если X - переменная,
***
X @ ,
***
I mean: place the address of X onto the stack, fetch its value, and type.
And if I type,
***
- положить адрес X на стек, заменить его его значением, напечатать значение.
А если,
***
X @ Y @ + ,
***
I mean: fetch the value of X, the value of Y, add, and type.
On the other hand,
***
- сложить значения X и Y, напечатать сумму.
С другой стороны,
***
X @ Y =
***
will: fetch the address of X, then its value, fetch the address of Y, and store the value of X into Y.
But if I type
***
- запомнить значение X в Y.
Но, если я напечатаю
***
X Y =
***
I'm saying: fetch the address of X, the address of Y, and store the address of X into Y.
Maybe this is that I mean to do, it's not unreasonable.
***
- запомниь адрес X в Y.
Возможно это то, что я и хочу сделать.
***
I don't want to belabor the point, for we're getting ahead of ourselves.
But variables require special verbs, one of which (@) is not ordinarily explicit.
Incidently, I originally used the word VALUE for @.
But the verb is used so often it deserves a single character name, and I thought @ (at) had some mnemonic value, besides being otherwise useless.
***
Еще немного объяснений.
Имя глагола @ не очень-то осмысленно.
Сначала я хотел использовать VALUE.
Но глагол используется столь часто, что больше одного символа для него слишком длинно.
***
I urge you to adopt the vereb @.
Although you can conceal it in various ways - we'll discuss one later - it adds needless complication.
Such a useful verb oughtn't be invisible. Besides it lets you store addresses in variables - indirect addressing
***
Я настаиваю на применении этого глагола.
Хотя вы можете вызывать его нявно, это будет бесполезным осложнением.
Такой полезный глагол не должен быть невидим.
К тому же, он позволяет вам хранить адреса в переменных, организуя косвенную адресацию.
***
X Y = Y @ @ ,
***
reads: store the address of X in Y; place the address of Y on the stack, fetch its value (the address of X) fetch its value (the contents of X), and type.
***
- запомнить адрес X в Y; положить на стек адрес Y, заменить его его значением (адресом X), заменить и его его значением (значением X), напечатать.
***
I hope I've given you some idea of how you can put arguments onto the stack and act on them with verbs.
Although I define constants and variables, unary and binary verbs, I hope it's clear that these are only examples.
You must define the nouns and verbs and perhaps other kinds of words that are useful for your application.
In fact, I think that is what programming is all about.
If you have available a program such as I will now describe, once you decide what entries an application requires, you'll find it absolutely trivial to code those entries, and thus complete your problem.
***
Я надеюсь, что объяснил про стек и глаголы.
Надеюсь понятно, что все эти переменные, константы, одноместные и двухместные глаголы - лишь примеры.
Вы можете использовать совершенно другие, удобные для вас виды слов.
В этом, надо думать, и заключается программирование.
Как только мы напишем нашу программу целиком, сами поэкспериментируете.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.2 CONTROL LOOP / ЦИКЛ УПРАВЛЕНИЯ
ТЕКСТ
Our program has a structure that is easy to miss: it is a single loop.
However, it is a loop that is diffuse - scattered among all the code in the program.
Very few instructions are gathered together to form an identifiable loop, so the loop warrants some explanation.
***
Наша программа имеет простейшую структуру - единственный охватывающий цикл.
Однако, код, организующий этот цикл, размазан по всей программе.
Локализовать его ключевые моменты достаточно трудно.
***
We are going to read a word from the input string, look up that word in the dictionary, and jump to the routine it specifies.
Each routine will return to the top of the loop to read another word.
We will be discussing many routines and it will be helpful to have a term to identify "return to the top of the loop to read another word".
I will use the word RETURN; you should provide a standard macro or label in your program for the same purpose.
***
Мы собираемся читать слово из строки ввода, искать его в словаре, и переходить к его программе.
Каждая программа после выполнения вернет нас в начало цикла, чтобы читать другое слово.
Этот возврат управления буду называть RETURN; Вы должны создать в вашей программе соответствующий макрос или метку.
***
Actually, you accomplish 2 purposes: you mark the end of a routine.
And you identify the preceeding code as being a routine, as distinct from a subroutine.
Thus, I use the word RETURN with a totally different meaning from the FORTRAN RETURN statement.
I shall speak of EXITing from a subroutine.
***
Во-первых, этим вы обозначаете конец программы.
Во-вторых, вы утверждаете, что здесь имеет место программа, а не подпрограмма.
Наш RETURN это не тот RETURN, что в FORTRAN.
Возврат из подпрограмм я буду обозначать EXIT.
***
Included in your control loop should be a check that the parameter stack has not exceeded its limits.
This is best done after RETURNing from a routine, and only needs to be done for routines that use the stack.
Thus there are 2 possible RETURN points (actually 3).
***
В цикл должна быть встроена проверка исчерпания стека.
Ее лучше вставить после RETURN, и только для тех программ, которые используют стек.
Т.о. имеются две точки RETURN (фактически - три).
***
The control loop must be efficient.
If you count the instructions it contains, you measure the overhead associated with your program.
You will be executing some very small routines, and it's embarrassing to find overhead dominating machine use.
In particular you don't need to check other than the parameter stack.
***
Наш цикл должен быть вылизан до совершенства.
Его размер - это размер нашей программы.
Вы будете исполнять маленькие программы, и заводить для этого громоздкий механизм не хочется.
В особенности, вы должны исключить все проверки, кроме проверки стека.
***
One more routine belongs in this section: an error routine.
Whenever an error is detected, a routine should jump to ERROR which will type the offending word and an error message.
It will then reset all stacks and the input pointer and RETURN normally.
***
Отметим еще одну важную программу: программу ошибки.
Всякий раз, когда обнаруживается ошибка, программа переходит на ERROR, к коду, который печатает ошибшееся слово и сообщение об ошибке.
Затем последует очистка стеков и ввода и обычный RETURN.
***
The problem of how to treat error messages is an important one.
We are in a position to do a good job: to avoid setting and testing flags; to avoid cascading back through subroutine calls.
By clearing the return stack we eliminate any pending subroutine returns.
By not returning with an error flag, we avoid having the subroutine have to worry about errors.
This simplifies the code, but we must have a standard method of handling problems.
***
Проблема обработки ошибок очень важна.
Мы здорово сэкономили на установке флагов и проверке вложенности.
Очистка позволяет устранить всякие последствия ошибки.
Нам не надо заботиться об обработке ошибок в разных подпрограммах.
Это упрощает код, но зато нам пришлось изобрести абсолютный способ борьбы с ошибками.
***
The image of a person at a keyboard in invaluable for this purpose.
No matter what problem arises, we needn't worry about what to do.
Pass the buck; ask the user.
For example, he types a word not in the dictionary.
What to do?
Ask him: type the word and an error message, in this case "?".
He tries to add 2 numbers and there's only 1 on the stack: type the word and "STACK!".
He tries to access a field beyond the limit of his memory: type the word and "LIMIT!".
***
Наличие человека-оператора здесь необходимо.
Независимо от того, что за ошибка случилась, вам не надо думать.
Спросите пользователя.
Например, он напечатает слово, которого нет в словаре.
Что делать?
Спросите его: напечатайте слово и сообщение об ошибке (в этом случае "?").
Он пробует сложить два числа, а на стеке только одно: напечатайте слово и "STACK!".
Он обращается к памяти за пределами выделенной ему области: напечатайте слово и "LIMIT!".
***
Of course you want to be careful not to pose the user problems he can't solve.
Faced with a message "MEMORY PARITY" what can he do about it?
But he's certainly in a better position than your program to take corrective action to most problems.
And of course it's up to you to decide what situations are problems.
***
Конечно, вы не должны требовать от пользователя того, на что он не способен.
Что он должен делать, получив сообщение "MEMORY PARITY"?
Но он всяко лучше, чем ваша программа, знает, что делать в случае его ошибки.
И, конечно, лучше вас решит, что является проблемой, а что - нет.
***
By the way.
Since you don't check the stack until after you executed a routine, it will exceed stack limits before you know it.
Thus stack overflow and underflow should be non-fatal.
A good solution is to let the parameter stack overflow into the return stack, and underflow into the message buffer.
The return stack should never underflow.
***
Между прочим.
Т.к. вы проверяете стек только после возврата из программы, вы узнаете об его исчерпании слишком поздно.
Т.о. переполнение или исчерпание стека не должно вызывать фатальной ошибки.
Хорошее решение состоит в таком размещении областей памяти, чтобы при переполнени стека залезать в стек возвратов, а при исчерпании - в буфер сообщений.
Стек возвратов исчерпаться не может.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.3. WORD SUBROUTINE / ПОДПРОГРАММА WORD
ТЕКСТ
I've described the control loop that will run our program.
The first thing it does is to read a word; so the first thing we shall discuss is how to read a word.
What is a word?
Not a computer word, as I'm sure you realise, although we shall have to use the word "word" in that sense.
A word is a string of characters bounded by spaces.
It is extracted from a larger string of characters by the routine we are discussing.
***
Как же работает наш цикл управления?
Обсудим первую из его задач - чтение слова.
Что такое слово?
Под словом можно подразумевать много чего.
Здесь, слово - цепочка символов, ограниченная пробелом.
Она извлекается из строки специальной программой.
***
Let me contrast this definition with more conventional input routines.
FORTRAN formatted input, for example, doesn't speak of words but of fields.
The meaning of a number is determined by the field it resides in; that is, by its position on a card.
Since we are not using cards, the notion of position becomes clumsy and we replace it with order: The order of the words we read is significant, though their position is not.
We lose, however, the ability to leave a field empty, since we cannot recognise an empty word.
All our data must be explicit, which is probably a good idea but a slow one to learn.
Decide now that you will not specify input conventions that have optional parameters.
***
Рассмотрим общепринятые способы реализации чтения.
В FORTRAN, например, чтение производится не по словам, а по полям.
Считываются литеры, расположенные в определенных столбцах.
Для нас существенен порядок слов, а не их позиционирование.
Однако, кое-что мы при этом и теряем, например, возможность считать слово из одних пробелов.
Все наши данные должны быть явны, к этому надо привыкнуть.
Не используйте соглашения о вводе, которые имеют неявные параметры.
***
Very well, let's write the WORD subroutine.
It uses the input pointer to point at the current position in the source text, the output pointer to point at the current position in memory where we will move the word.
We must move it; partly to align it on a computer-word boundary and partly because we may want to modify it.
***
Давайте напишем подпрограмму WORD.
Ей нужны два указателя: текущего положения курсора чтения и места, куда будем писать прочтенное слово.
Перемещение считанного слова обязательно из соображений выравнивания и редактирования.
***
Fetch input characters and discard them so long as they're spaces.
Thereafter deposit them until you find another space.
Deposit this space and as many others as needed to fill out the last computer-word.
If you have a character-oriented machine you may be amused at my insistance on word-alignment.
Mainly I'm anticipating the search subroutine when we'll want to compare as large a piece of the word as possible.
If a word holds 6 characters (or even 2) it's much more efficient to compare them in parallel than serially, even if you have the hardware.
***
Пропускайте литеры до появления первого не-пробела.
Считывайте литеры до появления пробела.
Перенесите считанное слово в нужное место с необходимым выравниванием.
Если в вашей машине символьное выравнивание, вас может удивить мое требование выравнивания.
Я делаю это для ускорения процедуры поиска; выровненные строки можно сравнивать не по-символьно, а по-словно.
Если в компьютерное слово вмещается шесть символов (или даже два), намного эффективнее сравнивать их большими кусками.
***
You may want to set an upper limit on word length.
Such a limit should include the largest number you will be using.
Then the question arises as to what to do with a longer word.
You might simply discard the excess characters, providing you don't plan to dissect the word (Chapter 8).
Better, perhaps, that you force a space into the word at the limit.
That is, break the word into 2 words. Presumably something's wrong and you will eventually discover it in attempting to process the fragments.
However this limit should be large enough - 10 to 20 characters - so that it does not constitute a real restriction on your input.
It should also be 1 character less than a multiple of your computer-word length, so that you can always include the terminal space in the aligned word.
***
Вы можете захотеть установить максимальную длину слов.
Разумеется, равной длине самого длинного слова, которое может вам пригодиться.
А вдруг кто-то введет еще более длинное слово?
Можно просто обрезать, если не хотите делить слово на части (Глава 8).
Можно выделять место с запасом.
Можно разбивать длинные слова.
Возможно, вы захотите обрабатывать части слов.
Предельная длина должна быть достаточно большой - от 10 до 20 символов, чтобы это не сильно ограничивать ваш ввод.
Нужно предусмотреть место для завершающего пробела.
***
Words are bounded by spaces. You can probably find objections to such a simple definition.
For instance, arithmetic expressions often do not have spaces between words.
We shall discuss this in Chapter 9.
Let me just say that we need to embed periods, dashes, and other characters in words in order not to unreasonably restrict our potential vocabulary.
We'd like these to be words:
***
Слова, ограниченные пробелами...
Вам это может не понравиться.
Например, арифметические выражения часто не имеют пробелов между словами.
Мы обсудим это в Главе 9.
Позвольте мне только заметить, что мы можем использовать в словах самые замысловатые символы.
Мы хотели бы, чтобы нормальными словами считались:
***
1,000 1.E-6 I.B.M. B&O 4'3" $4.95

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.3. WORD SUBROUTINE / ПОДПРОГРАММА WORD\3.3.1. MESSAGE I/O / ВВОД-ВЫВОД СООБЩЕНИЙ
ТЕКСТ
The WORD subroutine presumably examines input characters.
Where does it get these characters?
Although it's possible to read cards, I'm going to assume that you have a keyboard to type input.
Now there are 2 kinds of keyboards, buffered and unbuffered.
A buffered keyboard stores the message until you type an end-of-message character. An unbuffered keyboard sends each character as you type it.
Your hardware, in turn, may buffer input for you or not.
***
Подпрограмма WORD читает символы.
Откуда она их берет?
Я надеюсь, что у вас есть клавиатура, а не только читалка перфокарт.
Существует два вида клавиатур - с буферизацией и без.
Клавиатура с буферизацией ничего не передаст в компьютер, пока вы не нажмете клавишу конца ввода.
Клавиатура без буферизации передает символы, как только их клавиши нажимаются.
Ваше железо может также буферизировать или нет ваш ввод.
***
In any case we may want to examine each character more than once, so we want buffered input.
Even if you can process characters as they arrive, don't. Store them into a message buffer.
***
Мы можем хотеть читать каждый символ более, чем один раз, поэтому нам нужен буферизированный ввод.
Даже если вы можете обрабатывать сиволы по мере поступления, не делайте этого.
Храните их в буфере сообщений.
***
Set aside a 1-line message buffer.
Its size is the maximum size of a message, either input or output, so if you plan to use a 132 position printer make it large enough.
***
Выделите буфер сообщений на одну строку.
Его размер - максимальная длина входного/выходного сообщения и, если вы планируете использовать принтер со строкой 132 символа, сделайте буфер не меньше.
***
If you simulate buffering, you should implement a backspace character and a cancel message character.
For you will make a lot of typing errors.
If your hardware buffers, but does not provide these capabilities, you should do so.
This probably means a prescan of the input; any other technique gets too complicated, and probably costs more in the end.
***
Если вы организуете буферизацию, сделайте обработку забоя.
Опечатки - вещь частая.
Если ваше железо это не обеспечивает, сделайте сами.
Возможно, придется добавить лишний просмотр ввода, но это меньшее зло.
***
Mark the end of an input message with an end-of-message word.
This is a word bounded by spaces like any other.
It may or may not coincide with the end-of-message character that you typed, depending on your hardware and character set as to whether the required spaces can be provided.
This word permits ready detection of the last word in a message. It will have a specific definition and perform a valuable task.
***
Рассматривайте конец сообщения как слово.
Такое же, как все слова, ограниченные пробелами.
Конкретная реализация зависит от железа.
Нужно, чтобы оно читалось и выполнялось как и обычные слова.
Оно очень нужно.
***
In addition to a keyboard, you must have some sort of output device: a printer or scope.
Again it may be buffered or unbuffered.
Unlike input, we have no reason not to use unbuffered output.
However if you have several output devices, odds are one is buffered.
If so, treat them all as buffered, simulating the buffering where needed.
***
Кроме клавиатуры, вам нужно иметь устройство вывода: принтер или дисплей.
Оно тоже может быть буферизованным или нет.
В отличие от ввода, здесь буферизация нам не нужна.
Однако, если в наличии несколько конфликтующих устройств, она понадобится.
В этом случае, для единообразия, моделируйте буферизацию там, где ее нет.
***
We will use the same message buffer for both input and output.
My motivation is to save space, or rather to increase the utilization of space.
My reasoning is that input and output are mutually exclusive.
There are exceptions, but we don't usually read input and prepare output simultaneously.
At least we never have to.
***
Одного буфера достаточно и для ввода, и для вывода.
Значит, выделять второй не следует.
Одновременно ввод и вывод не происходят.
Имеются исключения, но редко.
По крайней мере, они нежелательны.
***
However, we do need a switch (1 bit) that states whether the message buffer still contains input.
The first time (or perhaps everytime) we type output, we must reset this switch.
We'll use it later.
***
Нам, однако, нужна логическая переменная (1 бит), показывающая остался ли еще в буфере необработанный ввод.
Его полезно переустанавливать как можно чаще.
Позже мы к этому вернемся.
***
We need a receive subroutine that will exit when we have a complete input message.
Likewise a transmit subroutine that will exit after sending an output message.
It should await an acknowledgement if the hardware provides one.
Don't try to overlap transmission of one message with preparation of the next.
Transmission is so slow and preparation so fast that no noticable increase in speed is available.
And it complicates the program considerably.
***
Нам нужна подпрограмма, вызываемая достижением конца ввода.
И подпрограмма вывода готового выходного сообщения.
Если возможно, они должны опираться на возможности вашего железа.
Совмещать вывод одного сообщения с подготовкой следующих?
Выигрыш в скорости минимален, а проблем будет много.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.3. WORD SUBROUTINE / ПОДПРОГРАММА WORD\3.3.2. MOVING CHARACTERS / ПЕРЕМЕЩЕНИЕ СИМВОЛОВ
ТЕКСТ
I will speak of fetching and depositing characters several times, mostly concerned with input and output.
For example, the WORD subroutine moves characters from the message buffer to a word buffer.
A simple task conceptually, but a difficult one to implement.
We would have exactly the same problem moving arrays from place to place.
But in fact we needn't move arrays and we must move characters.
***
Перемещение символов необходимая вещь, особенно при вводе и выводе.
Например, WORD переносит символы из буфера сообщений в буфер слов.
Проще сказать, чем сделать.
Такая же проблема существует при переносе массивов.
Но даже перенос массивов имеет смысл обсуждать только как перенос символов.
***
Let us define 2 entities: an input pointer and an output pointer.
For the moment you can think of them as index registers, although we will have to generalize later.
Let's also write 2 subroutines, although your hardware may permit them to be instructions: FETCH will load the character identified by the input pointer into a register, and advance the input pointer; DEPOSIT will store that register at the position identified by the output pointer, and advance the output pointer.
***
Определим два указателя: источника и приемника.
О них нужно думать как об индексных регистрах, позже уточним.
Определим две нужные подпрограммы (возможно, просто инструкции): FETCH загружает символ источника в регистр и продвигает указатель источника, DEPOSIT сохраняет символ из регистра в приемник и продвигает указатель приемника.
***
Depending on your computer, FETCH and DEPOSIT can be veery simple, or extremely complex.
If they require more than 1 instruction, they should be subroutines, for we'll use them often.
By combining them, we can perform a move.
However, it's important to be able to examine the character before depositing it.
A hardware move instruction is of little value.
***
В зависимости от вашего компьютера, реализовать FETCH и DEPOSIT может быть очень просто или очень сложно.
Если они весят больше, чем одну инструкцию, они должны быть оформлены в подпрограмму, поскольку используются часто.
Комбинируя их, мы можем организовать перемещение.
Однако, где-то между ними надо вставить анализ символа.
Стандартная инструкция переноса, реализованная в железе, очень неудобна.
***
The input and output pointers use index registers.
However, those registers should only be used during a move.
They should be loaded prior to a move and saved after it, for they will be used for a number of purposes, and it becomes impractical to store anything there permanently.
***
Указатели удобно хранить в индексных регистрах.
Однако, надо обеспечить их неприкосновенность на время всего перемещения.
Их нужно сохранять и восстанавливать, т.к. все время занимать регистры под указатели жалко.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.4. DECIMAL CONVERSION / ДЕСЯТИЧНОЕ ПРЕОБРАЗОВАНИЕ
ТЕКСТ
After isolating and aligning a word from the input string, your control loop searches the dictionary for it.
If it isn't in the dictionary, it might be a number.
A number is a special kind of word that doesn't need a dictionary entry; by examining the word itself we can decide what to do with it.
The code executed for a number will place the binary representation of the number onto the stack.
We will discuss the stack in the next section. First let's define a number more precisely.
***
Прочтя слово, мы ищем его в словаре.
Если его там нет, значит это число.
Число - слово специального вида, не нуждающееся в словаре, что с ним делать - очевидно.
Код для числа просто размещает его значение на стеке.
Стек обсудим дальше.
Сначала определим, что такое число.

\7.НОВОСТИ\СТАРЫЕ НОВОСТИ\ОПЕРАЦИИ НАД ЦЕЛЫМИ ЧИСЛАМИ ПО БРОУДИ\ОТКУДА НОГИ РАСТУТ
\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.4. DECIMAL CONVERSION / ДЕСЯТИЧНОЕ ПРЕОБРАЗОВАНИЕ\3.4.1 NUMBERS / ЧИСЛА
ТЕКСТ
It is very hard to state exactly what is a number and what is not.
You will have to write a NUMBER subroutine to convert numbers to binary, and this subroutine is the definition of a number.
If it can convert a word to binary, that word is a number; otherwise not.
It is foolish to examine a word to see if it is a number, and then to convert the number to binary.
Examination and conversion can be combined into one process very easily.
***
Очень трудно точно сказать, что является числом, а что - нет.
Вы напишете подпрограмму NUMBER для перевода чисел в двоичный вид, и эта подпрограмма и будет овеществленным определением числа.
Если ей не удастся преобразовать слово в число, значит оно не является числом.
Было бы глупостью сначала выяснять, число ли это, и только потом его преобразовывать.
Эти два вопроса решаются в одном процессе.
***
There is one kind of word that invariably is a number: a string of digits possible prefixed with a minus.
Such numbers are usually converted to binary integers. For example:
***
Безусловно, являются числами цепочки из цифровых символов, возможно, с предшествующим минусом.
Их обычно нужно преобразовать в двоичное значение.
Например:
***
1 4096 -3 7777 0 00100 10000000 6AF2 -B
***
are some decimal, octal and hex numbers.
The number does not specify its base, and a word that may be a hexadecimal number, may not be a decimal number.
So already base has complicated numbers.
***
- десятичные, восьмеричные и шестнадцатеричные числа.
Число не содержит в себе указания на основу счисления, но явно, что она должна быть больше, чем самая большая цифра числа.
Т.е. основание счисления - первая трудность.
***
And beyond simple integers are endless other kinds of numbers: fixed-point fractions, floating-point fractions double-precision integers, complex fractions, etc.
And such numbers can have many different formats as words: decimal point, implied decimal point, exponents, suffixes.
Indeed, the same word may represent different numbers depending on its context.
***
Есть числа и не такие простые: с фиксированной точкой, с плавающей точкой, целые двойной точности, сложные дроби и т.д.
И такие числа могут иметь много различных форматов слова: с десятичной точкой, с подразумеваемый десятичной точкой, экспоненциальный, с суффиксами.
Одно и то же слово может представлять различные числа в зависимости от контекста.
***
One of your major tasks will be to decide what kinds of numbers you need for your application, how you will format them, and how you will convert them.
Each kind of number must be uniquely identifiable by the NUMBER subroutine, and for each you must provide an output conversion routine.
***
Одна из ваших главных задач - решить, какие числа вы будете использовать, как будете их форматировать, и как преобразовывать.
Каждый вид должен однозначно распознаваться подпрограммой NUMBER, и для каждого вы должны обеспечить подпрограмму преобразования.
***
I suggest the following guidelines: always define integers and negative integers; do not permit a prefixed plus sign, it is useless on a number and useful as a word; if you have floating-point hardware, distinguish floating-point fractions by a decimal point; if you lack floating-point hardware, use the decimal point to identify fixed-point fractions; don't simulate floating-point; don't permit exponents on fractions.
These rules permit a simple NUMBER subroutine which I will outline.
***
Я предлагаю руководствоваться следующими принципами: всегда нужны целые числа и отрицательные целые числа; запретите предшествующий плюс, он бесполезен в числе и полезен как слово; если вы имеете аппаратные средства для вычислений с плавающей точкой, разрешите и их; если такого железа нет, ограничьтесь числами с фиксированной точкой.
Эти правила удобны для пользования и реализации.
***
Your application may need special number formats:
 45'6 for 45ft.6in., an integer
 1,000,000 an integer
 $45.69 an integer
***
Вам могут понадобиться и другие виды чисел:
 45'6 = 45 футов 6 дюймов, целое число
 1,000,000 - целое число
 $45.69 - целое число.
***
It is not hard to include such numbers in NUMBER, but you cannot include all possible formats.
Some are incompatible:
 3'9 for 3ft.9in.
 12'30 for 12min.30sec. of arc
 12'30 for 12min.30sec. of time
 4'6 for 4 shillings 6 pence
***
Нельзя иметь форматы на все случаи жизни.
Некоторые из них просто несовместимы:
 3'9 = 3 фута 9 дюймов
 12'30 = 12 минут 30 секунд угловой меры
 12'30 = 12 минут 30 секунды, время
 4'6 = 4 шиллинга 6 пенсов.
***
Basic Principle!
Fixed-point numbers are rarely used.
I am convinced of their value and would like to show you.
With floating-point hardware, they offer only the advantage of greater significance, which is probably not worth much.
However, without floating-point hardware they offer most of the capabilities of floating-point numbers, without the very great cost of floating-point software.
The exception is a wide range of exponents.
***
Основной Принцип!
Числа с фиксированной точкой используются редко.
Но они могут быть полезны.
Но, если железо поддерживает вычисления с плавающей точкой, они избыточны.
Однако, в противном случае, они позволяют минимальными средствами сделать очень много.
Исключение - работа с числами в очень широком диапазоне.
***
I am convinced that exponents are badly misused on computers.
Most applications use real numbers that can be used on a desk-calculator - say between 1e6 and 1e-6.
Such numbers can be equally well represented in fixed-point format.
Floating-point is not needed, although if hardware is available it might as well be used.
There are cases, especially in physics, when large exponents occur - 1e43 or 1e-13.
But this usually indicates that the proper units have not been chosen, or maybe even that logarithms should be used.
***
Я убежден, экспоненты используются в компьютерах неправильно.
Большинство обычно используемых чисел лежат в диапазоне от 1e-6 до 1e6.
Такие числа могут быть представлены и в формате с фиксированной точкой.
Т.о. плавающая точка здесь не необходима.
Правда в физике бывают числа и 1e43, и 1e-13.
Но это обычно бывает, когда выбраны неудобные единицы измерения или когда удобнее применять логарифмы.
***
Of course compilers do not implement fixed-point, so people don't use it.
We are in a position to implement it, and to take advantage of the speed possible with fixed-point (integer) instructions.
What does a fixed-point number look like?
Choose the number of decimal places you want to use. You may change this from time-to-time, but shouldn't mix numbers with different precision.
Have your NUMBER subroutine align all numbers (with decimal points) as if you had typed exactly that number of decimal places.
Thereafter treat that number like an integer.
That is, if you choose 3 decimal places:
 1. is considered 1.000 and treated as 1000
 3.14 is 3.140 and 3140
 2.71828 is 2.718 and 2718
 -.5 is -.500 and -500
***
Люди не используют вычисления с фиксированной точкой, потому что компиляторы им этого не разрешают.
Мы пишем свой язык сами и можем себе позволить воспользоваться преимуществами этого подхода.
Как это организовать?
Выберите потребное число знаков после запятой.
Вы сможете его, если надо, поменять, но не смешивайте числа с разными его значениями.
Научите вашу подпрограмму NUMBER выравнивать числа по положению точки, дополняя с нужной стороны нулями.
После того смело обращайтесь с ним, как с целым.
Например (подразумевая три цифры после запятой):
 1. = 1.000 = 1000
 3.14 = 3.140 = 3140
 2.71828 = 2.718 = 2718
 -.5 = -.500 = -500
***
I wouldn't bother rounding unless your application demanded it, or your hardware made it easy.
You can add and subtract such numbers without concern; their decimal points are aligned.
After multiplying 2 numbers, you must divide by 1000 to re-align the decimal points.
Hardware usually facilitates this; the result of a multiply is a double-precision product in the proper position for a dividend.
Before dividing 2 numbers, you must multiply the dividend by 1000 to maintain precision and align the decimal points.
Again this is easy.
***
Я бы не беспокоился насчет округления, ну, если только вам оно сильно надо или ваше железо его легко делает.
Складывать и вычитать такие выровненные числа можно без ограничений.
А вот, после перемножения придется делить результат на степень десятки (в нашем случае - на 1000).
Аппаратные средства обычно облегчают процесс; результат умножения - число двойной точности - уже в надлежащем положении для деления.
Перед делением двух чисел, вы должны умножить делимое на степень десятки (у нас - на 1000).
Это тоже легко.
***
So providing your words are large enough to store the number of decimal places you need, fixed-point arithmetic is easy.
If you have the hardware, double-precision numbers and operations let you deal with larger numbers.
Just as easily. And much easier than simulating floating-point operations.
You may have to write your own square-root and trig-function subroutines, but there are approximations available that make this not-difficult.
And they'll be much faster than the equivalent simulated floating-point subroutines.
***
Для хранения подобных чисел ячейка памяти лучше была бы побольше.
Если ваше железо позволяет, можно использовать арифметику двойной точности.
Легко.
И намного легче реализации чисел с плавающей точкой.
Вам, вероятно, придется писать собственные математические подпрограммы, но сейчас эти алгоритмы общедоступны.
И они будут намного быстрее, чем их аналог с плавающей точкой.
***
Aligning decimal points is easy to visualize, and avoids truncation problems.
However you may prefer to align binary points. That is, instead of 3 decimal places, keep 10 binary places to the right of the point.
The multiplication and division by 1000 can then be replaced by binary shifts - the equivalent for binary - which are much faster.
You must balance the gain in speed against the problem of alignment during conversion (input and output) and truncation during multiplication and division being more subtle.
And possibly the difficulty of explaining your arithmetic.
***
Выравнивание десятичных знаков легко осуществить при вводе и выводе.
Однако, вы можете предпочесть выравнивать двоичные разряды.
Из расчета три десятичных позиции на десять двоичных.
Выравнивающие деления и умножения тогда могут быть заменены гораздо более быстрыми сдвигами.
Вы должны выбирать, что нужнее - скорость вычисления или простота преобразований.
Или что труднее объяснить пользователю.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.4. DECIMAL CONVERSION / ДЕСЯТИЧНОЕ ПРЕОБРАЗОВАНИЕ\3.4.2. INPUT CONVERSION / ПРЕОБРАЗОВАНИЕ ПРИ ВВОДЕ
ТЕКСТ
Now let's discuss the NUMBER subroutine in detail.
First, why is it a subroutine?
If you examine the program I've outlined so far, and even the program as augmented by the end of the book, you'll fiind NUMBER is called only once - in the control loop.
By my own rules NUMBER should thus be in-line code.
However, I can't bring myself to put it in line; the logic in NuMBER is so complex that I want to isolate it away from the control loop, to emphasize its logical function - one purpose of a subroutine - and to reduce confusion in the control loop itself; also I'm never confident that I won't want to call NUMBER from some other routine, in fact I have.
But I think that such violations of programming standards should be explicitly recognised.
The key to a good NUMBER subroutine is another subroutine that it calls.
***
Рассмотрим подпрограмму NUMBER подробно.
Подпрограмму?
Она вызывается всего один раз - в цикле управления.
Т.о. это может быть просто фрагмент кода.
Однако, она настолько сложна, что ее потребовалось логически обособить; нельзя также исключить возможность, что мне захочется ее вызвать и в другом месте.
Подобные отклонения от канонов нужно описывать явно.
Нормой для подпрограмм является большое число их вызовов.
***
This subroutine has 2 entry points: SIGNED tests the next character for minus, sets a switch, zeros number-so-far and falls into NATURAL.
NATURAL fetches characters, tests that they're digits, multiplies the number-so-far by 10 and adds the digit.
It repeats until it finds a non-digit.
***
Подпрограмма NUMBER имеет две входные точки: SIGNED - анализ первого символа на "минус" и обнуление накопителя, затем переход к NATURAL.
NATURAL - цикл: проверить следующий символ на цифру, умножить накопитель на десять, добавить цифру.
Повторять, пока не найдется не-цифра.
***
With this routine, NUMBER can work as follows: set the input pointer to the start of the aligned word, call SIGNED.
If the stopping character is a decimal point, clear counter, call NATURAL to get the fraction, and use counter to choose a power-of-ten to convert to a floating or fixed-point fraction.
In any case, apply SIGNED's switch to make number-so-far negative.
Exit.
***
Итак NUMBER: установить указатель ввода на начало выровненного слова, вызвать SIGNED.
Если символ - точка, сбросить счетчик и вызвать NATURAL для считывания дробной части, счетчик покажет, сколько цифр введено и как надо преобразовать число в форму с фиксированной или плавающей точкой.
В любом случае применить результат, полученный в SIGNED, чтобы приписать числу правильный знак.
EXIT.
***
The routine that calls NUMBER can test the stopping character:
 * If it is a space, the conversion was successful.
 * Otherwise, the word was not a number.
***
Подпрограмма NUMBER должна останавливаться найдя:
 * пробел - тогда, это число;
 * что-то другое - это не число.
***
For example, the following are numbers:
***
Числа:
***
0 3.14 -17 -.5
***
The following are not:
***
Не числа:
***
0- 3.14. +17 -.5Z X 6.-3 1.E3
***
In each case NUMBER will stop on a non-space.
The number-so-far will be correctly converted up to that point (possibly 0) but it is of no value.
***
В этих случаях NUMBER остановится не на пробеле.
Накопитель будет правильно показывать распознанное на этот момент значение, но оно уже никому не нужно.
***
SIGNED/NATURAL is a valid subroutine since it is called twice.
Moreover, if you define other number formats, you'll find it useful.
For example, the format ft'in
 * After calling SIGNED, if the stopping character is a ' multiply number-so-far by 12 and call NATURAL. Then proceed as usual, testing for decimal point.
 If you want to verify that "in" are less than 12, you'll want to modify this slightly.
***
SIGNED/NATURAL здесь имеет право на звание подпрограммы, т.к. вызывается дважды.
Кроме того, она может быть полезна и для других форматов чисел.
Например (дюймы):
 * После запроса SIGNED, если найден апостроф, умножить накопитель на 12, вызывает NATURAL.
Если будет найдена точка - см. выше.
 Если Вы хотите удостовериться, что число дюймов меньше 12, надо будет внести изменения.
***
In NATURAL the number-so-far is multipled by 10.
Don't use a litereal 10, but rathere define a field (BASE) and store a 10 there as multiplier.
Then you can change BASE to 8 (or 16) and handle octal numbers.
You can even change it to 2 to use binary numberes.
NATURAL should test for digits by comparing them with BASE, thus prohibiting 9 in an octal number.
Hexadecimal input numbers cause an additional problem because the digits A-Z do not follow 9 in standard character sets.
It is thus harder to recognise digits; but this problem is isolated in a single place (NATURAL) and is easy to code:
 * An origin must usually be subtracted from a digit to get its binary value. If BASE is 16, a different origin is subtracted from A-F.
***
В NATURAL накопитель умножается на 10.
Используйте не константу 10, а значение переменной BASE.
Тогда Вы сможете поменять BASE на 8 (или 16) и вводить восьмеричные (шестнадцатеричные) числа.
Вы сможете даже записать там 2, чтобы работать с двоичными числами.
NATURAL, проверяя на цифры, должен их сравнивать со значением BASE.
Если BASE будет больше 10, то будет дополнительной проблемой распознать как цифры буквы A-Z.
Но эта проблема местная и легко решаемая:
 * Из номера символа вычитается номер символа 0.
Если BASE - 16, символ-буква ищется в A-F.
***
NUMBER should be efficient, at least in recognising words that are not numbers.
Not so much because you will use so many numbers, but because you will examine many words that aren't numbers.
We will discuss this further in Chapter 8.
It is also important that you examine the aligned copy of a word.
There are several reasons: to avoid trouble with the input pointer, to guarantee a terminal space.
However this creates a problem: the largest number you will use must fit in the aligned word; this may require a longer word than you would otherwise use.
A number longer than word-size will have its right-most digits discarded.
This will probably not destroy its numeric appearance so that no error will be detected; but the conversion will be incorrect.
This problem is not serious, just be aware of it.
***
NUMBER должна быть эффективной, по крайней мере, в распознании не-чисел.
Уж очень много слов-не-чисел.
Мы обсудим это в Главе 8.
Также важно то, что вы исследуете выровненную копию слова.
Имеются несколько причин для выравнивания: избегнуть неприятностей с указателем ввода, гарантировать место для завершающего пробела.
Однако, тут тоже проблема: слишком длинное число может не поместиться.
Потеряет свои правые цифры.
Ошибка не будет выдана, но число распознается неверно.
Впрочем, если об этом помнить, не такая это уж и проблема.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.4. DECIMAL CONVERSION / ДЕСЯТИЧНОЕ ПРЕОБРАЗОВАНИЕ\3.4.3. OUTPUT CONVERSION / ПРЕОБРАЗОВАНИЕ ПРИ ВЫВОДЕ
ТЕКСТ
Numeric output is harder than numeric input because there is an extra step involved.
During input, you multiply the number by 10 and add each digit.
You can work from left to right.
During output, you divide by 10, save the remainder for the digit, and repeat with the quotient until it becomes 0.
You get the digits from right to left, but you want to type them from left to right.
Thus you need somewhere to store the digits temporarily.
A good place is the far end of the message buffer.
The space is unused since you presumably have enough space for the number.
Of course, you can use the stack.
If you place a space at the right end of your temporary storage, and then deposit the digits from right to left, you can use the TYPEB subroutine to finally type the number.
***
Вывод чисел сложнее ввода на одну операцию.
При вводе вы умножаете накопитель на 10 и добавляете цифру.
Вы идете слева направо.
При выводе вы делите на 10, выводите остаток и снова делите, пока число не уменьшится до нуля.
Но вы получаете цифры справа налево, а печатать-то надо слева направо.
Т.о. цифры надо где-то временно накапливать.
Хорошее место - дальний конец буфера сообщений.
Свободного места там хватит.
Конечно, вы можете использовать стек.
Заполнив свой временный буфер цифрами, вы сможете распечатать их подпрограммой TYPEB.
***
You'll probably want to handle both negative numbers and fractions.
Remember the number is negative and work with its absolute value.
After you're finished, prefix a minus.
Fractions require 2 conversion loops: one to convert the fraction, counting the number of digits and depositing a decimal point; another to convert the integer, stopping when the quotient becomes 0.
You don't want to test the quotient in the fraction.
***
Вы захотите печатать отрицательные числа и дробные части.
Запомните, что число отрицательное и работайте с его абсолютным значением.
После того, как закончите, добавьте впереди минус.
Для чисел с фиксированной точкой надо два цикла: сначала накопите столько цифр, сколько надо для дробной части, и добавьте десятичную точку; затем - цикл, описанный выше.
Проверять исчерпание числа во время накопления дробной части не надо.
***
If you take the care, and spend a couple of instructions, you can improve the appearance of your numbers by:
 * Not typing a decimal point if the number has no decimal places.
 * Not typing a leading zero to the left of the decimal point.
***
Имеет смысл, для красоты, проверить еще пару вещей:
 * не печатать точку, если нет дробной части;
 * не печатать нулевую целую часть.
***
You will probably have several dictionary entries specifying different output formats.
For example, each kind of number: integer, float, complex will need its own output routine.
However the actual conversion should be done by a single subroutine with parameters to distinguish special cases.
That is, a single subroutine inverse to the NUMBER subroutine.
The similarities among different numbers are much greater than their differences.
***
Вы, наверное, создадите несколько словарных статей для вывода чисел в различных форматах.
Например, для целых чисел, с плавающей точкой, комплексных.
Однако, все фактическое преобразование должно быть сделано единственной процедурой, с параметрами для специальных случаев.
Процедура, обратная NUMBER.
Это возможно, т.к. у чисел гораздо больше общего, чем различий.
***
If you use decimal fixed-point fractions, you already have a field D that specifies the number of decimal places.
The same field is used to control decimal placement on output.
Ordinarily decimal places on input and output will be the same.
Even with floating-point numbers you need that field, since you're rarely interested in full precision output.
***
Если вы работаете с числами с фиксированной точкой, у вас уже есть переменная D для хранения размеров дробной части.
Ее же можно использовать и при выводе дробной части.
Дробная часть обрабатывается одинаково в обоих случаях.
Даже для чисел с плавающей точкой хватит этого же буфера (если не предъявлять чрезмерных требований к точности).
***
If you want to produce reports - carefully formatted columns of numbers - you will need to right-justify numbers.
That is, to line up decimal points.
For this you need another parameter F, the width of the field in which the number is to be right-justified.
It's easy to use: after converting the number right-left, compute the number of spaces you need and call SPACE.
Then call TYPEB.
In determining spaces, remember that TYPEB always types a space after the number.
Thus you will always have at least a single space between numbers.
If the number won't fit in the field you specify, you'll still have that one space, and the full number will be typed - fouling up the report format - but showing you the bad number.
***
Если вы хотите печатать отчеты - ровные колонки чисел - вы должны научиться выравнивать числа по правому краю.
Что в нашем случае равносильно выравниванию по десятичной точке.
Для этого нужна другая переменная - F, ширина поля.
Это просто: после преобразования числа нужно посчитать нужное число пробелов и вызвать SPACE.
Затем - TYPEB.
При подсчете помните, что TYPEB всегда печатает после числа пробел.
Т.о. между числами всегда будет минимум один пробел.
Если одно из чисел не влезет в поле, оно все же напечатается целиком, отделенное пробелами - число важнее красоты отчета.
***
Let me acknowledge that if you are going to right-justify numbers you can place the digits directly into position from right to left, for you know where the rightmost digit must go.
But then you must space-fill the message buffeer before starting output, and you can't type unbuffered output immediately.
However, my main objection is that you can't compose free-format output.
For example, place a number in a sentence without extra leading spaces.
And very often unformatted output is adequate, saving you having to specify field sizes you don't care about.
***
Конечно, можно было бы печатать все числа с выравниванием вправо, начиная с самой правой цифры.
Но тогда вы будете нуждаться в буферизации вывода.
Главное же возражение состоит в том, что вы не сможете печатать в свободном формате.
Например, вставить число в текстовую строку.
Свободный вывод без выравнивания - это то, что вам и надо.
***
Depending on your formatting requirements, there are other dictionary entries you might want: A SPACE entry, to space the number of positions on the stack.
It can even space backwards - by changing the output pointer - if the stack is negative.
This is useful if you want to suppress that space provided by TYPEB. A tab entry might calculate the amount to space in order to reach a specific position on the stack.
***
Среди других словарных статей для печати:
SPACE - снять со стека число и напечатать столько пробелов.
Возможно даже отрицательное число - обратный сдвиг указателя вывода.
Это полезно, если вы хотите забить выведенное TYPEB.
Слово TAB - расчет количества пробелов, необходимых для достижения позиции указанной числом на стеке.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.5. STACKS / СТЕКИ
ТЕКСТ
We will be using several push-down stacks and I want to make sure you can implement them.
A push-down stack operates in a last-in first-out fashion.
It is composed of an array and a pointer.
The pointer identifies the last word placed in the array.
To place a word onto the stack you must advance the pointer, and store the word (in that order).
To take a word off the stack you must fetch the word and drop the pointer (in that order).
There is no actual pushing-down involved, though the effect is the same.
A stack pointer is an excellent use for an index register, if you have enough.
Indirect addressing is also a possibility, especially if you have an add-to-memory instruction.
***
Вы должны будете организовать несколько стеков.
Стеки работают по принципу "последним пришел - первым ушел".
Он состоит из массива и указателя.
Указатель указывает на последнее помещенное слово.
Для размещения слова вы должны сначала увеличить указатель, а затем записать слово туда, куда он показывает.
Чтобы взять слово из стека, вы должны, наоборот, сначала прочесть слово, а потом уменьшить указатель.
Понятно, сам стек не сдвигается.
Очевидно, указатель стека - индексный регистр, конечно, если вы сможете его на это выделить.
Другое решение - использование косвенной адресации с автинкрементом/декрементом.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.5. STACKS / СТЕКИ\3.5.1. RETURN STACK / СТЕК ВОЗВРАТОВ
ТЕКСТ
This stack stores return information.
One use is to store the return address for subroutines, when subroutine calls use an index register.
The last-in first-out nature of a stack is exactly the behavior required for nested subroutine calls.
We will later encounter several other kinds of return inforrmation that can be stored in the same stack.
It is important not to attempt to combine the return stack and the parameter stack.
They are not synchronized.
8 words is probably enough space for the return stack.
***
Здесь хранится информация для обеспечения возвратов.
Например, адреса возврата для подпрограмм, если вызовы использовали индексный регистр.
Стек идеально подходит для хранения адресов возвратов вложенных процедур.
Позже мы приведем еще примеры информации для возврата.
Объединить стек возвратов со стеком параметров нельзя.
Они не синхронизированы.
8 слов, вероятно, для стека возвратов хватит.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.5. STACKS / СТЕКИ\3.5.2. PARAMETER STACK / СТЕК ПАРАМЕТРОВ
ТЕКСТ
This stack is the one I intend when I say simply stack.
Numbers, constants, variables are all placed on this stack, as will be discussed later.
This stack is used to pass parameters among routines.
Each routine can find its arguments there, regardless of how many other parameters are present, or how long ago they were placed there.
You should not implement a parameter stack less than 16 words long.
***
Или просто стек.
Все числа, константы и переменные складывают сюда свои значения.
Он для того и нужен - для обмена данными между программами.
Каждая программа ожидает найти на стеке свои параметры, независимо от того, сколько их там всего и кто, и когда их туда положил.
Стек явно должен быть не менее 16 слов.
***
A valuable refinement to the parameter stack is to set aside a register to hold the word on top of the stack.
Several rules must be religously observed if this is not to cause trouble:
 * You must never use this register for any other purpose.
 * You must keep this register full; no flag to indicate that it's empty.
 If you cannot fulfill these conditions, you're better off with the stack entirely in core.
***
Для указания на вершину стека нужен регистр.
Обязательно:
 * вы никогда не должны использовать этот регистр для других целей;
 * этот регистр должен всегда содержать актуальное значение; никаких проверок и флагов его пустоты нет.
 Это будет самая выгодная реализация стека.
***
We need some terminology:
 * You place a word onto then stack, thereby increasing its size.
 * You drop a word from the stack, thereby decreasing its size.
 * The word on top of the stack is called the top word.
 * The word immediately below the top of the stack is called the lower word.
***
Терминология:
 * кладете слово на стек - стек растет;
 * снимаете слово со стека - стек уменьшается;
 * слово на вершине стека - верхнее слово.
 * слово под вершиной стека - нижнее слово.
***
You may need to control the parameter stack from the input.
These words (dictionary entries) are extremely useful, and illustrate the terminology above:
 DROP drop the top word from the stack.
 DUP place the top word onto the stack, thereby duplicating it.
 SWAP exchange the top and lower words.
 OVER place the lower word onto the stack; move it over the top word.
***
Слова, управляющие стеком.
Очень полезные:
 DROP - удаляет верхнее слово.
 DUP - кладет копию верхнего слова на стек, т.е. дублирует верхнее слово.
 SWAP - меняет местами верхнее и нижнее слово.
 OVER - кладет копию нижнего слова на стек, т.е. поверх верхнего.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.6. DICTIONARY / СЛОВАРЬ
ТЕКСТ
Every program with input must have a dictionary.
Many programs without input have dictionaries.
However these are often not recognised as such.
A common 'casual' dictionary is a sereies of IF ... ELSE IF ... ELSE IF ... statements, or their equivalent.
Indeed this is a reasonable implementation if the dictionary is small (8 entries) and non-expandable.
It is important to acknowledge the function and existence of a dictionary, to concentrate it in a single place and to standardize the format of entries.
A common characteristic of bad programs is that the equivalent of a dictionary is scattered all over the program at great cost in space, time and apparant complexity.
***
Каждая программа с вводом должна иметь словарь.
Даже программы без ввода часто имеют словари.
Ведь последовательность операторов IF ... ELSE IF ... ELSE IF ... и есть такой псевдо-словарь.
Если словарь маленький (статей на 8) и не растет, такая реализация выглядит даже разумной.
Здесь важно утвердить понятие словаря, сосредоточить его код в одном месте и оговорить формат статей.
Общее место плохих программ - их эквивалент словаря разбросан по всему коду, что увеличивает затраты времени, места и сложности.
***
The most important property of an entry is one that is usually overlooked.
Each entry should identify a routine that is to be executed.
Very often many entries execute the same routine.
Perhaps there are few routines to choose among.
This tends to conceal the importance of specifying what is to be done for each entry.
By placing the address of a routine in each entry, an optimal and standard procedure for getting to that code can be designed.
***
Главное свойство словарных статей то, о котором вечно забывают.
Каждая статья должна содержать программу для исполнения.
Но, обычно, много статей делают одно и то же.
Их число можно сильно сократить.
Сделать каждую программу необходимой.
А заодно, написать для каждой оптимальный код.
***
Significantly, the IF ... ELSE IF construction has the characteristic of associating a routine with each entry.
***
Конструкция IF ... ELSE IF - пример связи статей с программами.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.6. DICTIONARY / СЛОВАРЬ\3.6.1. ENTRY FORMAT / ФОРМАТ СТАТЬИ
ТЕКСТ
There are 2 distinct ways to organize dictionary entries.
The choice may depend upon hardware characteristics, but I recommend the second.
A dominant feature of entries is that they have variable length.
A part of the entry may be the code to be executed, or parameters or an area of storage, all of which may have arbitrary length.
***
Имеются два различных способа организовать словарные статьи.
Выбор между ними может зависеть от характеристики аппаратных средств, но я рекомендую второй.
Главная особенность статей - то, что они бывают разной длины.
Причем, различную длину имеют не только они, но и их отдельные поля.
***
One possibility is to split an entry into two portions, one of fixed size, one of variable size.
This permits scanning fixed size entries to identify a word and often there are hardware instructions to speed this search.
A part of the fixed entry can be a link to a variable area; of course you choose the fixed size so as to make the link in the nature of an overflow - an exception.
***
Первая возможность: разбить статью на две части: одна фиксированного, вторая - произвольного размера.
Фиксированные заголовки позволят ускорить поиск слов.
Фиксированная часть должна содержать ссылку  на произвольную; конечно, вы так выбираете размер фикисованной части, чтобы сократить потребность в произвольной.
***
However, since input is relatively small volume (even as augmented in definitions), to minimize the time required to search the dictionary does not lead to a global optimum.
You can gain greater flexibility, a simpler allocation of core, and ultimately greater speed by chaining the variable-sized entries together directly.
This is the organization I shall discuss.
***
Однако, так как ввод имеет достаточно небольшой объем (даже с учетом определений), минимизировать время поиска введенных слов бесполезно.
Вы можете получать большую гибкость, более простое распределение ОЗУ, и, в конечном счете, большуя скорость, храня статью как одно целое.
Такой случай я и буду рассматривать.
***
An entry has 4 fields: the word being defined, the code to be executed, a link to the next entry and parameters.
Each of these warrants discussion.
***
В статье четыре поля: слово, исполняемый код, связь со следующей статьей и параметры.
Обсудим.
***
The format of a word must be decided in conjunction with the word input routine.
It should have a fixed size which may be smaller than that defined by NEXT, but must be a multiple of hardware word size.
However, more sophisticated applications use the dictionary words to construct output messages.
Then it is important not to truncate words, in which case the word field must have variable length.
To mark the size of this field the terminal space should be used rather than a character count.
To handle a variable word field within a variable entry, the word should extend in one direction (backwards) and the parameter in the other (forwards).
Fixed or variable word size requires application of the Basic Principle.
***
Формат слова связан с процедурой его чтения.
Поле для его размещения должно быть фиксированным, не больше, чем нужно NEXT (см. дальше), несколько машинных слов.
Однако, некоторые приложения могут хотеть распечатывать слова из словаря.
Тогда придется отказаться от усечения имен и хранить их в поле переменного размера.
Лучше использовать строку с ограничивающим пробелом, чем строку со счетчиком.
В статье слово должно расти назад, а поле параметров - вперед.
Применять статьи фиксированной или произвольной длины - вопрос вашего понимания Основного Принципа.
***
The code field should contain the address of a routine rather than an index to a table or other abbreviation.
Program efficiency depends strongly on how long it takes to get to the code once a entry is identified, as discussed in 3.9.
However, the small size of your program may permit this address to fit in less space than the hardware address field.
***
Поле кода должно содержать, скорее, адрес программы, чем ссылку на таблицу или какой-либо идентификатор.
Эффективность программы очень сильно зависит от того, как долго мы будем добираться до кода.
Однако, небольшой размер вашей программы может позволить использовать не абсолютные, а более короткие - относительные - адреса.
***
The link field may likewise be smaller than hardware-specified.
It should contain the absolute location of the next entry rather than its distance from the current entry.
***
Аналогично поле связи может быть короче, чем обычный для компьютера адрес.
Но, все равно, лучше запоминать в нем абсолютный адрес следующей статьи, чем смещение до него.
***
The parameter field will typically contain 4 kinds of information:
 * A number, constant or variable, of variable size. The nature of the number is determined by the code it executes.
 * Space in which numbers will be stored - an array. The size of the array may be a parameter, or may be implicit in the code executed.
 * A definition: an array of dictionary entries representing virtual-computer instructions; see 3.9.
 * Machine instructions: code compiled by your program which is itself executed for this entry. Such data must probably be aligned on word boundary, the other need not.
***
Поле параметров обычно может содержать четыре вида информации:
 * Число, постоянное или переменное, переменного размера. Природа этого числа определяется кодом слова.
 * Массив. Размер массива может быть указан здесь же, но может быть прописан в коде.
 * Определение: набор ссылок на другие словарные статьи.
 * Машинный код, скомпилированный сюда при создании слова. Кроме того, что, вероятно, необходимо некое выравнивание, других ограничений нет.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.6. DICTIONARY / СЛОВАРЬ\3.6.2. SEARCH STRATEGY / СТРАТЕГИЯ ПОИСКА
ТЕКСТ
One basic principle applies to dictionary search: it must be backwards - from latest to oldest entries.
You have perhaps noticed that the dictionary is not arranged in any order (ie. alphabetical) other than that in which entries are made.
This permits the same word to be re-defined, and the latest meaning to be obtained.
There is no trade-off valuable enough to compromise this property.
***
Основной принцип поиска в словаре: он ведется назад - от самой последней до самых старых записей.
Другого порядка в словаре просто нет.
Это позволяет переопределять слова, вводя для них новые статьи.
Нет никакого резона изобретать что-то иное.
***
To identify a word, place it (or its first portion) in a register and compare for equality with each entry (or its first portion).
An algebraic comparison is adequate.
Concern is sometimes expressed that treating words as floating-point numbers may permit a false equality.
This has 0 probablity and you can always change the word - ignore it.
***
Чтобы идентифицировать слово, разместите его (или его часть) в регистре, и сравнивайте на равенство с началом каждой статьи.
Обычное арифметическое сравнение.
Некоторые беспокоятся, что использование для этого сравнения с плавающей точкой может дать ложное совпадение.
Вероятность этого ничтожна, игнорируйте.
***
A full-word compare (rather than a character-by-character) should be used for speed.
A match is usually found on the first portion, and extensions may be treated with less efficiency (though still full-word compares).
***
Сравнение словами быстрее, чем по-символьное.
Вероятность найти расхождение в начале слова гораздо больше, и концы слов можно сравнивать и с меньшей эффективностью.
***
Fixed-length entries may be scanned with a simple loop.
Linked entries require an equally simple loop, but usually a slower one.
However the speed of a linked search can be increased without limit: Rather than link each entry to its physical predecessor, link it to a predecessor in one of a number of chains.
Scramble the word to determine which chain it belongs in, both when you enter it and when you search for it.
Thus, only a fraction of the total dictionary need be searched to find the word or assure its absence.
***
Поиск в статьях фиксированной длины может быть реализован простым циклом.
При применении связанного списка статей цикл поиска остается простым, но замедляется.
Однако, скорость поиска может быть увеличена: использовать вместо списка хэш-таблицу.
Находите хэш-функцию от слова и ищете не в полном списке, а только в одном из списков слов с совпадающими значениями хэш-функции.
А последние заведомо очень короткие.
***
The number of chains should be a power of 2: 8 will provide a useful increase in speed.
The scramble technique may be very simple: add the first few characters together and use the low-order bits.
In order to maintain a linked dictionary, the next available location and the location of the last entry must be kept.
A multiply-chained dictionary requires the location of the last entry for each chain: a small price in space for a large gain in time.
***
Число таких списков должно быть степенью двойки, 8 уже даст значительное ускорение.
Хэш-функция может быть очень проста: сложите несколько первых символов слова и возьмите младшие разряды.
Нормальное поле связи с предшествующим словом, все-таки, придется сохранить для обслуживания словаря.
Подобная методика требует хранения таблицы ссылок на начала списков, но это маленькая цена за большую скорость.
***
However, search time is not a important consideration, and I advise against multiple chains unless the dictionary is very large (hundreds of entries).
***
Однако, оптимизация поиска не столь важна, и я против хэш-таблиц для небольших словарей (несколько сотен статей).

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.6. DICTIONARY / СЛОВАРЬ\3.6.3. INITIALIZATION / ИНИЦИАЛИЗАЦИЯ
ТЕКСТ
The dictionary is built into your program and is presumably initialized by your compiler.
This is centainly true if you have fixed-size entries.
Variable-sized entries must be linked together, however, and this can be beyond the ability of your compiler, especially if you have multiple chains.
***
Словарь заранее включается в вашу программу и, возможно, инициализируется вашим компилятором.
Это особенно легко при использовании статей фиксированного размера.
Правильно расставить ссылки, тем более при использовании хэш-списков, многим компиляторам не по силам.
***
In such a case, it is a simple matter to write a loop that scans the dictionary and establishes the links.
It should scan the core occupied by the dictionary and recognise an entry by some unique flag (7's in the link field).
It can the pick up the word, scramble it and add it to the appropriate chain.
***
В таком случае, надо написать простенький цикл для связывания.
Он должен пробежать все пространство словаря, распознавая статьи по определенным сигнатурам (семерки в поле связи).
Найдя, считает хэш-функцию и привязывает слово к спискам.
***
This is purely temporary code.
Although it may call permanent subroutines to scramble and link, the initialization code will have no further use.
Thus it should be placed where it can be overlaid as the program proceeds.
The message buffer, if large enough, or the disk buffer are possibilities.
***
Это одноразовый код.
Хотя он и может вызывать какие-то подпрограммы, но сам используется только при инициализации.
Т.о. после выполнения, на его место вполне можно записать что-нибудь полезное.
Например, буфер сообщений или дисковый буфер.
***
Other things may need initializing, particularly any registers that are assigned specific tasks.
All such duties should be concentrated in this one place.
***
Возможно придется инициализировать и что-то еще, например нужные для чего-то определенного регистры.
Весь код инициализации должен быть собран в одном месте.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\3. PROGRAMS WITH INPUT / ПРОГРАММЫ С ВВОДОМ\3.7. CONTROL LANGUAGE, EXAMPLE / ЯЗЫК УПРАВЛЕНИЯ, ПРИМЕР
\7.НОВОСТИ\СТАРЫЕ НОВОСТИ\СТЕК\ПРИКЛАДНОЙ ЯЗЫК БЕЗ СТЕКА
ТЕКСТ
Applications tend to be complicated before they become interesting.
But here's a fairly common problem that shows off a control language to advantage.
Implementation would be tricky, execution woud be inefficient; but the program would be simple, and its application flexible.
***
Обычно, приложения становятся сложными быстрее, чем интересными.
Но здесь может помочь язык управления.
Сколь угодно сложное и гибкое поведение может быть доступно и простой программе.
***
The problem is to examine a sequential file, select certain records, sort them, and list them - in many different ways.
Suppose these variables define the fields in the record:
***
Пусть, надо читать последовательный файл, выбирать некоторые записи, сортировать их, выдавать их - различными способами.
Пусть, эти переменные определяют поля записей:
***
NAME AGE SALARY DEPT JOB SENIORITY
***
Let's define these verbs:
***
Определим глаголы:
***
LIST SORT EQUAL GREATER LESS
***
Each acts upon the temporary file produced by the previous, in accordance with the following examples:
***
Каждое действие будет порождать временный файл, служащий исходным для следующего действия:
***
List in alphabetical order all employees in dept 6:
***
Список (в алфавитном порядке) всех служащих 6-го отдела:
***
6 DEPT EQUAL NAME SORT LIST
***
First we choose records with dept = 6 and copy them into a temporary file.
Then we sort that file by name.
Then we list it.
***
Сначала мы выбираем все записи 6-го отдела и копируем их во временный файл.
Затем сортируем его по именам.
Вносим результат в список.
***
List twice, by seniority, all employees holding job 17 in dept 3:
***
Двойной список по старшинству, все служащие, работающие над проектом 17 в 3-ем отделе:
***
17 JOB EQUAL 3 DEPT EQUAL SENIORITY SORT LIST LIST
***
List, by age, all employees whose salary is greater than $10,000; and identify those whose seniority is less than 3:
***
Список по возрасту, все служащие, чье жалованье большее $10,000 и/или чья выслуга меньше чем 3:
***
10000 SALARY GREATER AGE SORT LIST 3 SENIORITY LESS LIST
***
Several comments seem indicated.
We can apply a logical "and" by using several select verbs in sequence; we cannot use a logical "or".
We can sort on several fields, if our sorting technique does not unnecessarily re-arrange records.
We need 2 more verbs:
***
Несколько комментариев.
Мы можем реализовать логическое "и", используя несколько глаголов выбора последовательно; но не логическое "или".
Мы можем сортировать сразу по нескольким полям, если наша техника сортировки не будет избыточно перемешивать записи.
Нам надо еще два глагола:
***
REWIND END
***
to start over with the original file, and to quit.
***
- вернуться к первоначальному файлу и закончить работу.
***
Actually many other capabilities could be provided, including the ability to locate specific records and modify them.
But rather than design a particular application, I just want to show how nouns and verbs combine to provide great flexibility with a simple program.
Notice how even such a simple example uses all our facilities: the word subroutine, the number subroutine, the dictionary, the stack.
We're not speculating, we are providing essential code.
***
Можно придумать еще много чего, включая выбор и модификацию указанных записей.
Это просто пример, я только хочу показать, как существительные и глаголы объединяются, чтобы обеспечить большую гибкость простой программы.
Заметьте, как даже в таком простом примере мы использовали все наши инструменты: WORD, NUMBER, словарь, стек.
Мы не размышляем на пустом месте, мы подкрепляем свои идеи написанием кода.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\4. PROGRAMS THAT GROW / ПРОГРАММЫ, КОТОРЫЕ РАСТУТ
ТЕКСТ
So far our dictionary has been static.
It contains all the entries you need - placed there when the program was compiled.
This need not be.
We can define entries that will cause additional entries to be made and deleted.
Let me point out why this might be desirable.
***
Пока наш словарь был неизменным.
Он заранее содержал все необходимые статьи, которые помещались в него при компиляции.
Это не обязательно.
Мы можем создать статьи, которые будут добавлять или удалять словарные статьи.
Зачем?
***
You have a program that controls an application.
Based upon the words you type, it will do as you direct.
In Chapter 3 we provided the ability to type out results.
Not the sort of results that are the inevitable result of the application, but variables that you'd maybe like to see.
More a conversational sort of output, since it is controlled directly by input.
***
Вы имеете программу, которая управляет приложением.
Что вы печатаете, то она и делает.
В Главе 3 мы научились печатать отчеты.
Но вы могли бы хотеть видеть их в другом виде.
Например, управлять выводом при помощи специального диалога.
***
There are 2 problems with this situation.
Firsts, to add an entry to your dictionary you must re-compile the program.
Clearly, you won't be adding many entries - but maybe you won't have to.
Second, all your entries must be present at the same time.
This creates, not so much a volume problem, as a complexity problem.
If your application is complex, it becomes increasingly difficult to make all aspects compatible.
For instance, to find distinct names for all fields.
Third, if you find an error in an entry you must recompile the program.
You have no ability to correct an entry - though of course you could define entries to provide that ability.
***
Тут две проблемы.
Во-первых, чтобы добавить новый код, вам надо перекомпилировать программу.
Из-за немногих добавлений запускать заново компиляцию не хочется.
Во-вторых, то, что мы добавим таким образом, будет в нашем словаре все время работы программы.
Это порождает не столько проблему объема, сколько проблему сложности.
Чем сложнее ваше приложение, тем сложнее делать его механизмы совместимыми.
Например, чтобы выбрать уникальные имена для всех полей.
В-третьих, если вы находите ошибку во вводе, вы должны повторно компилировать программу.
Вы не имеете никакой возможности исправить ввод на ходу, хотя, конечно, вы могли бы определить статьи, чтобы ее обеспечить.
***
If you can create dictionary entries you can accomplish 2 things:
 * You can apply your program to different aspects of your application - without conflicts and reducing complexity.
 * You can create a dictionary entry differently, and thus correct an error.
 In fact, the purpose of your program undergoes a gradual but important change.
You started with a program that controlled an application.
You now have a program that provides the capability to control an application.
In effect, you have moved up a level from language to meta-language.
This is an extremely important step.
It may not be productive.
It leads you from talking to your application to talking about your application.
***
Если вы можете создавать словарные статьи:
 * Вы можете легко изменять вашу программу - без пересборки, и не загромождая ее инструментарием;
 * Вы можете тут же переопределить неправильную статью.
Фактически, ваша программа приобретает новое качество.
Вы начали с программы, которая управляла приложением.
Теперь вы имеете программу, которая обеспечивает способность управлять приложением.
Вы перешли с уровня языка на уровень мета-языка.
Это - чрезвычайно важный шаг.
Не делать, а управлять действием.
***
Another way of viewing the transition is the entries in your dictionary.
At first they were words that executed pieces of code that constituted your application program.
A purely control function.
Now they tend to become words that let you construct your application program.
They constsitute a problem-oriented-language.
The distinction need not be abrupt but it is irreversible.
You change from an application to a system programmer - your system being your application.
***
С другой стороны.
Сначала были слова, которые выполняли куски кода, которые составляли вашу прикладную программу.
Они вполне управляли процессом.
Теперь добавились слова, позволяющие вам создавать прикладные программы.
Они создают проблемно-ориентированный язык.
Перемена небольшая, но она необратима.
Из прикладного вы становитесь системным программистом.
***
I hesitate to say whether this is good or bad.
By now you surely know - it depends on the application.
I suspect any application of sufficient complexity, and surely any application of any generality, must develop a specialized language.
Not a control language, but a descriptive language.
***
Я не знаю, хорошо это или плохо.
Вы уже конечно знаете - все зависит от приложения.
Я думаю, что любое сложное приложение требует своего языка.
Не языка управления, а языка, описывающего его действие.
***
Some examples: A simulator does not want a control language.
It is important to be able to describe with great facility the system being simulated.
A linear-programming problem needs a language that can describe the problem.
A compiler actually provides a descriptive language for use with the programs it compiles.
A compiler-compiler describes compilers.
What is a compile-compiler that can execute the compiler it describes and in turn execute the program it compiled?
That is the question!
***
Пример: симулятору не нужен язык управления.
Важно уметь описать моделируемую систему.
Непосредственно решаемая проблема нуждается в языке, который может описать проблему.
Компилятор определяет язык программирования.
Компилятор компиляторов описывает язык программирования компиляторов.
Компилятор компиляторов компиляторов?
Вот, в чем вопрос!
***
Let me now assume that you have a problem that qualifies for a descriptive language.
What dictionary entries do you need?
***
Позвольте мне теперь предположить, что перед вами проблема, которая требует описательного языка.
В каких словарных статьях вы нуждаетесь?

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\4. PROGRAMS THAT GROW / ПРОГРАММЫ, КОТОРЫЕ РАСТУТ\4.1. ADDING DICTIONARY ENTRIES / ДОБАВЛЕНИЕ СЛОВАРНЫХ СТАТЕЙ
ТЕКСТ
Let us now assume that you want to expand your dictionary; that you have a sufficiently complex application to justify a specialized language.
How do you make a dictionary entry?
Recall the control loop: it reads a word and searches the dictionary.
If you want to define a word, you must not let the control loop see it.
Instead you must define an entry that will read the next word and use it before RETURNing to the control loop.
In effect, it renders the following word invisible.
It must call the word subroutine, which is why it is a subroutine rather than a routine.
Let us call such an entry a defining entry, its purpose is to define the next word.
***
Допустим, вы хотите расширить ваш словарь; и что вам действительно это надо.
Как создать словарную статью?
Вспомните цикл управления: он читает слово и ищет его в словаре.
Если вы хотите определить слово, вы не должны позволить управляющему циклу его увидеть.
Вместо этого прочесть это слово и использовать его для создания словарной статьи - до выполнения RETURN для возврата в цикл управления.
Т.о. цикл управления этого слова не увидит.
Используем подпрограмму WORD.
Такое слово, создающее статью, назовем словом, определяющем следующее слово.
***
In principle we only need one defining entry, but we must supply as a parameter the address of the code to be executed for the entry it defines.
Remember that 4 fields are required for each entry: the word, its code address, a link, and (optionally) parameters.
The word we obtain from the word subroutine; the link we construct; the parameters we take from the stack.
We could also take the address from the stack, but it's more convenient to have a separate defining word for each kind of entry to be constructed.
That is, to have a separate defining entry for each address we need, that provides the address from its parameter field.
***
По большому счету, создание словарной статьи - это связывание слова с его кодом.
Вспомним, что для каждой статьи нужно создать четыре поля: слово, его адрес кода, связь, и (возможно) параметры.
Слово мы получает от подпрограммы WORD; связь, это адрес предыдущего слова; параметры мы берем из стека.
Мы могли также брать адрес со стека, но более удобно иметь отдельное слово для создания словарных статей определенного типа.
Адрес кода новой статьи будем брать из поля параметров определяющего слова.
***
I'm afraid this is confusing.
We have one entry that supplies the address field of a new entry from its own parameter field.
Let's take an example; suppose we want to define a constant:
***
Как бы не запутаться.
Мы имеем статью, которое записывает в поле адреса кода новой статьи содержимое своего поля параметров.
Например, мы хотим определить константу:
***
0 CONSTANT ZERO
***
0 is placed on the stack; the code for the word CONSTANT reads the next word, ZERO, and constructs a dictionary entry for it: it establishes the link to a previous entry, stores 0 from the stack into the parameter field, and from its own parameter field stores the address of the code ZERO will execute.
This is, presumably, the address of code that will place the contents of the parameter field onto the stack.
Thus for each kind of entry we will be making, we need a defining entry to supply the code address and do the work.
Since all defining entries have much in common, you should write an ENTRY subroutine they can call.
It should have as parameter the code address, and construct all of the new entry except the parameter field, which is specialized by the defining entry.
***
0 помещен в стек; код слова CONSTANT читает следующее слово - ZERO - и строит для него словарную статью: связывает его с предыдущей статьей, сохраняет 0 со стека в поле параметров, копирует в поле адреса из своего поля параметров адрес кода, который будет выполнен при обращении к ZERO.
Скорее всего, этот код будет помещать на стек содержимое своего поля параметров.
Таким образом для каждого вида статей нужно создать определяющее слово, хранящее адрес нужного вида кода.
Так как все определяющие слова похожи, то напишем для них подпрограмму ENTRY.
Она будет получать адрес кода в виде параметра, и создавать новую словарную статью (за исключением поля параметров, т.к. оно зависит от вида слова).
***
Other defining entries might be:
 0 INTEGER I - an integer-size parameter field is initialized to 0; its address will be placed on the stack.
 1. REAL X - a floating-point parameter field is initialized to 1.
 8 ARRAY TEMP - an 8 word parameter field is cleared to 0; the address of its 1st word will be placed on the stack.
***
Примеры возможных определяющих слов:
 0 INTEGER I - целая переменная, инициализируемая нулем, кладет на стек адрес своего поля параметров.
 1. REAL X - вещественная переменная, инициализируемая 1.
 8 ARRAY TEMP - 8-словный массив, заполняется нулями; крадет на стек адрес его первого слова.
***
I must emphasize the word "might".
Different applications will require different defining entries; even the same word might act differently for different applications.
But you are in a position to define any kind of noun you need, and then create as many instances of that noun as you like.
It is a futile exercise to attempt to establish a universal set of nouns.
Compiler languages have repeatedly stumbled by not providing enough, and no matter how many they provide, someone will want one more.
***
Я должен подчеркнуть - "возможные".
Различные приложения требуют различных определяющих слов; даже одни и те же слова в разных приложениях могут иметь разный смысл.
Но вы можете создавать столько видов существительных, сколько вам надо, и при помощи них создать сами существительные.
Создание универсального набора существительных бессмысленно.
Это вечная проблема компилируемых языков, как ни пытаются они предусмотреть все случаи, все равно кому-то хочется большего.
***
For example, you might define the following noun:
 0 8 INDEX J - J is defined to be an index, that varies from 0 to 8. When executed, it adds its value to the top of the stack.
***
Например:
 0 8 INDEX J, где J - индекс, изменяющийся от 0 до 8. Кладет на стек текущее значение.
***
If you then define appropriate verbs to advance, test and reset J, you can have a powerful indexing facility.
***
Если вы добавите соответствующие глаголы, чтобы увеличивать, проверять и сбрасывать J, вы получите мощное средство индексации.
***
Or define:
 3 VECTOR X 3 VECTOR Y 9 VECTOR Z
 and define arithmetic verbs to implement vector arithmetic:
 X Z = Z Y + add X and Y, store in Z.
 X Y Z *C multiply X and Y (outer product), store in Z.
***
Или:
 3 VECTOR X 3 VECTOR Y 9 VECTOR Z
 И арифметические глаголы, чтобы получить арифметику:
 X Z = Z Y + - конкатенация X и Y в Z.
 X Y Z *C - перемножение X и Y с записью в Z.
***
Anything you need for your application you can define.
But you can never define everything.
Basic Principle!
***
Все, что вам нужно, вы можете определить.
Определить все Вы не сможете.
Основной принцип!

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\4. PROGRAMS THAT GROW / ПРОГРАММЫ, КОТОРЫЕ РАСТУТ\4.2. DELETING ENTRIES / УДАЛЕНИЕ СТАТЕЙ
ТЕКСТ
So far we've only discussed defining nouns.
Actually you'll be using more verbs than nouns, but they require much longer explanations.
Here is one kind of verb.
***
Пока мы обсуждали определение существительных.
Но потребность в глаголах значичельно выше, и мы до них еще дойдем.
Все глаголы создаются одинаково.
***
If you can add entries to your dictionary, eventually you're going to want to get rid of them.
You'll need to delete entries in order to re-enter them correctly, or delete entries in order to make room for another application.
After all, your dictionary is finite; no matter how large you make it, you will be aware of its upper limit.
Parkinson's Law may be rephrased: Dictionaries expand to fill the available space.
***
Если вы научились добавлять статьи в словарь, то, захотите научиться и избавляться от них.
Удалять ошибочные статьи или просто освобождать место.
В конце концов, ваш словарь конечен.
Вариант Закона Паркинсона: каждый словарь будет расширяться, пока не заполнит все доступное место.
***
There is only one feasible way to delete entries.
That is to delete all entries after a certain point.
If you were to delete specific entries, you would leave holes in the dictionary, since it occupies contiguous core.
If you attempt to pack the dictionary to recover the holes, you are faced with a wicked re-location problem, since we use absolute addresses.
To avoid absolute addresses is inefficient and unnecessary.
***
Есть только один способ удалять статьи.
Удалить все статьи начиная с какого-то места словаря.
Удаление статей по одной породило бы кучу дырок в памяти.
Упаковать словарь для закрытия этих дырок, значит получить кучу проблем с пересчетом абсолютных адресов.
Не использовать абсолютные адреса - неэффективно и избыточно.
***
Deleting trailing entries is a completely satisfactory solution.
I know of no argument to prove thie, except to say try it and see.
You'll find that, in practice, you add a bunch of entries; find a problem; delete those entries; fix the problem; and reenter all the entries.
Or you fill your dictionary for one application; clear it; and re-fill with another application.
Or you might re-load the same application just to clear some fields.
In each case, you want to get rid of all the latest entries.
***
Удаление этой и всех последующих статей - вполне удовлетворительное решение.
Доказано практикой.
Обычно определения добавляются группами, нашли ошибку - исправили - перезагрузили группу.
Добавляете по одному?
Тоже работает - проверили - стерли - набили заново.
Освободить память?
Тоже, вроде, получается.
В каждом случае, вы, скорее всего, хотите избавиться от всех последних статей.
***
One exception is when you use some entries to construct others.
The constructing entries are then no longer needed, and there is no way to get rid of them.
It happens; I may even give some examples later.
But all you lose is dictionary space, and I can't see a practical solution.
***
Одно исключение - определяющие слова.
Они слишком глубоко закопаны.
Такое бывает.
Но тут уж ничего не поделаешь.
***
OK, how do you delete trailing entries?
You want to mark a point in your dictionary and reset evereything to that position.
One thing is the dictionary pointer that identifies the next available word in the dictionary.
That's easy.
However you must reset the chain heads that identify the previous entry for each of your search chains.
It only takes a small loop: follow each chain back, as you do when searching, until you find a link that preceeds your indicated point.
***
Как происходит удаление?
Просто отмечаете место словаря, начиная с какой-то точки, как свободное.
Однако, вы должны переопределить начала цепочек поиска слов.
Тут необходим маленький цикл, удаляющий из цепочек все адреса, пока не будет достигнут адрес, меньший адреса точки очистки.
***
If you have fixed-size entries, you must reset the pointer to the parameter area, but you don't have to follow links.
***
Если вы используете статьи фиксированного размера, то нужно только переустановить указатель свободного места, связей никаких нет.
***
A convenient way to specify the point you want to delete from is to place a special entry there.
A verb that will delete itself and evereything following it when you execute it.
For example,
***
Удобный способ определить точку очистки, разместить там специальную статью.
Ее код удалит себя и все, что введено позже.
Например,
***
REMEMBER HERE
***
When you type HERE, it is forgotten; it both marks a place in the dictionary and executes the deleting code.
HERE doesn't need a parameter field, unless you use fixed-length entries, whereupon it must save the current value of the parameter pointer.
This is our first example of a verb-defining entry.
***
Когда вы напечатаете HERE, оно удалит себя и все, что за ним.
HERE не нуждается в поле параметров, если вы не используете статьи фиксированной длины (тогда надо где-то хранить указатель на область хранения переменных частей).
Это - наш первый пример определения глагола.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\4. PROGRAMS THAT GROW / ПРОГРАММЫ, КОТОРЫЕ РАСТУТ\4.3. OPERATIONS / ОПЕРАЦИИ
ТЕКСТ
Recall that the stack is where arguments are found.
There are some words you may want to define to provide arithmetic capabilities.
They are of little value to a control language, but essential to add power to it.
I'll use logical constructs TRUE (1) and FALSE (0).
And remember the definition of top and lower from 3.6.
***
Вспомните про стек.
Нужны кое-какие слова простейшей арифметики.
Язык управления в них не особо нуждается, но вычислительную мощность они повышают.
В качеств логических используются значения TRUE (1) и FALSE (0).
Вспомните определения стековых терминов.
***
Unary operators: change the number on top of the stack.
 MINUS changes sign of top.
 ABS sets sign positive.
 ZERO if top is zero, replace it with TRUE; otherwise place FALSE onto the stack.
 NONZERO if top is nonzero, place TRUE onto the stack; otherwise leave it alone (leave FALSE on the stack).
***
Одноместные операторы: изменяют верхнее значение.
 MINUS - изменение знака.
 ABS - абсолютная величина.
 ZERO - если ноль - TRUE, иначе - FALSE.
 NONZERO - если ноль - TRUE, иначе - без изменения (т.е. FALSE).
***
Binary operators: Remove top from the stack and replace lower by a function of both.
 + add top to lower.
 * multiply lower by top.
 - subtract top from lower.
 / divide lower by top, leave the quotient.
 MOD divide lower by top, leave the remainder.
 MAX if top is larger than lower, replace lower by top.
 MIN if top is smaller than lower, replace lower by top.
 ** raise lower to power of top.
***
Двухместные операторы: снимают со стека верхнее и заменяют нижнее результатом операции над обоими.
 + - сложить верхнее и нижнее.
 * - умножить нижнее на верхнее.
 - - вычесть верхнее из нижнего.
 / - разделить нижнее на верхнее, оставить частное.
 MOD - разделить нижнее на верхнее, оставить остаток.
 MAX - если верхний больше нижнего, заменяет нижнего верхним.
 MIN - если верхний меньше нижнего, заменяет нижнего верхним.
 ** - возвести нижнего в степень, указанную верхним.
***
These are only samples. Clearly you are free to define whatever words you feel useful.
Keep in mind that you must place the arguments on the stack before you operate on them.
Numbers are automatically placed on the stack.
Constants are too.
Thus the following make sense:
 1 2 +
 PI 2. *
 1 2 + 3 * 7 MOD 4 MAX
 1 2 3 + *
***
Это только примеры.
Вы определяете те операции, которые полезны для вас.
Имейте в виду, аргументы должны быть загружены на стек до выполнения операции.
Числа загружаются на стек автоматически.
Константы - тоже.
Примеры:
 1 2 +
 PI 2. *
 1 2 + 3 * 7 MOD 4 MAX
 1 2 3 + *
***
This notation permits arithmetic calculation in the same manner a desk calculator.
It is often called parenthesis-free representation or perhaps right-handed Polish, but it is simply the way you work with arguments on a stack.
Conventional algebraic notation is much harder to implement (8.2).
***
Нотация - как у настольного калькулятора.
Ее называют бесскобочной или обратной польской записью, но суть проще - такова специфика работы со стеком.
Обычную алгебраическую нотацию осуществить сложнее (8.2).
***
Other binary operations are the arithmetic relations: these leave a truth value on the stack:
 = are they equal?
 &lt; is top greater than lower?
 &gt; is top less than lower?
 &gt;= is top not greater than lower?
 &lt;= is top not less than lower?
***
Другие двухместные операции - отношения (оставляют на стеке логическое значение):
 = - равны?
 &lt; - верхний больше нижнего?
 &gt; - верхний меньше нижнего?
 &gt; - верхний не больше нижнего?
 &lt;= - верхний не больше нижнего?
***
The logical operations include a unary and several binary:
 NOT if top is FALSE, replace with TRUE; otherwise replace with FALSE.
 OR logical or.
 AND logical and.
 IMP logical implication.
 XOR logical exclusive or.
***
Логические операции включают одноместную и несколько двухместных:
 NOT - если верхний FALSE, заменить TRUE; иначе заменить FALSE.
 OR - логическое "или".
 AND - логическое "и".
 IMP - импликация.
 XOR - логическое "исключитающее или".
***
Your stack must have a fixed word-length.
However the operations mentioned above might apply to several kinds of numbers: integers, fixed-point fractions, floating-point fractions, double-precision fractions, complex numbers, vectors of the above kinds.
The truth values are only 1 bit.
Clearly, the stack must be able to hold the largest number you expect to use.
Less clear is how you should distinguish among various kinds of numbers.
***
Ваш стек должен иметь фиксированный размер слова.
Однако, действия, упомянутые выше, могли бы работать и с целыми, и с фикированной точкой, и с плавающей точкой, и с числами двойной точности, и с комплексными, и с векторами...
Логические переменные, вообще, вмещаются в один бит.
Ясно, что размер слова стека должен вмещать самое длинное из нужных вам чисел.
Совсем неясно, как различать какого типа число на стеке.
***
One way is to define separate operations for each kind of number:
 + integer and fixed-point add (they are the same).
 +F floating-point add.
 +D double-precision add.
***
Один путь состоит в том, чтобы определить отдельные операции для каждого вида чисел:
 + - сложение целых и с фиксированной точкой (это одно и тоже).
 +F - сложение чисел с плавающей точкой.
 +D - сложение чисел двойной точности.
***
Another is to make a stack entry long enough to contain a code identifying the kind of number.
This makes the code defining each operation more elaborate and raises the problem of illegal arguments.
I recommend not checking arguments and defining separate operations, for reasons of simplicity.
Actually, you are working with one kind of number at a time and the problem may never arise.
***
Другой выход - хранить в слове стека вместе с числом информацию о его типе.
Это делает код операций намного сложнее и поднимает проблему ошибок типа.
Я рекомендую не проверять аргументы и определить отдельные операции; так проще.
Обычно вы одновременно работаете с числами только одного типа, и никакой проблемы не возникает.
***
Do not bother with mixed-mode arithmetic.
You never need it, and it's not convenient often enough to be worth the great bother.
With multiple word numbers (complex, double-precision) you may put the address of the number on the stack.
However, this leads to 3-address operations with the result generally replacing one of the arguments.
And this, in turn, leads to complications about constants.
***
Не пользуйтесь арифметикой со смешением типов.
Это не нужно, не удобно и очень затратно.
Для громоздких чисел (комплексных, двойной точности) вы можете помещать на стек не значение, а их адрес.
Однако, это ведет к 3-адресным операциям с результатом, записываемым в один из аргументов.
И это, в свою очередь, ведет к осложнениям с константами.
***
In general, the number of things you might do with numbers increases indefinitely.
Many of these are mutually incompatible.
Basic Principle!
***
Вообще, тема арифметики неисчерпаема.
И многие решения будут взаимно несовместимы.
Основной Принцип!

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\4. PROGRAMS THAT GROW / ПРОГРАММЫ, КОТОРЫЕ РАСТУТ\4.4. DEFINITION ENTRIES / ОПРЕДЕЛЕНИЕ СТАТЕЙ
ТЕКСТ
I must now describe an entry more complicated than any so far, though not the most complicated that you'll see.
It is also exceptional in that it's not optional.
For this ability is required for any effective application language: to be able to define one word in terms of others.
To abbreviate, if you will.
You recall that I characterised words as being simple in themselves, but powerful in combination.
Well here is a way to combine words.
***
Приступаем к более сложным вещам.
Описываемый здесь механизм обязательно нужно реализовать.
Он обеспечивает важнейшее свойство проблемно-ориентированного языка - определять одни вещи через другие.
Т.е. придумывание аббревиатур, заменяющих целые предложения.
Вы же помните, что я характеризовал слова как сами по себе простые, но мощные в комбинации.
Как же они комбинируются?
***
A definition consists of a defining entry ":" followed by a series of words terminated by ";".
The intention is that the word defined by ":" has the meaning expressed by the words that follow.
For example:
***
Определение начинается со слова ":", затем следуют другие слова, и заканчивается определение словом ";".
Слово ":" определяет следующее за ним слово через слова, которые идут дальше.
Например:
***
: ABS DUP 0 LESS IF MINUS THEN ;
***
This is a definition of the word ABS.
Its purpose is to take the absolute value of the number on the stack.
It does this by executing a series of words that have the proper effect.
***
Определение слова ABS.
Получение абсолютного значения верхнего числа.
О чем и говорят идущие следом слова.
***
You may consider this a rather clumsy definition of ABS.
Especially since there is an instruction on your computer that does exactly that.
you're quite right, definitions tend to be clumsy.
But they let us use words that we hadn't the foresight to provide entries for.
Given certain basic words we can construct any entry we need.
Definitions provide a succinct distinction betwen a control language and an application language: The control language must have all its capabilities built in; the application language can construct those capabilities it needs.
***
Определение довольно неуклюжее?
Тем более, для выполнения этой операции есть специальная команда процессора.
Вы совершенно правы, определения часто неуклюжи.
Но они позволяют нам создавать слова, придуманные по ходу дела.
Имея небольшой набор базовых слов мы сможем обработать ввод любой сложности.
Наличие определений, это - главное различие между языком управления и прикладным языком: язык управления должен включать все свои инструменты изначально, прикладной язык может сам создавать свои инструменты.
***
To implement definitions is simple, yet awkwardly subtle.
The parameter field of a definition contains the addresses of the dictionary entries that define it.
You must somehow deposit these entries in the parameter area, and later fetch them when you execute the definition.
The complementary processes of definition and execution are more involved than for any other entry we've encountered.
***
Определение работает просто и тупо.
Адреса слов, входящих в определения записываются в поле параметров создаваемого слова.
А когда новое слово будет выполняться, куски кода по этим адресам будут вызваться.
Этого достаточно для создания статьи с любым нужным поведением.
***
Before I describe these processes in detail, let me try to clarify exactly what a definition is.
You recall that the code executed for a word is a routine, and not a subroutine.
And yet a series of words is like a series of subroutine calls, for the control loop serves the function of returning to a position where the next word can be found.
You might consider a definition to be just that: a series of subroutine calls with the addresses of the subroutines constituting the definition.
***
Прежде чем углубиться в детали, еще немного общих мест.
Вспомните, что код слова - программа, а не подпрограмма.
И все же, здесь последовательность слов работает, как последовательность подпрограмм, после выполнения одного слова цикл управления возвращает нас в точку вызова следующего.
Ряд адресов подпрограмм, которые выполняются одна за другой?
***
Another viewpoint is concealed in an abbreviation I use: I speak of "executing a word", when I really mean executing the code associated with the word.
Or even more precisely, executing the code whose address is stored in the dictionary entry for the word.
The abbreviation is not only convenient, it suggests that a word is an instruction that can be executed.
And indeed, it is helpful to think of a word as an instruction: an instruction for a computer that is being simulated by our real computer.
Let's call that imaginary computer the "virtual computer".
Thus when you type words you are presenting instructions to the virtual computer.
The control loop becomes the instruction fetch circuitry of the virtual computer.
***
Еще одна тонкость: я говорю "выполнение слова", хотя подразумевается выполнение кода, связанного со словом.
Или даже более точно, выполнение кода, адрес которого записан в поле кода словарной статьи слова.
Сокращение не только удобно, оно уравнивает слово с машинной командой, которая может быть выполнена.
И действительно, полезно думать о слове как о машинной команде: команде для компьютера, который моделируется нашим реальным компьютером.
Давайте называть этот мнимый компьютер виртуальным.
Т.о. когда вы печатаете слова, вы печатаете инструкцию виртуальному компьютеру.
Цикл управления описывает логику процессора виртуального компьютера.
***
If we extend this analogy to definitions, a definition becomes a subroutine for the virtual computer.
And the process of defining a definition is equivalent to compiling this subroutine.
We'll return to this analogy later.
***
Продолжая аналогию, получаем, что определение является подпрограммой виртуального компьютера.
И процесс определения определения эквивалентен компилиляции этой подпрограммы.
Мы возвратимся этой аналогии позже.
***
You'll see that the virtual computer is a real help in understanding definitions.
In fact, it originally led me to apply compiler techniques to definitions - techniques that otherwise wouldn't have occurred to me.
But although it may be helpful to programmers, it is only confusing to non-programmers.
So I prefer the name "definition" for this type of entry, and the phrase "defining one word in terms of others" as its explanation.
***
Ведение термина "виртуальной машины" упрощает понимание других определенияй.
Именно он надоумил меня на применение в определениях техники компилирования.
Однако, что полезно программистам, запутает не-программистов.
Так что я предпочитаю термин "определение" для этого типа статей и фразу "определение одного слова через другие".
***
Definitions are extremely powerful.
Why, is hard to explain, hard even to comprehend.
Their value is best appreciated by hindsight.
You complete a ludicrously simple implementation of an application, discover that you used a dozen definitions and nested them 8 deep.
The definitions appear responsible for the simplicity.
***
Механизм определений чрезвычайно мощен.
Зато, труднообъясним.
Их практическое удобство трудно предвидеть теоретически.
Вы заканчиваете писать нелепо простое приложение, и обнаруживаете, что вы использовали дюжину определений а глубина их вложения может достигать восьми.
Но писать было очень просто - благодаря определениям.
***
But there are several properties that emphasize the value of definitions over their equivalent, a series of subroutine calls.
First, you needn't be concerned about call sequence, about what registers are available and what must be saved; simply type a word.
Second, one definition can execute another.
That is, you can nest definitions, again without any concern about saving return addresses or other register conflicts.
You can even use definitions recursively without concern.
Third, you can pass arguments among definitions effortlessly, in fact invisibly, since they are on the stack.
Again you have no concern for calling sequence or storage conflicts.
Plenty of temporary storage is available, too; again on the stack.
***
Имеются несколько свойств, которые происходят из аналогии между определениями и последовательностями подпрограмм.
Во-первых, вас совершенно не интересует, как реализовано слово, также как вас не интересуют подробности реализации подпрограммы.
Во-вторых, одно определение может использовать другое.
То есть вы можете использовать механизм вложения подпрограмм без выяснения как организуются вызовы и возвраты.
Вы можете даже использовать рекурсивные определения.
В-третьих, вы можете легко передавать аргументы, так как они находятся на стеке.
Вам не нужно волноваться о том, что какой-то из них пропадет.
На стеке можно хранить и временные переменные текущей подпрограммы.
***
Of course you have to pay for this convenience, though probably less than you would with FORTRAN subroutine calls.
The price is the control loop.
It's pure overhead.
Executing the code for each entry of course proceeds at computer speed; however obtaining the address of the next code to execute takes some instructions, about 8.
This is why I urge you to optimize your control loop.
***
Конечно вы платите за это удобство, хотя намного меньше, чем вы платили за подпрограммы FORTRAN.
Цена - цикл управления.
И все.
Выполнение кода происходит со скоростью компьютера; однако получение адреса следующего куска кода требует приблизительно восьми инструкций.
Вот почему я призываю оптимизировать цикл управления.
***
Notice that if the code executed for words is long compared to the control loop, the cost is negligible.
This is the principle of control languages.
As the code shrinks to control loop size, and smaller, overhead rises to 50% and higher.
This is the price of an application language.
Note, however, that 50% overhead is easily reached with operating systems and compilers that support an application program.
***
Заметьте, что, чем длиннее куски кода слов, тем незначительнее потери.
Это - принцип языка управления.
При уменьшении фрагментов кода до размеров кода цикла управления потери достигают 50% и выше.
Это - цена прикладного языка.
Обратите внимание, однако, что 50%-потери обычны для операционных систем и для обычных компиляторов.
***
I suggest that you compromise.
Code the computation-limited portions of your problem and use definitions for the rest.
The use of definitions to control, rather than perform, calculations is inexpensive.
And the ease of constructing them reduces the time and effort, and thus cost, of implementation.
***
Я предлагаю компромисс.
Закодируйте критические части вашей программы, и используйте определения для остального.
Использование определений, скорее, для управления, чем для исполнения, делает вычисления недорогими.
А т.к. легкость их написания сокращает траты времени и усилий, то все просто замечательно.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\4. PROGRAMS THAT GROW / ПРОГРАММЫ, КОТОРЫЕ РАСТУТ\4.4. DEFINITION ENTRIES / ОПРЕДЕЛЕНИЕ СТАТЕЙ\4.4.1. DEFINING A DEFINITION / ОПРЕДЕЛЕНИЕ ОПРЕДЕЛЕНИЯ
ТЕКСТ
The defining entry ":" acts just like any other.
It passes the address EXECUTE to the ENTRY subroutine.
I'll discuss that code in the next section.
It then sets a switch STATE.
The control loop must be changed to test STATE: if it is 0, words are executed as I've already described; if it is 1, words are compiled.
Let me repeat: if you add definitions to your program, you must modify the control loop so that it will either execute or compile words.
If you plan to include definitions from the start, you should plan the control loop accordingly.
Implement the switch so that executing words is as fast a possible; you'll execute many more words than you'll compile.
***
Определение статьи при помощи ":" проходит как и создание прочих статей.
Предлагаем EXECUTE в качестве адреса кода и выполняем подпрограмму ENTRY для создания новой статьи.
Про код расскажу позже.
Затем устанавливаем переключатель STATE.
Цикл управления должен быть изменен для проверки STATE: если он сброшен (0), слова исполняются, как было описано выше; если же он установлен (1), слова компилируются.
Поовторю: если вы хотите вводить определения, ваш цикл управления должен и выполнять, и компилировать слова.
Если вы планируете использовать определения с самого начала, вы должны соответственно программировать цикл управления.
Попытайтесь реализовать переключатель с наименьшими потерями; выполнять слова вы будете гораздо чаще, чем компилировать.
***
To compile a word is simple.
After finding it in the dictionary, you have the address of its dictionary entry.
Deposit this address in the parameter field.
Notice 2 things: we already have a mechanism for depositing words in the dictionary.
ENTRY uses it as well as many defining entries for parameters.
The dictionary pointer DP identifies the next available word in the dictionary.
All you must do to compile a word is to store its address at DP and advance DP.
Also notice that we deposit the address of the entry not the address of the code executed.
This is so we have access not only to the code but also to the parameter field, and even the word itself should we need it.
***
Компиляция проста.
Проведя поиск в словаре, вы получаете адрес статьи.
Добавьте этот адрес в поле параметров.
Два замечания: мы уже имеем механизм создания словарных статей.
ENTRY создает все поля статьи, кроме поля параметров.
Указатель словаря DP указывает на свободное место словаря.
Все, что вы должны сделать, чтобы скомпилировать слово, это сохранить его адрес туда, куда указывает DP и продвинуть DP.
Также заметьте, что мы сохраняем адрес статьи, а не адрес кода.
Так мы имеем доступ не только к коду, но также и к полю параметров, и, даже, к полю слова.
***
All right, so much for compiling words.
What about numbers?
A number presented to a compiler is called a literal.
And literals are a problem to any compiler.
Fortunately we can define our virtual computer so that it can handle literals in-line.
You must again modify the control loop to test STATE when a number is successfully converted.
***
Про компиляцию слов хватит.
Что с компиляцией чисел?
Число, встретвшееся в программе, относится к литералам.
А литералы - проблема для любого компилятора.
К счастью, мы можем определять наш виртуальный компьютер так, чтобы он мог обращаться с литералами.
Вы должны снова изменить цикл управления, чтобы проверять STATE в момент, когда число успешно конвертировано.
***
Before showing how to compile a number, let me define pseudo-entries.
A pseudo-entry is a dictionary entry that is not in the dictionary.
That is, it has the format of an entry but it is not linked to other entries.
Thus it would never be found during a dictionary search.
You see, we occassionally need entries to permit the virtual computer to run smoothly, but we don't want to slow the dictionary search by including non-referencable entries.
***
Определим понятие псевдо-статьи.
Псевдо-статья - это статья, которой нет в словаре.
Т.е. статья есть, но в списках поиска ее нет.
Т.о. ее никогда не удасться найти.
Такое решение принято для того, чтобы добавить статьи, нужные для работы виртуального компьютера, но не замедлить процедуру поиска слов в словаре.
***
As you've probably guessed, in order to compile a literal you compile a pseudo-entry.
You then follow it by the number itself; that is, you compile the number also.
The result is a double-length virtual-computer instruction.
The code executed for the pseudo-entry must fetch the number and place it onto the stack.
Thus literals that are compiled have the same effect, when executed, as if they were executed immediately.
***
Как вы уже догадались, при компиляции литералов будет скомпилирована псевдо-статья.
Следом записывается само число.
Результат - инструкция виртуального компьютера двойной длины.
Код псевдо-статьи должен взять число и положить его на стек.
Т.о. скомпилированные литералы при выполнении будут работать так же, как и при их непосредственном исполнении.
***
Notice that if you have different-size literals, you'll need different pseudo-entries for them And having brought up the subject, let me discuss word length a moment.
Word length for the virtual computer should be about 12 bits.
This is because each instruction is composed of simply a dictionary address and 12 bits is enough to identify one of perhaps 1000 entries.
If your real computer word length is longer than 18 bits you should pack several virtual-computer instructions into one word.
This is possibly awkward, since you must modify DP to address other than a real computer word.
But you'll save a lot of space.
***
Заметьте, что, если вы используете литералы различного размера, вам будут нужны различные псевдо-статьи; заодно обсудим размер компьютерного слова.
Длина слова для виртуального компьютера должна быть около 12 бит.
Этого хватит для прямой адресации словаря более, чем на 1000 статей.
Если слово вашего компьютера длиннее 18 бит, вы должны будете упаковывать несколько инструкций вашего виртуального компьютера в одно машинное слово.
Это, возможно, неудобно, т.к. DP должно будет адресовать что-то более мелкое, чем машинное слово.
Но, зато, вы сэкономите много места.
***
Incidently, since literals require extra space when compiled, you might define commonly used literals as words:
***
Для экономии места Вы могли бы хранить наиболее часто встречающиеся литералы в виде констант:
***
1 CONSTANT 1
***
Recall that numbers may be words, since the dictionary is searched before numeric conversion is attempted.
And a word requires only a single-length virtual-computer instruction.
On the other hand, a dictionary entry takes much more space than a compiled literal, so watch the trade-off.
***
Эта константа будет найдена намного быстрее, чем уйдет на конвертирование числа.
И будет компилироваться одинарной инструкцией.
С другой стороны, вы потеряете место на создание новой статьи.
***
The code in the control loop that compiles words much watch for ";".
It is compiled as usual, but it also resets STATE to prevent further compiling.
It also performs another task, which requires a digression.
***
Слова будут компилироваться пока не встретится слово ";".
Оно компилируется как обычно, но еще сбрасывает STATE, заканчивая компиляцию.
Кроме того, оно делает кое-что еще.
***
Notice that when we're compiling a definition we're searching the dictionary for each word.
If we reference the word we've just defined, we'll find it.
Thus we'll have made a recursive reference.
If you want recursive definitions, fine.
However it's extrememly convenient to exchange recursion for re-definition. That is, to understand a reference to itself inside a definition to refer to an earlier definition.
For example,
***
Заметьте, что, когда мы компилируем определение, мы каждое слово ищем в словаре.
Если мы поищем в словаре слово, которое сейчас определяем, мы его немедленно найдем.
Т.о. получив рекурсию.
Если именно это вы и хотели, прекрасныо.
Однако, гораздо удобнее таким образом переопределять слова.
Т.е. трактовать ссылку на определяемое имя, как ссылку на предыдущую статью с таким же именем.
Например,
***
: = SWAP = ;
***
Here I redefine the = verb to operate upon arguments in the opposite order.
I could use a different word for that purpose, but = has mnemonic significance.
***
Здесь я переопределяю глагол "=", чтобы обрабатывать аргументы в обратном порядке.
Я мог бы придумать новое слово для той цели, но "=" имеет удобное мнемоническое значение.
***
In any case, the capability is easy to provide.
Let ":" bugger the search so the latest entry cannot be found.
And let ";" unbugger the search and thereby activate the new definition.
If you want recursive definitions, you could provide a defining entry ":R" that did not bugger, providing you make ";" work for both.
I'll mention another technique later.
***
В любом случае, это легко реализовать.
Пусть ":" блокирует поиск самой последней статьи.
И пусть ";" его разблокирует.
Если вы хотите использовать рекурсивные определения, вы можете вместо ":" использовать ":R" - тоже, но без блокировки, ";" будет подходить для обоих случаев.
Позже я приведу другое решение.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\4. PROGRAMS THAT GROW / ПРОГРАММЫ, КОТОРЫЕ РАСТУТ\4.4. DEFINITION ENTRIES / ОПРЕДЕЛЕНИЕ СТАТЕЙ\4.4.3. IMPLEMENTATION / ИСПОЛНЕНИЕ
ТЕКСТ
I hope you now appreciate the need for words that are executed at define time.
I'm sure you're aware of the need for branches and loops.
Perhaps you'll notice that I did not mention labels; the branch generating words I mentioned, and others you can invent, are perfectly capable of handling jumps without labels.
You saw in the definition of HERE how the stack can be manipulated to permit overlapping jumps as well as nested ones.
However in a sense we have many labels, for every dictionary entry effectively assigns a name to a piece of code.
***
Я надеюсь, что вы поняли, зачем нужны слова, выполняющиеся во время компиляции.
Ветвления и циклы всегда полезны.
Причем метки для их реализации совершенно не нужны.
На примере HERE мы видели, что управление стеком позволяет вкладывать конструкции самым разным образом.
Однако, с другой стороны, меток у нас более, чем достаточно, ведь, словарные статьи - это они и есть.
***
Now to consider some problems I glossed over.
Clearly you must be able to recognize those words that are to be executed during definitions.
That is, IF, THEN, BEGIN, END, etc. must somehow override the normal mechanism whereby the control loop would compile them.
I mentioned a switch that distinguished execution from compilation.
Let's establish a similar flag (1 bit) in each dictionary entry, with the values
 1: execute
 0: compile
applying both to switch and flag.
For a given entry, 'or' the switch and flag together; if either is 1, execute the word, else compile it.
***
Вернемся к проблеме, которую я замял.
Как распознать те слова, которые должны выполняться на этапе определения?
Т.е. IF, THEN, BEGIN, END и т.д. должны так или иначе прервать обычный цикл управления, стремящийся их откомпилировать.
Я упомянул переключатель, значение которого отличало выполнение от компиляции.
Давайте устанавливать подобный флаг (1 бит) в каждой словарной статье:
 1: выполнить,
 0: компилировать,
анализируемый совместно с переключателем.
Для данной статьи объединяем значение и переключатель по "или"; если любой из них 1, выполняем слово, иначе компилируем.
***
The above rule is correct, and even fairly efficient.
Remember that we want the control loop efficient!
And it's adequate providing all words that must be executed are built into your system dictionary.
Unfortunately, it's not adequate for the examples I gave above, which probably means it's inadequate, since those were pretty simple examples.
But complication is part of the fun of programming.
So pay attention and I'll try to explain some problems I don't understand very well myself.
***
Это корректно и, даже, эффективно.
Ведь мы же хотим сделать цикл управления эффективным!
Работает для всех слов, включенных в словарь.
К сожалению, это не работает для слов, которые я приводил в некоторых примерах, а, ведь, они были просты.
Значит, будем устранять проблему.
Обратите внимание, я пытаюсь объяснить то, что сам плохо понимаю.
***
Editor: I don't understand my concern about SWAP below.
The word ! did not endure.
Don't try to reconcile what I said.
I can't.
***
Я сам не понял, что меня насторожило в SWAP.
Cлово "!" мертворожденное.
Не пытайтесь понять, что я написал.
Я сам не понимаю.
***
Consider the definition of HERE I gave above:
***
Вспомните определение:
***
: HERE SWAP THEN ;
***
Here is one of those imperative words; it must be executed at definition time.
But it is defined as an ordinary definition - and would be compiled.
Even if we managed to execute HERE, the first word in its definition is SWAP: a most ordinary word, and one that would certainly be compiled, except that we intend it, too, to be executed.
The next word, THEN, offers no problem - or does it?
If we can execute HERE we'll also execute THEN, since it's imperative.
However we have a problem at the time we define HERE; we'll try to execute THEN, when we want to compile it.
That is, sometimes we want to compile imperative words; and sometimes we want to execute ordinary words - even in a definition.
***
Это слово должно выполняться на этапе определения.
Но само должно определяться нормально.
При выполнении HERE, SWAP будет стремится откомпилироваться, вместо того, чтобы выполниться.
C THEN нет никакой проблемы, или есть?
Выполняя HERE, мы выполним и THEN.
Однако мы имеем проблему во время определения HERE, ведь THEN не захочет просто так компилироваться.
Т.о. иногда мы хотим компилировать слова обязательные для выполнения; а иногда мы хотим выполнить обычные слова - даже во время определения.
***
So, what to do?
I bet you think I have a solution.
Your faith is touching, but I don't have a very good one.
It suffers a small restriction, but a nagging one: you may not execute a literal in a definition.
To phrase it positively: literals must be compiled inside definitions.
Let's see how it works.
***
Так, что делать?
Держу пари, вы думаете, что я знаю ответ.
Ваша вера трогательна, но мой решение не очень красиво.
Оно работает, но с ограничением: Вы не можете выполнять во время определения литералы.
Впрочем, зачем? Литералы должны копилироваться.
Как это работает?
***
Consider the switch STATE.
It's normally 0; ":" makes it 1 to indicate compilation.
Let's define a new defining entry ":!" that acts exactly like ":" with 2 exceptions:
 * It sets the entry flag to 1; to mark an imperative word.
 * It sets STATE to 2; to force all words to be compiled. Since the test in the control loop is to execute if STATE and flag are equal, nothing will execute.
 ";" is unchanged; its sets STATE to 0 for both sorts of definitions.
This solves all our problems except SWAP. How do we execute words that ordinarily would be compiled?
Define a new entry "!".
Let it execute the last entry compiled and remove it from the compilation. Now we can re-write the definition of HERE as
***
Рассмотрим переключатель STATE.
Нормально - 0; ":" делает устанавливает его в 1, указывая на компиляцию.
Давайте определим новую определяющую статью ":!".
Она работает подобно ":" с двумя исключениями:
 * Устанавливает флаг статьи в 1 - отмечает обязательное для исполнения слово.
 * Устанавливает STATE в 2; заставляя компилироваться все слова, т.к. слова исполняются, если значения переключателя и флага равны.
";" остается тем же самымм; он сбрасывая STATE в 0.
Это решает все наши проблемы, кроме SWAP.
Как мы выполним слово, которое обычно компилируется?
Определим новую статью - "!".
Пусть он исполняет последний скомпилированный адрес и удаляет его из скомпилированного кода.
Теперь мы можем переписывать определение HERE
***
:! HERE SWAP ! THEN ;
***
and it will work.
I'll review the rules:
 * All words are normally executed.
 * Only words flagged imperative are executed in definitions.
 * Any word can be made imperative by following it with an "!".
 * A definition can be made imperative by using ":!" instead of ":" to define it.
***
Это будет работать.
Правила:
 * Все слова обычно выполняются.
 * Только слова с установленным флагом могут исполняться в момент определения.
 * Любое слово после которого стоит "!", исполняется.
 * Слова с установленным флагом определяются через ":!" вместо ":".
***
Now the restriction I mentioned should be apparant.
A literal cannot be made imperative with a "!" because it's a double-length instruction - and the "!" code has no way of knowing that.
Oh well, we could set a field to indicate the length of the last compiled instruction, but it's not that great a problem.
Besides, in that case successive !s wouldn't work.
***
С литералами это не проходит.
Потому, что их инструкция состоит из двух слов.
Конечно, можно было бы хранить где-то адрес последней инструкции, но не такая уж это важная проблема.
Кроме того, в том случае не работала бы последовательность из нескольких "!".

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\4. PROGRAMS THAT GROW / ПРОГРАММЫ, КОТОРЫЕ РАСТУТ\4.5. CODE ENTRIES / КОДОВЫЕ СТАТЬИ
ТЕКСТ
I've explained definitions and how they, in effect, compile instructions for the virtual-computer.
What about compiling code for your real computer then?
Of course you can.
But you probably won't.
***
Я объяснил, как компилировать инструкции для виртуального компьютера.
А как быть с компиляцией для настоящего компьютера?
Конечно, вы можете это сделать.
Но, вероятно, не будете.
***
The Basic Principle intrudes.
If you add code entries to your program, you add enormous power and flexibility.
Anything your computer can do, any instructions it has, any tricks you can play with its hardware are at you fingertips.
This is fine, but you rarely need such power.
And the cost is appreciable.
You'll need many entries (say 10) to provide a useful compiler; plus all the instruction mnemonics.
Moreover you'll have to design an application language directed at the problem of compiling code.
***
Работает Основной Принцип.
Если вы добавляете код в вашу программу, вы добавляете максимальную мощность и гибкость.
Вы можете все, что может компьютер.
Это прекрасно, но вам это очень редко надо.
И затраты растут.
Для этого вам понадобится штук десять статей, плюс мнемоники инструкций.
Кроме того, вы еще должны будете изобретать прикладной язык компиляции.
***
I don't want to down-grade the possibility or value of such efforts, but you wrote your program in some language to start with.
If you need additional code it's much easier to re-compile your program and add what you need.
Only if you have an application that needs tailored code.
or can profit by providing different code to different users, or different code at different times, can you satisfy the Basic Principle.
***
Мы написали программу поддержки языка.
Если нужен новый код проще добавить его в программу и перекомпилировать.
Конечно, вашей целью может быть написание приложения, компилирующего код.
Или ваши пользователи хотят иметь код по своему вкусу.
Только тогда Основной Принцип оправдает такое усложнение.
***
On the other hand, if you start with code entries, you can construct all the other entries I've been talking about: arithmetic operators, noun entries, definitions.
In Chapter 9 I'll show how you can use code entries in a really essential role; and achieve a significantly more efficient and powerful program than by any other means.
But except for that I'm afraid they are marginal.
***
С другой стороны, если вы научитесь компилировать код, вы сможете создавать новые арифметические операторы, новые типы существительных, компилирующие слова.
В Главе 9 я покажу, как вы можете использовать код с пользой, достигая максималной эфективности.
Но, все это крайние меры.
***
So how can you generate code?
First you need a defining entry that defines a code entry.
The characteristic of a code entry is that it executes code stored in its parameter field.
Thus the address passed to ENTRY by its defining entry (say CODE) must be the location into which will be placed the first instruction.
This is not DP, because the entry itself takes space; but is simply DP plus a constant.
***
Как вы можете генерировать код?
Сначала вы нуждаетесь в статье, создающей кодовую статью.
Главное свойство кодовых статей - хранение кода в поле параметров.
Адрес, попадающий в ENTRY, должен быть получен определением (назовем его CODE) и показывать на начало куска кода.
DP не подходит, т.к. должно быть еще зарезервировано место под заголовок статьи.
***
Second you need an entry to deposit a number at DP.
We have used such a routine several times, constructing variables and definitions, but we've not had an entry for it.
I suggest the word "," although that might conflict with your output entries.
All it does is move a number from the stack to the parameter field.
Instructions are numbers of course.
You'll construct them on the stack and then deposit them.
Incidently, this is a useful entry - apart from compiling code.
You'll find it useful for initializing data arrays of all kinds.
***
Нужна статья для сохранения числа по адресу DP.
Мы использовали эту подпрограмму уже несколько раз, строя переменные и определения, но мы не оформляли ее в виде статьи.
Я предлагаю слово "," хотя так мы уже называли слово печати числа.
Все что оно делает, это кладет верхнее число со стека в поле параметров.
Наши коды, ведь, тоже числа.
Вы будете строить их на стеке и затем записывать.
Такое слово окажется полезным не только для компиляции кода.
Им будет удобно инициализировать самые разные данные.
***
Now you can appreciate the source of my earlier caution.
You'll have to provide a flock of entries that access code compiled into your program that we've not needed to reference directly before.
For example RETURN: when you routine is finished, it must jump to the control loop, just as you built-in entries do.
However you don't know the location of the control loop in core; and it moves as you change your program.
So you must have an entry to generate a RETURN instruction.
***
Теперь вы можете понять мои давнишние опасения.
Вы будете должны создать множество словарных статей, которые компилируют полезный код, но не вызываются напрямую.
Например, RETURN: когда программа закончена, она должна перейти в цикл управления.
Однако, где в памяти входная точка цикла управления?
Так что вы должны будете создать статью для RETURN, чтобы она связалась при компиляции.
***
Likewise, if you plan to compile defining entries you must provide entries that will generate subroutine calls to ENTRY.
Other code might want to access WORD or NUMBER or indeed any facility already available in your program.
Moreover you will have to define variable entries for those fields you will use: D and F for output; perhaps STATE and BASE;
Basically, the problem is that you must make available outside your program, all the labels available inside it already.
You must use them enough to justify the effort.
***
Аналогично, если вы создаете компилирующие слова, вы должны создавать и статьи для хранения кода, адрес которого будет передаваться ENTER.
Благодаря этому, к вашим WORD и NUMBER сможет получить доступ кто угодно.
Кроме того, надо будет определить статьи для используемых переменных: D и F для вывода; STATE и BASE.
Проблема состоит в том, что вы делаете доступными извне внутренние точки программы.
Вы, поэтому, должны обосновать их доступность их полезностью.
***
All right, you've done that much.
Now you've got to decide how to construct an instruction.
They have several fields - instruction, index, adddress - that you'll want to put onto the stack separately and combine somehow.
This is easy to do, but hard to design.
You probably don't want to copy your assembler, and probably couldn't follow its format conveniently anyway.
In fact you can do a good job of designing a readable compiler language; but it will take some effort.
Definitions provide all the tools you need.
***
Вот и поговорили.
Теперь о том, как строить инструкцию.
Она состоит из нескольких частей - код операции, индекс, адрес, которые надо как-то скомбинировать.
Это легко делать, но трудно спроектировать.
Просто так копировать ассемблер не интересно.
Это будет работа по созданию полноценного компилятора.
Но все необходимые для вас инструменты уже есть - определения.
***
For example, you might write a definition that will "or" together an instruction and address and deposit it.
Or if your hardware's awkward, you can provide a definition that converts absolute addresses to relative, or supplies appropriate paging controls.
Whatever you need, or want can be readily defined.
Done properly, such a compiler is a substantial application in itself, and if you're going to do it at all, plan to spend the necessary time and effort.
***
Вы можете без проблем написать определение, объединяющее (по "или") код операции и адрес и размещающее их.
Если надо, вы можете преобразовывать абсолютные адреса в относительные или использовать страничную организацию.
Вы можете все.
Компилятор, он и есть компилятор - серьезная программа.
***
We discussed conditional statements and loops for the virtual computer.
Precisely the same techniques apply here, with due allowance for hardware variations.
In fact, I originally applied the stack-oriented branch generation to code for my real computer.
Such statements are really the difference between an assembler and a compiler.
Keep in mind the Basic Principle.
***
Мы обсуждали условные и циклические конструкции виртуального компьютера.
Подобные методы можно использовать и здесь.
На самом деле, я впервые применил стековое разрешение переходов для написания кодов моего реального компьютера.
Когда превращал ассемблер в компилятор.
Помните Основной Принцип.
***
One valuable use of a compiler is the permit the definition of new kinds of nouns.
That is, to construct new defining entries.
As an example consider using the primitive compiler to define instruction entries as described just above.
Or you might want to define entries that multiply the top of the stack by a constant.
***
Компилятор позволит определять новые виды существительных.
Т.е. строить новые определяющие слова.
Рассмотрим пример описанного выше.
Напишем слово, умножающее верхнее число стека на константу.
***
As usual when adding an ability, several distinct entries must cooperate to provide it.
In this case ENTER and ;CODE.
Let me illustrate:
***
Как обычно, требуется совместно использовать несколько специальных слов.
В этом случае - ENTER и ;CODE .
Вот так:
***
: UNIT ENTER , ;CODE 1 V LDA , SP MPY , SP STA , NEXT ,
 2.54 UNIT IN
 4. IN
***
The first line defines the word UNIT.
The next line uses this defining entry to define the word IN (inches).
The last line uses IN in a way that puts 4 inches onto the stack, as centimeters.
The 3 lines are equivalent to
***
В первой строке определяется слово UNIT (т.е. единица измерения).
В cледующей строке оно используется, чтобы определить слово IN (в дюймах).
В последней строке при помощи IN в сантиметры переводится 4 дюйма.
Эквивалентное определение IN
***
: IN 2.54 * ;
***
which is certainly simpler.
But if you want to define many UNITs, a special defining entry is much more convenient and efficient.
***
оно, конечно же проще.
Но, зато, при помощи UNIT вы можете эффективно определить много подобных слов.
***
The first special word is ENTER.
It calls the ENTRY subroutine used by all your defining entries, but passes a 0 address as the location of the code to be executed.
Look at the definition of UNIT.
The word ENTER is imperative.
It generates a double-length pseudo-instruction; a pseudo-entry for the first half and a 0 constant for the second.
At execution time, the pseudo-entry will call ENTRY to construct a new dictionary entry, passing the following constant as the address of code to be executed.
The word ;CODE is a combination of the words ";" and CODE.
It terminates the definition of UNIT and stores DP into the address field established by ENTER.
Thus the code that follows ;CODE is the code that will be executed for all entries created by UNIT.
;CODE knows where to store DP because ENTER is restricted to being the first word in any definition that uses it; and ;CODE knows which definition it is terminating.
***
Первое из новых слов - ENTER.
Оно вызывает подпрограмму ENTRY как всякое определяющее слово, но пишет 0 в поле адреса.
Смотрим на определение UNIT.
Слово ENTER обязательно.
Оно производит псевдо-инструкцию двойной длины; псевдо-статью и 0.
Во время выполнения псевдо-статья вызовет ENTRY (чтобы построить новую словарную статью), передавая ему 0 из второй половины псевдо-инструкции.
Слово ;CODE - комбинация слов ";" и CODE.
Оно заканчивает определение UNIT и сохраняет DP в поле адреса, установленное ENTER.
Т.о. код, который следует за ;CODE, будет выполняться для всех статей, созданных UNIT.
;CODE знает, куда сохранять DP потому, что ENTER обязательно первое слово в подобных определениях и ;CODE знает, какое определение оно заканчивает.
***
The restriction on the position of ENTER is unimportant, it may as well be first as anywhere else.
In the case of UNIT, only a "," to deposit the constant was needed.
Other nouns might need more elaborate processing to establish their parameter field.
***
Ограничение на расположение ENTER в начале определения незначительно.
"," в UNIT нужна для размнщения константы.
Другие существительные могли бы нуждаться в более сложном коде для формирования поля параметров.
***
You notice I gave an example of code following ;CODE.
You see instruction mnemonics and addresses deposited by ",".
I don't want to explain this compiler language, for it is not relevant for your computer.
***
Вы видите код после ;CODE - инструкции и адреса, обращающиеся в т.ч. к константе, размещенной ",".
Я не хочу объяснять язык своего ассемблирующего компилятора, т.к. для вашей машины будет нужен другой.
***
One more suggestion might prove helpful.
You might define a new kind of constant: an instruction.
When executed, an instruction expects an address on the stack, extracts a constant from its parameter field and constrcts and deposits a completed instruction.
You'll probably have a large number of instructions, and use a large number.
This will save you many deposit entries.
***
Еще одна полезная идея.
Вы можете определить новый вид констант - инструкции.
Когда они исполняются, снимают со стека адрес, комбинируют его с инструкцией, хранящейся в поле параметров, и размещают результат.
Таких инструкций понадобится много.
И статей, ими созданных, тоже будет много.
***
I'm sorry, but I think it's infeasible to attempt an example.
If you can't see how to construct your own code entries from what I've already said, forget it.
The application is extremely machine dependent - and rightly so.
Don't attempt to apply the same code to several computers; definitions already do that for you.
The purpose of code is to exploit the properties of your particular computer.
***
Боюсь, пример здесь не поможет.
Если вы не поняли, как делать кодовые слова, забудьте.
Приложение с кодовыми словами будет слишком машинно-зависимым.
Обычные определения гораздо удобнее.
Код нужен только для доступа к специфическим возможностям вашего компьютера.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\5. PROGRAMS WITH MEMORY / ПРОГРАММЫ С ПАМЯТЬЮ
ТЕКСТ
You may perhaps grant the value of a program that grows, without being willing to provide the volume of input required.
Naturally it does little good to have a hundred dictionary entries if you must type every one.
Obviously we need a place to save entries and obviously that place is disk (or drum, or other random secondary memory).
***
Конечно, не хочется набивать большой объем ввода.
И заново создавать сотни статей.
Следовательно, надо их где-то хранить, например, на диске (или барабане, или другом устройстве произвольного доступа).
***
What is not obvious is how to store entries.
It ought to be a Second Principle that you never save anything on disk without being able to modify it, but this rule is universally ignored.
To simply copy dictionary entries violates another cardinal principle: never store core address on disk.
You could never modify your program without chasing down all code addresses.
***
В какой форме хранить статьи?
Тут работает Второй Принцип - всегда сохраняйте информацию в виде, пригодном для редактирования.
Прямое копирование статей на диск нарушит и еще один принцип - никогда не сохраняйте адреса.
Вам при редактировании программы пришлось бы все их пересчитывать.
***
Fortunately there is a solution.
Store on disk the text from which dictionary entries are constructed.
It is a simple matter to divert the input routine from reading your message buffer to reading disk.
This chapter will show how.
***
К счастью, есть решение.
Сохраняйте на диске ввод, который порождает построение ваших словарных статей.
Затем можно будет переключить программу ввода с чтения буфера сообщений на чтение диска.
Эта глава покажет, как.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\5. PROGRAMS WITH MEMORY / ПРОГРАММЫ С ПАМЯТЬЮ\5.1. ORGANIZATION OF DISK / ОРГАНИЗАЦИЯ ДИСКА
ТЕКСТ
There is only one way to organize disk.
In the same way that core is divided into a large number of words, disk must be divided into a large number of blocks.
In the same way that words are the smallest field that can be fetched from core, blocks are the smallest field that can be fetched from disk.
A block contains 256 words.
***
Есть только один способ организации диска.
Как ОЗУ разбито на большое количество слов, так диск разбит на большое число блоков.
Как слово - минимальный квант чтения из памяти, так и блок - минимальный квант чтения с диска.
В блоке 256 слов.
***
A block contains 256 words because that is the size of a 1-byte address, and because 256 4-byte words hold 1024 bytes which is the amount of text that can be displayed on a typical scope.
***
Блок содержит 256 слов потому, что для адресации слова достаточно одного байта, и потому, что если слова по 4 байта, то получается 1024 символа, что вполне по силам обычным устройствам отображения информации.
***
However, here is another instance in which your application and hardware must play a dominant role.
Disks usually have a hardware block-size that offers advantages.
You must choose a multiple of that.
Your application may involve storing data on disk, and you must choose a block size useful for data as well as text.
I say no less than 512 characters nor more than 1024.
128 word blocks have recently been mentioned; fine if the words are 6 or 3 bytes (characters).
***
Другая аппаратура - другие размеры.
Некоторые диски имеют определенный размер блоков.
Размер Ваших блоков должен быть ему кратен.
Доза хранимой информации должна быть разумной.
Я считаю - не менее 512 и не более 1024 символов.
128-словные блоки подходят для слов в 6 или 8 байт.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\5. PROGRAMS WITH MEMORY / ПРОГРАММЫ С ПАМЯТЬЮ\5.1. ORGANIZATION OF DISK / ОРГАНИЗАЦИЯ ДИСКА\5.1.1. GETTING BLOCKS / ПОЛУЧЕНИЕ БЛОКОВ
ТЕКСТ
In trying to anticipate the organization of a random file, certain principles are obvious.
Cross-references between blocks will probably be wanted.
Such references are simple if they use absolute block addresses; extremely clumsy otherwise.
We may use absolute addresses if we promise never to move a block.
This means we can never pack disk.
We agree cheerfully because we didn't want to pack disk anyway.
***
Очевидны и некоторые другие принципы организации наших файлов произвольного доступа.
Понадобятся ссылки на блоки.
Они удобны, если являются абсолютными адресами блоков; иначе - очень неудобны.
Абсолютные адреса дают сбой только, если блоки перемещаются.
Это значит, что диск нельзя упаковывать.
Мы соглашаемся, потому что и не собирались это делать.
***
This means that as the data in blocks becomes useless, space will become available in block-sized holes.
We must somehow re-use these holes.
Which means that we must allocate, and re-allocate, disk in block-sized pieces.
***
Это означает, что если надобность в каких-то блоках исчезнет, на диске появятся "дыры".
Их надо как-то заполнять.
Это значит, что мы должны распределять дисковое пространство блоками.
***
All addresses start at 0, block addresses included (otherwise you find youself forever adding and subtracting 1).
However we cannot use block 0 - for anything.
You will find that most addressing errors involve block 0.
If you look at block 0 from time to time you will find the most amazing things there.
You will find block 1 a useful place to store things you need to remember from run to run.
Like the address of the first block available for re-use - none: 0.
And the address of the last block used - initially: 1.
***
Все адреса считаются, начиная с 0, включая адреса блокок (иначе Вам бы пришлось постоянно прибавлять и вычитать единицу).
Однако, мы не можем использовать блок 0.
Туда очень легко попадает мусор при ошибках.
Посмотрите и убедитесь.
Блок 1 удобно использовать сохранения данных между сеансами работы.
Там же хранятся номер первого блока в списке освободившихся (первоначально 0) и номер последнего использованного блока (первоначально 1).
***
You will want to copy disk (onto another disk, or tape) for protection.
You need only copy the nuber of blocks used, which is usually less than half the disk capacity, or else you're pretty worried about space.
If you destroy block 1 (you will) you will have to re-load the entire disk from your back-up.
Never try to recover just block 1, you'll end up horribly confused.
***
Вы захотите иметь возможность копировать свой диск на другой или ленту (для сохранности).
Копировать нужно только то число блоков, которые были использованы, обычно их не более половины диска, иначе начинаются проблемы с пространством.
Если Вы испортите блок 1, то перезагрузить придется все блоки.
Никогда не копируйте только блок 1, результат вас обескуражит.
***
You may want to put your object proram on this disk.
Fine!
It won't even take many blocks.
You may need to start it in block 0 in order to do an initial load (bootstrap).
OK, but be able to re-load the program (only) from back-up because you will destroy block 0.
Only if you destroy the block (we'll call it block 1) containing available space information must you re-load data (all data).
Unless you destroy many blocks.
Choose the path of least confusion, not least effort.
Re-loading disk will confuse you, you'll forget what you've changed and be days discovering it.
Much better you spend hours re-typing text and re-entering data.
***
Вы захотите поместить на диск вашу объектную программу.
Прекрасно!
Это не займет много блоков.
Если нужен автозапуск, то начать надо с блока 0.
Однако, надо оставить возможность загрузки с дублирующего диска, т.к. блок 0 Вы быстро испортите.
Перезагружать все блоки при порче блока 1 надо потому, что в нем хранится число использованных блоков.
Иначе вы потеряете много блоков.
Выберите путь минимизирующий ошибки и затраты.
Полная перезагрузка приведет к тому, что вы запутаетесь, что изменяли, а что нет.
Уж лучше перенабить утраченное за несколько часов.
***
So when you need a block, you type a word (GET) which reads block 1, places the block up for re-use on the stack, reads that block, places the contents of its first word into block 1, and re-writes block 1.
The first word, of course, contains the address of the next block up for re-use.
If no block was availabe for re-use (initially the case), GET increments the last block used, puts it on the stack and re-writes block 1.
GET then clears your new block to 0 and re-writes it.
***
Когда вам нужен блок, вы вводите слово GET, которое читает блок 1, кладет на стек номер первого блока из списка освободившихся, читает этот блок, переписывает его первое слово в блок 1, и переписывает блок 1.
Первое слово, конечно, содержит адрес следующего блока в списке освободившихся блоков.
Если этот список пуст (как сначала) GET увеличивает номер последненго использованного блока, помещает его на стек, и перезаписывает блок 1.
GET тогда затирает новый блок нулями и перезаписывает его.
***
Several comments: Notice that GET places its result on the stack - the logical place where it is available for further use.
Notice that blocks are re-used in preference to expanding the disk used.
This makes sense except for the problem of arm motion.
Forget arm motion.
You just have to live with it.
This is, after all, a random memory.
Don't neglect clearing the block to 0.
***
Несколько комментариев: число, возвращаемое GET на стеке - номер блока, готового для использования.
Т.о. более не нужные блоки используются повторно.
Сломать, конечно, можно все, но делать этого не следует.
Не перемещайте блоки!
Это, в конце концов, память произвольного доступа.
Не забывайте затирать новые блоки нулями.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\5. PROGRAMS WITH MEMORY / ПРОГРАММЫ С ПАМЯТЬЮ\5.1. ORGANIZATION OF DISK / ОРГАНИЗАЦИЯ ДИСКА\5.1.2. RELEASING BLOCKS / ОСВОБОЖДЕНИЕ БЛОКОВ
ТЕКСТ
To release a block, put it on the stack and say RELEASE.
It will read block 1, extract the next block for re-use, place the stack there and write block 1; then read the released block and place the old next-block in the first word.
All we're doing, of course, in constructing the chain of available blocks used by GET.
Possibly the block you release is linked to other blocks. You must release all those, too.
A convenient way is to use the first word as a link field.
Then the available block chain is the same as any other block chain.
To concatenate chains you place the first block in block 1, run down the chain to the last block (0 in link) and place the old next-block in that link.
***
Чтобы освободить блок, поместите его номер на стек и напечатайте RELEASE.
Его действие обратно GET - в 1 блок записывается номер освобождаемого блока, а в первое слово того - старый номер первого блока из списка освободившихся.
Возможно, блок, который вы освобождаете, связан с другими блоками.
Вы должны освободить и их.
Удобный путь состоит в том, чтобы использовать первое слово как поле связи.
Список освободившихся - частный случай такого списка.
Для связывания: вы запоминаете номер блока в блок 1, возвращаетесь к блоку и сохраняете в нем старый номер из блока 1.
***
Don't be tempted to maintain a count of the available blocks.
Its not worth the trouble.
If you must know, you can count the length of the available chain.
***
Не пытайтесь поддерживать индекс освободившихся блоков.
Оно того не стоит.
Если хотите, можете хранить длину списка освободившихся.
***
If you have enough different kinds of blocks, it may be useful to store a code identifying the block in the first word (or second).
You can then examine all blocks of a certain kind.
Available blocks should have code 0.
***
Если у вас несколько разных видов блоков, может быть полезно хранить код, указывающий тип блока в первом или втором слове.
Вы можете тогда перебирать все блоки некоторого вида.
Свободные блоки должны иметь код 0.
***
How many blocks you can have is probably limited by the disk, however it may be limited by the field you choose to store block addresses in.
Be careful!
You can circumvent the first limit by modifying your read subroutine to choose one of several disks.
You must re-format all your block addresses (cross-references on disk, remember) to expand the second.
***
Сколько блоков вы можете иметь, определяется размером диска и размером поля, отведенного для хранения номера блока.
Будьте осторожны!
Вы можете обойти первое ограничение, так изменив вашу подпрограмму чтения, чтобы иметь возможность выбора одного из нескольких дисков.
Для обхода второго, надо будет переформировать все ссылки в блоках.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\5. PROGRAMS WITH MEMORY / ПРОГРАММЫ С ПАМЯТЬЮ\5.1. ORGANIZATION OF DISK / ОРГАНИЗАЦИЯ ДИСКА\5.1.3. READING AND WRITING DISK / ЧТЕНИЕ И ЗАПИСЬ ДИСКА
ТЕКСТ
I'm sure you know how to read disk.
However, do not choose a block size that causes the slightest difficulty: like half a block between tracks.
If you check the GET routine, you'll see that you'll need 2 blocks in core at once.
This is a reasonable minimum, it makes it easy to move things from one block to another.
However, you'll have lots of core left over and you might as well use it for buffering disk; especially if access time is noticable.
***
Я уверен, что вы умеете читать диск.
Не берите только размер блока, который будет неудобен аппаратно.
Если вы посмотрите на GET, увидите, что одновременно надо держать в ОЗУ два блока.
Это - разумный минимум, позволяющий также легкое копирование из одного блока в другой.
Однако, при большом размере ОЗУ разумным будет создать еще буферов, особенно если время чтения значительно.
***
You'll want a table specifying which blocks are in core: your read routine can check this table before reading.
***
Нужна будет таблица, показывающая, какие блоки находятся в ОЗУ: ваша программа чтения будет проверять эту таблицу перед чтением.
***
But you should not write a block when you change it.
Rather mark it 'to be written' in the buffer table.
When you come to re-use that buffer, write the old block first.
The principle is that you're likely to change a block again if you change it once.
If you minimize writes you can save a lot of disk accesses.
Of course, there is a trade-off - if you program crashes, you may have updated blocks in core that aren't on disk.
You should be able to re-start your program and preserve the core buffers.
***
Вы не должны стремиться сразу записывать измененный блок.
Довольно пометить его, как "требующий записи", в таблице загруженных блоков.
Когда соберетесь загружать в буфер новый блок, тогда и запишите старый.
Дело в том, изменения блоков в одиночку не ходят.
Запись в последний момент сэкономит много времени.
Конечно, возможно, что программа закончится по ошибке раньше, чем успеет записать блоки.
Вы должны быть способны перезагружать программу без стирания буферов.
***
Of course, multiple core buffers imply an allocation problem.
A simple round-robin is as effective a scheme as any.
***
Конечно, многократные основные буфера подразумевают проблему распределения.
Простой циклический алгоритм подойдет не хуже любого другого.
***
If you are going to scan data sequentially, you can save many accesses by reading consecutive blocks at the same time.
However it is likely that random reads may be interspersed with these sequential ones.
An effective solution is to store the last block in the sequential area and the number of blocks somewhere for your read subroutine.
If the block isn't in core, and is within the sequential range, it can read as many consecutive blocks as there are consecutive buffers available.
Don't attempt more than this - ie, making more buffers available.
The net effect is that you will do the best you can with sequential blocks, subject to interfering constraints.
***
Если вы просматриваете данные последовательно, вы можете сэкономить много времени, считывая разом последовательные блоки.
Однако, такая последовательность может быть легко случайно разбита.
Эффективное решение: хранить в подпрограмме чтения номер последнего блока в последовательности и число загруженных блоков.
Если блок не находится в ОЗУ и лежит в пределах диапазона, считывайте подряд столько блоков, сколько влезет.
Дальнейшая оптимизация смысла не имеет, разве только сделать побольше буферов.
В общем, все зависит от аппаратуры.
***
You will inevitably spend a lot of effort reading-writing disk.
But remember the Basic Principle!
***
Вы неизбежно потратите много усилий, на реализацию чтения/записи.
Помните Основной Принцип!

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\5. PROGRAMS WITH MEMORY / ПРОГРАММЫ С ПАМЯТЬЮ\5.2. TEXT ON DISK / ТЕКСТ НА ДИСКЕ
ТЕКСТ
You will store a lot of text on disk - hundreds of blocks - but this is probably a small fraction of your disk.
The rest is presumably data for your application(s).
***
Вы будете хранить много текста на диске - сотни блоков - но это, вероятно, намного меньше емкости диска.
Остальное место может быть использовано для хранения данных вашего приложения.
***
A block that contains text (I mean text to be read and executed by your program) contains one long character string.
If the first word contains control information, it starts in the second word and extends until a particular word marks the end (perhaps ;S).
This end word is important because it is inconvenient to have the input routine test for end-of-block.
You quickly learn not to leave that word out.
***
Блок, который содержит текст (я подразумеваю - текст, пригодный в качестве ввода) содержит одну длинную строку символов.
Если первые слова заняты под служебную информацию, текст начинается от них, до специального слова-завершителя (возможно - ;S).
Такое слово применять гораздо удобнее, чем постоянно делать проверку на конец блока.
Вы быстро привыкните его ставить.
***
A block that contains text should have a special name, for you will be using it often in conversation.
I have called such blocks SHEETs - since the text filled a sheet of paper - and SCREENs - since the text filled the screen of a scope.
Define the word READ to save the input address, the block and character position of the next character to be scanned, on the return stack; and reset the input pointer to the block on the stack and the first character position.
Define the word ;S to restore the original input pointer.
Very simply you can have your program read block 123:
***
Блоку, содержащему текст, удобно придумать особое название.
Я назвал такие блоки SHEET-ами и SCREEN-ами.
Определите слово READ, сохраняющее адрес ввода, блок и положение курсора на стеке возвратов; установите указатель ввода на первую позицию блока, номер которого находится на стеке.
Определите слово ;S, чтобы восстановить первоначальный указатель ввода.
Вот как вы пополняете свою программу вводом из блока 123:
***
123 READ
***
However... there's always a however, isn't there.
You must modify your word routine to read the current block before scanning.
This is expensive but essential (of course no actual read is performed if the block is in core), for the last word executed may have caused a block to be read that overlaid the block the word was read from.
This can especially occur if one screen directs the reading of others (as they will).
No other solution to this problem has been satisfactory, so swallow the code - which need not be great.
You will find that with text on disk, the original characterization of 'input' as low volume is strained.
You will read many words and do many dictionary searches.
However, on a microsecond computer, you won't notice it.
***
Однако...
Вы должны изменить вашу программу WORD, чтобы иметь возможность считать блок в ОЗУ.
Это затратно, но необходимо (конечно, чтение блока необходимо не при чтении каждого слова).
Чтение блока понадобится, например, если один блок требует читать другой.
Никакое другое решение этой проблемы не подошло, так что, пишите нужный код.
Вы увидите, что ввод теперь больше происходит с диска, чем с клавиатуры.
Вы будете читать много слов и много искать в словаре.
Однако, это только микросекунды.

\7.НОВОСТИ\СТАРЫЕ НОВОСТИ\РЕДАКТОР ПО БРОУДИ\ОТКУДА ВЗЯЛСЯ РЕДАКТОР
\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\5. PROGRAMS WITH MEMORY / ПРОГРАММЫ С ПАМЯТЬЮ\5.2. TEXT ON DISK / ТЕКСТ НА ДИСКЕ\5.2.1. TEXT EDITING / РЕДАКТИРОВАНИЕ ТЕКСТА
ТЕКСТ
Never put anything on disk you can't modify!
And we haven't discussed how you get text on disk in the first place.
Do not load it from cards!
You're misdirecting your effort toward card reading, and you had to punch the cards anyway.
Type it.
The definitions required to edit the text stored in blocks (SCREENs) is simple.
***
Никогда не храните на диске того, что не умеете редактировать!
Откуда берется текст на диске?
Не грузите его с перфокарт!
Долой их!
Печатайте.
Редактируйте текст SCREEN-ов.
***
You must be able to handle character strings surrounded with quotes (4.1).
Given that, I shall exhibit a text editing screen.
This is a simple example of the value of definitions.
You may notice it is the first non-trivial exmple I've given.
You should be motivated by now to give it proper attention.
***
Вы должны быть способны работать со строковыми литералами.
Это важно для редактирования.
Рассмотрим простой пример.
Однако он требует внимания.
Разберитесь!
***
Naturally, you're going to have to type these definitions twice.
Once to put them into your dictionary; again, to use them to put them in a screen (bootstrapping).
In fact you'll probably type them many times, but 2 is minimum.
***
Эти определения вам придется набить дважды.
Один раз - для словаря; другой - для экрана автозагрузки.
Но вам, наверное, двух раз не хватит.
***
I'm going to exhibit an annotated copy of the EDIT screen I used in a particular program.
It uses system entries whose value may not be clear.
They are borrowed from other aspects of the application.
***
Я собираюсь показать откомментированный код EDIT, который использовал в одной из программ.
Он использует некоторые необъясненные статьи.
Они заимствованы из других программ.
***
0 C1 42 # :R RECORD
***
Here I am constructing a field description: RECORD is a 42 character field starting in character 1 of word 0 of the current block (understood).
I'm using blocks that can hold 15 42-character lines; a word has 6 characters, so that's 15 7-word lines.
***
Здесь я строю описание поля RECORD: 42 символа длиной, начинается с первой литеры нулевого слова текущего блока.
Я использую блоки в 15 строк по 42 символа; в слово влезает 6 символов, т.е. - 15 строк по 7 слов.
***
: LINE 1 - 7 * RECORD + ;
***
Here I'm defining a verb that will convert a line number (1-15) to a field address.
It modifies the RECORD descriptor by changing the word specification (low order bits).
Thus line 1 starts in word 0; line 2 in word 7; etc.
***
Глагол, который преобразует номер строки (1-15) в адрес.
Надо модифицировать описатель RECORD при изменении порядка битов в слове.
Т.о. строка 1 начинается со слова 0; 2-ая - со слова 7; и т.д.
***
: T CR LINE ,C ;
***
If I type 3 T - I want line 3 typed.
T does a carriage return (CR), executes LINE to compute the field address, and copies the (character) field into the message buffer (,C).
***
Если я напечатаю 3 T - я выведу 3-ю строку.
T переводит каретку (CR), выполняет LINE, чтобы вычислить адрес, и копирует поле в буфер сообщений (,C).
***
: R LINE =C ;
***
If I type " NEW TEXT" 6 R - I want line 6 to be replaced by the text in quotes.
The leading quote puts a string descriptor on the stack. R then executes LINE, followed by =C to store the quote string in the field.
The block will automatically be re-written, since it was changed.
***
Если я напечатаю " NEW TEXT" 6 R - я заменю 6-ю строку символьным литералом (текстом в кавычках).
Ведущая кавычка помещает описатель строки в стек.
R выполняет LINE, а затем - =C, чтобы сохранить строку в поле.
Блок помечается, как требующий записи.
***
: LIST 15 0 DO 1 + CR DUP LINE ,C DUP ,I CONTINUE ;
***
LIST will list the entire block: 15 42-character lines followed by line numbers.
It sets up a DO-CONTINUE loop with the stack varying from 1 - 15.
Each time through the loop it: does a CR; copies the stack and executes LINE; types the field (,C); copies the stack again and types it as an integer (,I).
***
LIST выведет полный блок: 15 строк по 42 символов, сопровождаемые номерами строк.
Цикл DO-CONTINUE пробегает от 1 до 15.
Каждый раз он делает CR, дублирует переменную цикла и вызывает LINE; печатает поле (,C); снова дублирует переменную цикла и печатает ее как число (,I).
***
: I 1 + DUP 15 DO 1 - DUP LINE DUP 7 + =C CONTINUE R ;
***
If I type " NEW TEXT" 6 I - I want the text inserted after line 6.
"I" must first shift lines 7 - 14 down one position (losing line 15) and then replace line 7.
It adds 1 to the line number, sets up a backwards DO-CONTINUE loop starting at 14, constructs two field descriptors, LINE and LINE+7, and shifts them (,C). When the loop if finished, it does an R.
***
Если я напечатаю " NEW TEXT" 6 I - я вставлю текст, после строки 6.
I должен сначала сдвинуть строки 7-14 вниз на одну позицию (строка 15 пропадет) и затем заменить строку 7.
Сначала добавляет 1 к номеру строки, запускает цикл, от 14 до этой строки, строит два описателя поля LINE и LINE+7, и сдвигает поле (=C).
Когда цикл заканчивается, запускает R.
***
: D 15 SWAP DO 1 + DUP LINE DUP 7 - =C CONTINUE " " 15 R ;
***
If I type 12 D - I want to delete line 12.
D must move lines 13-15 up one position and clear line 15: It sets up a DO-CONTINUE loop from stack+1 to 15.
Each iteration it: constructs fields LINE and LINE-7 and shifts them (=C).
Then it replaces line 15 with spaces.
***
Если я напечатаю 12 D - я удалю строку 12.
D должен переместить строки 13-15 на одну позицию вверх и очистить строку 15: опять цикл - от номера на стеке +1 до 15.
Теперь перенос идет между LINE и LINE-7.
Затем 15-ю строка заменяется пустой.
***
That's it.
With 10 lines of code I can define a text-editor.
It's not the most efficient possible, but it's fast enough and illustrates many points: In dealing with small amounts of text, you needn't be clever; let the machine do the work.
The verb LINE is an extremely useful one; such useful verbs are invariably an empirical discovery.
The verbs ,C and =C are the heart of the method; incidently, they only work on fields less than 64 characters.
Notice how one definition wants to reference another (R used by I and D; LINE used by all).
Notice how I and D are similar yet different.
And notice how a few verbs eliminate a lot of bookkeeping and let you concentrate on the problem and not the details.
***
Итак.
10 строк ввода - и редактор готов.
Может, он и не очень эффективен, но вы можете себе позволить переложить на машину свою работу.
Глагол LINE - чрезвычайно полезный; такие полезные глаголы - обычное эмпирическое открытие.
Глаголы ,C и =C - самые важные, они работают со строками не длиннее 64 символов.
Заметьте, как одно определение ссылается на другое (R используется в I и D; LINE используется всеми).
Заметьте, что I и D в чем-то подобны, но все же различны.
И обратите внимание, как удачные глаголы сократили объем бумажной работы.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\6. PROGRAMS WITH OUTPUT / ПРОГРАММЫ С ВЫВОДОМ
ТЕКСТ
By now I'm sure you're aware that the heart of your program is its control loop.
It not only controls the operation, but also the philosophy and organization of the program.
Let me review its operation: it reads a word, finds it in the dictionary and executes its code; failing that it converts it to a binary number and places it onto the stack; failing that it types an error message.
***
Надеюсь, вы запомнили, что сердце вашей программы - цикл управления.
Он не только управляет, но и определеляет философию построения программы.
Как помните, он читает слово, находит его в словаре и выполняет его код; если не удалось найти, он пытается преобразовать его в число и положить на стек, если и это не удалось, сообщить об ошибке.
***
So far I've ignored that error message; not because it's unimportant or trivial to implement, but because it's part of a diffcult subject - output.
Logically I oughtn't have delayed discussing output this long, for even a control language needs output.
But as usual in this program it is involved with other features that we've only just discussed.
I'll leave it to you to implement those features of the output capabilities I'll present, that your application requires.
***
Пока я не объяснял, как выводится сообщение об ошибке; не потому, что это слишком просто, но потому, что вывод еще не обсуждался.
Конечно, логичнее было бы рассказать о нем уже давно, ведь в нем нуждается даже цикл управления.
Но технической возможности не было, только теперь мы узнали все необходимые детали.
Частности оставляю вашей изобретательности.
***
Most compilers, and therefore most programmers, regard output the inverse of input.
For example, FORTRAN uses the same FORMAT statements for output as for input, thereby suggesting that the two processes are very similar.
But are they?
***
Большинство компиляторов (и поэтому - большинство программистов) расценивают вывод как инверсию ввода.
Например, FORTRAN использует те же самые оператры FORMAT и там, и там.
Так?
***
You conpose input: you select words and combine them into fairly complex phrases; your program spends considerable effort deciphering this input and extracting its meaning.
In reply it will not go through any such elaborate procedure.
You'll see that most of its output consists of the word OK.
You are talking to the computer, but it is hardly talking to you; at best it's grunting.
***
Вы тратите время на сочинение сложного входного текста, программа тратит усилия на его понимание.
Вывод намного проще.
Его основная функциональность заключена в слове OK.
Вы говорите с компьютером, а он в ответ едва похрюкивает.
***
I maintain that the two processes have nothing in common, that the computer does not prepare output in a manner analogous to you preparing input.
In Chapter 8 I'll describe a way your program can compose complex output messages.
Although such a technique might provide a 2-way dialog, it has even less similarity to interpreting input.
***
Я утверждаю, что два этих процесса не имеют ничего общего, что компьютер не сочиняет выходной текст так как вы сочиняете ввод.
В Главе 8 я буду описывать путь, которым ваша программа может составлять сложные сообщения.
Хотя такая техника могла бы поддерживать диалог, она еще меньше похожа на интерпретацию ввода.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\6. PROGRAMS WITH OUTPUT / ПРОГРАММЫ С ВЫВОДОМ\6.1 OUTPUT ROUTINES / ПРОГРАММЫ ВЫВОДА
ТЕКСТ
You will need 3 output subroutines; conceivably you could get by with 2.
 * One to type a number of spaces.
 * One to type a number of characters from a specified location (TYPEN).
 * One to type characters until it encounters a space (TYPEB) and including the space.
This last depends on your dictionary format, for it is used to type entry words.
Of course, these should use the fetch and deposit subroutines you use for input.
***
Вам нужно три подпрограммы вывода, но хватило бы и двух:
 * вывод некоторого числа пробелов;
 * вывод некоторого числа символов (TYPEN);
 * вывод символов до пробела включительно (TYPEB).
Последняя программа зависит от вашего формата словаря, поскольку для их печати, в основном, и предназначается.
Конечно, они должны использовать те слова, которые мы уже определили.
***
Let us use the composition of an error message as an example.
You have just typed an input message, the carriage is positioned at the last character.
First you want a space.
Then use TYPEB to type the current word.
It caused the error and will tell you where it occurred.
You don't need this for an unbuffered device.
Then use TYPEB again to type a word that describes the error.
Avoid long error messages - you're the one who will wait while they're typed.
You can detect a number of errors, so it's worth your while to devise a routine to generate them.
***
Рассмотрим как пример сообщение об ошибке.
Вы только что напечатали входное сообщение, каретка стоит на последнем символе.
Сначала вам надо напечатать пробел.
Затем - TYPEB для печати текущего слова.
Оно вызвало ошибку и вам надо добавить к нему сообщение об этом.
Для устройства без буферизации это проще.
Снова - TYPEB для печати описания ошибки.
Используйте описания покороче.
Т.к. ошибок у вас будет много, удобно будет придумать для сообщения о них отдельное слово.
***
After finding an error, you of course quit doing whatever you were doing.
There is no point in trying to continue when you're standing by ready to correct and start again.
However it is convenient to reset things that you'd probably have to reset anyway.
In particular, set the stacks empty.
This is sometimes unfortunate since the parameter stack might help you locate an error.
But it usually is most convenient.
Don't try to reset the dictionary since you're note what you may want to reset it to.
***
После обнаружения ошибки вы все очищаете и начинаете с начала.
Продолжать дальше смысла не имеет - все равно придется переделывать.
Очистите стеки.
Это иногда неудобно, так как состояние стека могло бы помочь с локализацией ошибки.
Но это удобнее всего остального.
А вот словарь стирать не стоит.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\6. PROGRAMS WITH OUTPUT / ПРОГРАММЫ С ВЫВОДОМ\6.2. ACKNOWLEDGEMENT / ПРИГЛАШЕНИЕ
ТЕКСТ
I mentioned in Chapter 3 that you must write subroutines to send and receive messages.
Now I must expand on exactly how you should use these subroutines.
***
Я упомянул в Главе 3, что вы должны написать подпрограммы, чтобы посылать и получать сообщения.
Теперь я должен подробно остановиться на том, как вы должны использовать эти подпрограммы.
***
Recall that input and output share the same message buffer.
This now causes trouble.
However it considerably simplifies the more powerful message routines of Chapter 7.
On balance the single message buffer seems optimal.
***
Помните, буфер сообщений у нас один: и для ввода, и для вывода?
Теперь это неудобно.
Однако, это значительно упрощает мощные программы вывода сообщений Главы 8.
В итоге, один буфер удобнее.
***
First let me call the subroutine that sends a message SEND.
It sends a single line and should add a carriage return to the line, as well as any other control characters needed, and translate characters as required.
The routine that receives a message is QUERY.
It is a routine, and not a subroutine.
QUERY calls SEND to send a message, and then awaits and processes an input message.
stripping control characters and translating characters as required.
It initializes the input pointer IP and jumps to NEXTW.
Notice that your program can send output via SEND wherever it pleases.
However it can only receive input in conjunction with output, via QUERY.
You have no provision for receiving successive messages without intervening output.
This is exactly the behavior you need, and actually simplifies the coding of message I/O.
***
Подпрограмма посылки сообщения - SEND.
Она посылает одну строку, добавляя в нее все обходимые симолы для перевода строки.
Программа, которая получает сообщения - QUERY.
Это - программа, а не подпрограмма.
QUERY вызывает SEND для посылки сообщения, а затем ждет ввода.
Обрезает символы возврата каретки.
Устанавливает указатель ввода IP и переходит к NEXTW.
Заметьте, что ваша программа может выводить при помощи SEND везде, где вам захочется.
Однако, вводит только в одном месте - QUERY.
Вы не имеете никакой возможности считать сообщение без вывода приглашения.
Это, конечно, именно то, что нам надо.
***
Now let me describe the use of QUERY.
Each input message is terminated with an end-of-message word, a non-printing character surrounded by spaces.
This word has a dictionary entry that types the word OK and jumps to QUERY.
Thus after interpreting each input message, your program types a brief acknowledgement - OK, message received and understood - and awaits further input.
***
Теперь позвольте мне описывать использование QUERY.
Каждое входа сообщение заканчивается словом конца сообщения - непечатным символом, окруженным пробелами.
Это слово имеет статью словаря, которая печатает слово OK и переходит к QUERY.
Т.о. после интерпретации каждого входного сообщения, ваша программа напечатает краткое подтверждение - OK, "получил и понял" - и ждет дальнейшего ввода.
***
Notice that if an input message generates output it destroys itself.
That is, the output is placed in the message buffer irrespective of the input already there.
Thus a word that generates output should be the last word in a message, since succeeding words will not be seen.
In particular, the end-of-message word won't be seen and the reply OK won't be typed.
This is what you want: OK is only typed in lieu of any other output.
***
Заметьте, что, если входное сообщение приводит к выводу, оно уничтожает себя.
Т.к. буфер у нас один.
Поэтому слово, которое требует вывода, должно быть последним словом во входном сообщении, остальные просто не прочитаются.
В частности, не будет прочитано слово конца сообщения, и ответ OK не будет напечатан.
Это - то, что вы хотите: OK нужен только тогда, кода нет другого вывода.
***
OK should appear on the same line as the input message, separated from the last word by a least one space.
QUERY should not acknowledge receipt of a message - as most time-sharing systems do - with a carriage-return.
The only acknowledgement is the OK at completion of interpretation.
Placing OK on the same line helps distinguish output from input and compresses the conversation, especially valuable on a limited-size scope face.
A user must not type input until he receives output.
It's only important to enforce this rule with multi-user programs.
For this see Chapter 7.
***
OK должен появиться в той же строке, где было входное сообщение, отделенный от последнего введенного слова не менее, чем одним пробелом.
QUERY не должен подтверждать прием сообщения переводом каретки, как делает большинство систем.
Единственное подтверждение - OK при завершении интерпретации.
Размещение OK в той же строке разграничивает ввод и вывод, и экономит место.
Пользователь не должен печатать ввод, пока он не получит вывод.
В многопользовательских программах надо это обеспечить.
См. Главу 7.
***
In order to determine whether there is input in the message buffer, establish a field EMPTY.
QUERY should set empty false and each output generating entry should set it true.
Actually output generating verbs have much in common with each other, and each should jump to a routine that does the following:
 * Drop the stack. Each output verb must have an argument. Its last argument can be dropped at this point, and the stack pointer checked against its lower limit.
 * Set EMPTY true.
 * If NEXT contains NEXTW and SCREEN is 0, jump to QUERY. Under these circumstances there is no further input available in the message buffer.
 * Jump to NEXT.
***
Чтобы определить, имеется ли в буфере сообщений ввод, используется переменная EMPTY.
QUERY должно сбросить EMPTY, и каждый вывод должен ее устанавливать.
Фактически, глаголы вывода имеют много общего, и каждый из них заканчивается переходом к программе, которая делает следующее:
 * Удаляет значение со стека. Каждый глагол вывода должен иметь аргумент, который к этому времени уже выведен. Здесь его надо удалить и проверить стек на исчерпание.
 * Устанавливает EMPTY.
 * Если NEXT содержит NEXTW, и SCREEN - 0, переходит к QUERY. Дальнейший ввод если и был, то уже потерян.
 * Переходит к NEXT.
***
Notice that if entries are coming from a definition or from a screen, no conflict can arise with the message buffer.
Only if input is currently being read from the message buffer is there a problem.
***
Заметьте, что, если слова поступают из определения или SCREEN-а, никакого конфликта не возникает.
Только, если слова вводятся из буфера сообщений.
***
However there are 2 places where source of input is changed.
This is in the code for ";" and ";S".
If ";" restores NEXTW to NEXT, it must guarantee that input is available.
That is, jump to QUERY if EMPTY is true and SCREEN is 0.
Likewise, if ";S" restores SCREEN to 0, it should jump to QUERY if EMPTY is true (NEXT is guaranted to be NEXTW.
***
Имеются 2 места, где источник ввода меняется.
Это делается в коде для ";" и ";S".
";" устанавливает NEXT в NEXTW.
";S" сбрасывает SCREEN в 0.
Поэтому мы это и проверяем выше.
***
The logic required is summarized in Fig 6.2 and is the price paid for duplexing the message buffer.
One final complication concerns EMPTY.
If true, it states that input has been destroyed; it does not indicate that output is currently in the message buffer.
Output may have been placed there and already sent.
If the message buffer is empty, type OK before jumping to QUERY.
***
Сложность - плата за общий буфер сообщений.
Еще про EMPTY.
Если она истинна, значит, ввод был разрушен; но это не гарантирует, что в буфере есть выходной текст.
Вывод мог уже быть послан.
Если буфер сообщений пуст, печатаем OK перед переходом к QUERY.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\6. PROGRAMS WITH OUTPUT / ПРОГРАММЫ С ВЫВОДОМ\6.3. CHARACTER STRINGS / СТРОКИ
ТЕКСТ
Everything isn't easy, and this particular feature is my nemesis.
Perhaps a measure of its value is the difficulty of its implementation.
A character string is an awkward entity.
Mostly because there is nowhere to put it.
Numeric literals go on the stack in a most natural fashion.
Character strings won't fit, and that isn't what we want to do with them anyway.
***
Для меня они очень трудны.
Это не числа, которые легко положить на стек.
***
My solution is this.
When you see a character string, leave it alone.
Put on the stack a descriptor giving the address of the first charactere and the number of characters in the string.
Skip over the string.
That is, advance the input pointer to its end.
You can't do it in quite that order, of course, because only by skipping can you discover the number of characters.
***
Мое решение.
Оставьте строку, где нашли.
Положите на стек описатель строки: адрес первого символа и длину строки.
Пропустите строку, передвинув указатель на ее конец.
На самом деле, он передвинется, пока вы будете считать символы.
***
What does a character string look like?
Of all the ways you might choose, one is completely natural:
***
На что похожа строка?
Например, так:
***
"ABCDEF...XYZ"
***
A character string is enclosed in quotes.
It can contain any character except a quote, specifically including spaces.
***
Строка заключена в кавычки.
Внутри может быть что угодно, кроме кавычек.
***
We get in trouble immediately!
How do you recognize a character string?
By the leading quote, for course.
But do you modify your word subroutine to recognize that quote?
If you do so you may never use a leading quote for any other purpose.
Much better that the quote is a word by itself, treated like any other dictionary entry, for it can then be re-defined.
But words are terminated by spaces, and I still resist making quote an exception.
So let's type character strings:
***
Неприятность!
Как вы распознаете строку?
Конечно, по открывающим кавычкам.
То есть вы хотите так переопределить WORD?
Но тогда вы не сможете использовать кавычки для других целей.
Намного лучше, сделать открывающие кавычки отдельным словом.
Но пробел вставлять после него очень не хотелось.
Получилось:
***
" ABCDEF...XYZ"
***
The extra space is annoying, but in Chapter 8 I will tell you how to eliminate it without the objections I just raised.
So a character string is started with a quote-space and terminated by a quote.
***
Лишний пробел раздражает, но в Главе 8, я сообщу вам, как его можно устранить.
Так, что строка будет просто символами в кавычках.
***
Remember that we leave the character string alone, merely remembering where it is.
We are talking about character strings in the input buffer (so far), and we had better use the string before we destroy it with output or additional input.
When it is destroyed depends on many things, so the best rule is to use it immediately.
***
Помните, что мы оставили строку там, где нашли, просто запомнив место.
Т.о. мы должны использовать строку раньше, чем ввод будет уничтожен.
Лучше - немедленно.
***
What can you do with a character string?
I've only found 2 uses.
They are very similar, but part of the frustration of implementing them is to take advantage of the similarity.
You can type a string, or you can move it to a character field.
***
Что мы можем сделать со строкой?
Я нашел им только два применения.
Они похожи, но не совсем.
Вы можете напечатать строку, или вы можете переместить ее в текстовое поле.
***
To type a string is easy.
Define an entry that uses the descriptor on the stack to set parameters for the TYPEN subroutine.
***
Напечатать строку легко.
Определите статью, которая использует описатель на стеке, чтобы установить параметры для подпрограммы TYPEN.
***
To move a string is harder, but still easy.
You have 2 descriptors on the stack: on top a field descriptor; below the string descriptor.
Set the input and output pointers, and do a character move of length the smaller of the 2 field sizes.
Space fill the remainder of the destination field.
Notice that you musn't move more characters than you have, or will fit.
And of course, string descriptors will rarely have the right size.
Truncating a string is not an error condition!
***
Переместить строку труднее, но ненамного.
Вы имеете 2 описателя на стеке: на вершине - описатель поля; ниже - описатель строки.
Установите указатели источника/получателя и пререносите символы до тех пор, пока не исчерпаете меньшей из двух длин.
Остаток поля назначения заполните пробелами.
Не переносите больше символов, чем влезет в поле.
Размеры будут совпадать очень редко.
Усечение строки - это совсем не ошибка!
***
If you can do the above, you can also move one character field to another.
That is, if you make your character string and field descriptors compatible - which adds to the fun.
You might want to prevent moving a field to a string, but than who cares.
***
Научившись перемещать строки в поле, вы сможете также премещать из поля в поле.
Для этого описатели должны быть совместимы.
Если вам нечего делать, можете предотвратить перемещение из поля в строку.
***
The problem is to reconcile all the above requirements.
Not really to produce optimum code, but even to produce code that is remotely acceptable in size, speed, restrictions and correct operation.
***
Проблема состоит в том, чтобы избегнуть противоречий.
Написать не оптимальный код, но просто работающий.
***
We've slid into the subject of field descriptors.
You might want to type a character field, and of course the same code should work as for string descriptors.
***
Т.о. мы дошли до описателей полей.
Они должны быть полностью совместимы со строковыми.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\6. PROGRAMS WITH OUTPUT / ПРОГРАММЫ С ВЫВОДОМ\6.4. FIELD ENTRIES / ПОЛЯ
ТЕКСТ
We've talked about the different kinds of numbers you might want, and the different entries these require.
However, all these entries dealt with computation.
Another kind of entry is useful for more sophisticated output purposes.
I call it a field-entry because its most common use is to define a field in a data record.
***
Мы говорили о разных видах чисел, требующих для обработки разных статей.
Однако, все они имели дело с вычислением.
Другой вид статей полезен для вывода.
Я назвал их полями, т.к. они удобны для определения полей в записях данных.
***
In addition to the descriptor associated with a variable, a field entry needs additional parameters that specify the output format.
It is extremely useful to be able to specify a field width for output once and for all, and then use it automatically on all reports.
Also it is useful to be able to reference the name of the field - which of course is contained in the dictionary entry.
***
В дополнение к описателю, поле нуждается в дополнительных параметрах, которые определяют формат вывода.
Чрезвычайно полезно определить ширину поля раз и навсегда, и затем использовать ее автоматически во всех сообщениях.
Также полезно иметь возможность сослаться на поле имени статьи поля.
***
So a useful convention is that a field entry puts the address of itself - that is the dictionary entry - on the stack.
Recall that a variable entry places the address of the variable on the stack.
If you want the name of the entry, this address tells you where it is.
If you want the format, this address - offset by some constant - tells you where to find it.
And if you want the address of the field, you can get that too - a process that is executed automatically for a variable.
***
Полезно положить, что поле помещает на стек адрес своей словарной статьи.
Вспомните, что переменная клала на стек только адрес поля параметров.
Если вы хотите имя поля - это адрес статьи.
Если вы хотите формат - адрес получается из статьи.
Хотите адрес поля - тоже пожалуйста.
***
These various capabilities require various entries to effect them.
You might define:
 ,NM - type out field name.
 F - extract field width.
 @F - obtain field address.
***
Для этого нужны специальные слова.
Например:
 ,NM - печать имени;
 F - ширина поля;
 @F - адрес поля.
***
Depending (as usual) you might be able to make @F compatible with @.
Or make @ automatically work correctly for field entries.
You may want to distinguish addresses of variables from address of field entries.
This would be analogous to distinguishing different kinds of numbers, and for the same reason - so that the same operations (in this case probably @ and =) will work on all.
Apply the Basic Principle.
***
Можно сделать F@ совместимым с @.
Или сделайте так, чтобы @ работало и для полей.
Вы можете захотеть отличать адреса переменных от адресов полей.
Подобно тому, как мы различаем числа, и по той же причине чтобы операции (те же @ и =) работали правильно.
Примените Основной Принцип.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\7. PROGRAMS THAT SHARE / ОБЩИЕ ПРОГРАММЫ
ТЕКСТ
It is not obvious, but a program orgainzed as we have discussed is ideally suited to handling several users simultaneously.
All of the basic problems of interactive processing have been solved by interacting with one user.
The organization is such that all data is, or can be, stored in the user's dictionary.
To distinguish users merely requires the program recognise the proper dictionary.
***
Это не очевидно, но наша программа организовалась так, что идеально подходит для работы нескольких пользователей одновременно.
Все основные проблемы диалоговой обработки были решены для взаимодействия с одним пользователем.
Все, что принадлежит пользователю может быть занесено в его словарь.
Различение пользователей - различение словарей.
***
Of course the value of multiple users depends upon the application.
There appears to be a correlation between the complexity of an application and the number of potential users.
An application that deserves a problem-oriented-langage my well be of interest to many users on a continuous basis.
***
Конечно, многопользовательность нужна не везде.
Кажется, чем сложнее приложение, тем больше потенциальных пользователей.
Приложение, которое заслуживает проблемно-ориентированного языка будет постоянно востребовано.
***
Moreover, once the basic program is available, it is relatively simple to add other, even unrelated, applications.
The ability to control your vocabulary by reading screens allows a terminal to be used by different people with absolute minimum effort: each can have a personal screen that will load his dictionary with the vocabulary he wants.
***
Перепрофилирование нашей программы на другое приложение тоже труда не составит.
Наша схема экран-словарь позволяет легкую организацию многопользовательской работы.
***
Providing the message traffic from any one terminal is low enough, as is inevitably the case - for we have in effect slowed the computer down to human speed - we can handle a much larger number of terminals than can fit in core, hundreds, by storing inactive users on disk.
***
Т.к. основная работа делается оператором в диалоге, т.е. очень очень медленно, можно без проблем общаться одновременно со многими пользователями, сохраняя данные заснувших на диске.
***
However there is a cost, primarily of assuring that re-entrant programming rules are strictly followed.
The additional code required to switch the computer's attention among users and the additional core required for disk buffers and user dictionaries demand that a single user application by de-bugged first.
And then the capacity of the computer multiplied with a multiple-user control routine as the demand develops.
It is all too easy to get bogged down in the multiple-user controller and never to perfect an application.
Or to perfect a multiple-user control and never to find a demand to justify it.
***
Затраты на поддержку многопользовательской работы все же существуют.
Дополнительный код для переключения, дополнительное место под буфера и словари...- проще сначала отладить в однопользовательском варианте.
И добавить многопользовательский режим при возникновении спроса.
Иначе, программу изначально придется сделать менее симпатичной.
Или наши усилия могут, вообще, никому не понадобиться.
***
Given a successful single-user application, I will show how it can be expanded to many users.
If you plan to take this step, there are certain precautions you should take with your original implementation.
But mind the Basic Principle!
***
Поэтому обсудим расширение работающей однопользовательской программы до многопользовательской.
Вы должны тщательно соблюдать некоторые предосторожности.
Помните Основной Принцип!

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\7. PROGRAMS THAT SHARE / ОБЩИЕ ПРОГРАММЫ\7.1. USER CONTROL / ПОЛЬЗОВАТЕЛЬ
ТЕКСТ
The fact that you have several users creates a new problem.
Of course the computer can only process one user at a time (we assume a single processor).
But when it's finished with one user, it must switch its attention to another.
***
Много пользователей - проблема.
Конечно, одного процессора хватит на много пользователей.
Но нужен какой-то механизм переключения.
***
When is it finished with one user?
Clearly, if a user is awaiting input the computer is finished.
We are talking about keyboard input, which will take many seconds to arrive.
Similarly if the user is sending output, the computer may as well stop.
Output will take several seconds, especially if an acknowledgement from the device is anticipated.
It needn't stop.
While sending one message, it could be composing the next.
But it's much simpler not to attempt such overlap.
If the user is reading disk, the computer can stop.
***
Когда возможно переключение?
Ясно, что тогда, когда пользователь читает вывод и набивает ввод, компьютер отдыхает.
Плюс, паузы на доступ к устройствам ввода-вывода.
При посылке одного сообщения мы можем составлять следующее.
Но намного проще не пытаться оптимизировать.
Чтение диска пользователем - тоже простой компьютера.
***
I want to define a single phrase to cover these situations.
I shall say that a user relinquishes control of the processor whenever he does message or disk I/O.
This is a voluntary action on his part, and those are the only times he relinquishes control.
In particular, there is no time quantum that will take control from him.
For this reason: With several users, code must clearly be re-entrant.
However, if a user is promised that he will be allowed to finish what he starts, if he will not lose control to someone else except when he relinquishes it, the re-entrant requirements become much less onorous.
The program need only be re-entrant across I/O, which can save a lot of bother.
***
Я хочу описать все эти ситуации одной фразой.
Я буду говорить, что пользователь передает управление компьютеру каждый раз, когда он печатает сообщение или обращается к диску.
Это его добровольное действие и единственное время, когда он отказывается от управления.
В частности, не имеется никакого кванта времени, который бы ему выделялся.
По этой причине код должен быть реентерабельным.
Однако пользователь будет уверен, что у него не отберут управление в момент, когда он не успел что-то закончить.
Программа должна только правильно обрабатывать их ввод-вывод.
***
All right, what happens when a user relinquishes control?
The computer simple scans a table of users to see if anyone else is ready.
The table contains the address of the user's dictionary and a flag: ready or not?
The I/O complete interrupt routines simply mark the proper user ready.
And if no one is ready, the computer scans the table endlessly - it's got nothing better to do.
Naturally, upon program start-up, no one is ready.
***
Как же переходит передача управления?
Компьютер просматривает таблицы пользователей в тоисках готового.
Таблица содержит адрес словаря пользователя и флаг готовности.
Прерывание ввод-вывода просто устанавливает этот флаг.
И если никто не готов, компьютер опять посматривает таблицу - больше ему делать нечего.
Естественно, сразу после запуска программы еще никто не готов.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\7. PROGRAMS THAT SHARE / ОБЩИЕ ПРОГРАММЫ\7.1. USER CONTROL / ПОЛЬЗОВАТЕЛЬ\7.1.1. NON-USER ACTIVITIES / ПОМИМО ПОЛЬЗОВАТЕЛЯ
ТЕКСТ
Each user has a position in the ready table to identify his status.
The computer examines this table to decide what to do next.
You may want to add to the ready table entries not associated with users, but representing tasks that must be performed by the computer.
***
Каждый пользователь имеет строку в таблице готовности.
Компьютер проверяет таблицу в поисках готового.
Вы можете добавить в эту таблицу строки для непользовательских процессов.
***
For example, if you have to poll phone lines to acquire input, you want to perform these polls asynchronously with whatever other work you're doing.
Since interrupt routines are best kept small, the task of translating character sets, checking parity, distributing messages, ets. should be performed at lower priority.
This is easy to do with an entry in the ready table. The interrupt routine sets a message routine "ready" and the computer will process it when possible.
***
Например, вы можете опрашивать телефонные линии в поисках сообщений.
Лучше производить все связанные с приемом операции не сразу по прерыванию, а поставить их в очередь.
Т.к. это не очень срочно.
Добавим этот процесс в таблицу.
Когда делать будет нечего, дойдет дело и до него.
***
Each such independent activity should have a ready table entry and a (perhaps) small dictionary in which to store its parameters; return address, register contents, etc. in the same format as a user activity.
In fact these activities are competely equivalent to users, except that they don't process users.
This is significant, for it means they never generate error messages, they must handle their own errors, somehow.
***
Каждый такой процесс должен иметь строку в таблице и маленький словарь, чтобы хранить параметры; адрес возврата, регистры и т.д., в том же самом формате как и пользователь.
Такие процессы - полный аналог процессов пользователя.
Единственное, им некому выдавать сообщения об ошибках и они должны обрабатывать ошибки сами.
***
If you haven't already noticed, we're now talking about operating systems.
I don't have much more to say on the subject, but there are other asynchronous activities you might want:
 * A clock to handle the timer interrupt and maintain a time and date in core and disk. It might ready other activities that relinquished control for a fixed time.
 * A routine to write blocks on disk. Periodically it might scan the block buffers for blocks to copy. (however, writing blocks when the read routine needs a buffer seems simpler.)
***
Итак, начался разговор об операционных системах.
Я не хочу знать ничего асинхронного, за исключением:
 * Работа с прерыванием таймера - установка даты/времени и запуск процессов по будильнику.
 * Сброс измененнных блоков на диск. (Однако, запись блока при освобождении буфера проще.)
***
Such activities cost little, and usually provide the simplest answer to any asynchronous problem.
Mind the Basic Principle, though!
***
Это просто и полезно, и ничего асинхронного более не требуется.
Основной Принцип!

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\7. PROGRAMS THAT SHARE / ОБЩИЕ ПРОГРАММЫ\7.1. USER CONTROL / ПОЛЬЗОВАТЕЛЬ\7.1.2. MESSAGE HANDLING / ОБРАБОТКА СООБЩЕНИЙ
ТЕКСТ
If you can read input from one user, you can read input from many.
You must get an interrupt that tells you input is available and from whom it comes.
You simple direct it to the proper message buffer.
Likewise with output.
***
Если вы умеете читать ввод одного пользователя, вы умеете читать ввод всех.
Вы должны прерваться и определить, кто требует внимания.
Вы просто читаете нужный буфер сообщений.
Аналогично с выводом.
***
It needn't be simple, but it certainly depends on hardware exclusively.
If you have to poll terminals, it can become very interesting, indeed.
But the problem remains beyond the scope of this book.
***
Это может быть сложно и, конечно, зависит от аппаратных средств.
Опрашивать терминалы, конечно, интересно.
Но это не наша проблема.
***
If all your users are not core resident, it is better if none of them are.
Then any input message can be written into the message buffer area on disk.
And all output messages read from disk.
The fact that some users might reside in core, causes an unreasonable complication, and the fact that disk access is fast compared to message transmission means that to attempt to save such disk accesses is not efficient.
***
Очень сложно держать данные части пользователей в ОЗУ, а части - на диске.
Это нарушает единообразие.
Уж лучше держать всех на диске.
Простота окупит неэффективность.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\7. PROGRAMS THAT SHARE / ОБЩИЕ ПРОГРАММЫ\7.2. QUEING / ОЧЕРЕДИ
ТЕКСТ
You can save yourself a lot of trouble by putting some code in the user controller.
Two subroutines: QUE and UNQUE.
When a user needs a facility that might be in use by someone else, he calls QUE.
If it's available, he gets it.
If it's not available, he joins the que of people waiting for it.
When it is released, and his turn, he will get it.
***
Написав простой код диспетчера пользователя, можно избежать многих неприятностей.
Две подпрограммы: QUE и UNQUE.
Когда пользователь жаждет ресурсов, он вызывает QUE.
Если ресурс доступен, он получает доступ.
Если ресурс занят, он ставится в очередь.
Когда подойдет его очередь, он получит доступ.
***
For example, he can't read disk if someone else if reading disk.
Or at least he can't use a particular channel or device.
While he's waiting, of course he relinquishes control.
When he's through with the facility, he calls UNQUE which passes it to someone else.
***
Например, он не может прочесть диск, когда его читает кто-то другой.
Или воспользоваться каким-либо каналом или устройством.
На время ожидания он разумеется теряет управление.
Когда он освобождает ресурс, он вызывает UNQUE.
***
These are extremely valuable routines, for there are many facilities that can be handled in the manner; each disk, each line (shared lines), the printer, block 1 (disk allocation), non-re-entrant routines (SQRT).
An extension will even permit exclusive use of blocks.
***
Это очень удобное средство для управления многими видами ресурсов, к которым нельзя обращаться всем одновременно, вплоть до нереентерабельных подпрограмм (например, SQRT).
Его можно распространить даже на доступ к блокам.
***
Naturally, I have in mind a specific way to implement QUE and UNQUE.
And I caution you, more strongly than usual, that plausible modifications won't work.
I'll try to mention all the reasons.
***
Естественно, я имею в виду определенный способ осущестления QUE и UNQUE.
И я предостерегаю вас, более настоятельно чем обычно, что модификации, вероятно, не будут работать.
Я попробую упомянуть все причины этого.
***
In addition to the user's dictionary address and ready flag, each user must have a link field - not in his dictionary, but in user control.
Each facility that is to be protected must have associated with it 2 fields: the owner, and the first person waiting.
The best arrangement is to have a table of such que-words, one for each facility.
If a facility is free, its owner is 0; otherwise its owner is the number of the user owning it.
A user's number is his position in the table of users, starting at 1.
If no one is waiting, a facility's waiter field is 0; otherwise it is the number of the user waiting.
***
В дополнение к адресу словаря пользователя и флагу готовности, каждый пользователь должен иметь поле связи - не в его словаре, а в таблице.
Каждый защищаемый ресурс, должен иметь два поля - владелец и первый в очереди.
Лучше всего иметь таблицу таких полей - по строке на каждый ресурс.
Если ресурс свободен, его владелец - 0; иначе - номер пользователя, его занимающего.
Номер пользователя - его строка в таблице пользователя, начиная с 1.
Если очереди нет, поле очереди устройства - 0; иначе - номер первого пользователя в очереди.
***
If I want a facility and its free:
 * I place my number in the owner field and exit.
***
Если я хочу ресурс и он свободен:
 * Я помещаю свой номер в поле владельца и выхожу.
***
If it's busy, but no one's waiting:
 * I place my number in the waiter field, 0 my link field, and relinquish control.
***
Если ресурс занят, но очереди нет:
 * Я помещаю свой номер в поле очереди, и 0 в мое поле связи, и выхожу.
***
If someone's waiting:
 * I follow the chain of links starting at the waiter's link field until I find a 0 link; I place my number there, 0 my link field, and relinquish control.
***
Если есть очередь:
 * Я прохожу до конца цепочку, начинающуюся в поле очереди ресурса; помещаю мой номер в найденное нулевое поле связи, 0 - в мое поле связи и выхожу.
***
When I'm through with a facility (UNQUE):
 * IF no one's waiting, I 0 the owner field, and exit.
 * If someone's waiting, I move his number to the owner field, move his link field to the waiter field, mark him ready, and exit.
***
Когда я освобождаю ресурс (UNQUE):
 * Если очереди нет, я помещаю 0 в поле владельца, и выхожу.
 * Если очередь есть, я помещаю его номер в поле владельца, а его поле связи копирую в поле очереди, ставлю ему флаг готовности, и выхожу.
***
The whole procedure is simple and efficient.
It handles a lot of potential problems in a reasonable and effective way.
Several comments: The ques will probably be very short.
In fact, facilities will usually be free, unless the computer is over-loaded.
A user can not be in more than one que. However, a user can own more than one facility.
Hence the need for a waiter field with each facility: a que must descend from each facility, and not from each owner; the two concepts are independent.
You must add to the error routine a loop to release any facilities held by the current user.
Since a user needs to know his own number in order to que, this number must be stored in a field in his dictionary, and be set by the re-initialize routine.
***
Процедура проста и эффективна.
Она разрешает много потенциальных проблем.
Несколько комментариев: Очередь, вероятно, будет очень коротокой.
Если компьютер не перегружен, ресурсы будут обычно свободны.
Пользователь не может стоять больше, чем одной очереди.
Однако, пользователь может владеть более, чем одним ресурсом.
Следовательно, каждому ресурсу нужен свой набор полей.
Вы должны добавить к программе цикл, чтобы освободить все ресурсы, занятые текущим пользователем.
Так как пользователь должен знать свой номер, чтобы обратится к очереди, этот номер должен быть записан в его в его словаре при инициализации.
***
It's complicated, it's troublesome, and it's the price you must pay for multiple users.
***
Это сложно и неприятно, но это плата за многопользовательность.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\7. PROGRAMS THAT SHARE / ОБЩИЕ ПРОГРАММЫ\7.3. PRIVATE DICTIONARIES / ЧАСТНЫЕ СЛОВАРИ
ТЕКСТ
The key to the case of conversion to multiple users is that all required information about a user is stored in his dictionary - a single contiguous area of core.
He makes extensive use of code that belongs to the system, and that does not reside in his dictionary.
On the other hand, code unique to his application may reside there.
Here is the first decision that you must make: What belongs in the user's private dictionary?
***
Ключ к многопользовательности - хранение всей информации пользователя в его словаре - маленьком непрервном фрагменте ОЗУ.
Он активно пользуется кодом, принадлежащем системе и хранимым в другом месте.
Его же уникальный код - при нем.
Что хранить в частном словаре пользователя?
***
Let us look at the arrangement of core.
If we choose, and we should, it follows dictionary format: each entry followed by the code it executes.
Each entry is linked to the previous so that the dictionary may be searched backwards.
Some entries are obviously of interest to all applications: those that control the stack, that define dictionary entries, that specify fields such as BASE, CONTEXT, etc.
Other entries are probably of local concern: the names of fields in records, definitions used to edit text, special purpose code (random number generator, square root, etc.).
At some point you must separate the system and user dictionaries.
***
Обсудим распределение ОЗУ.
Вспомним формат словаря: каждая статья, содержит код для выполнения.
Каждая статья связана с предыдущей, чтобы словарь можно было просмотреть назад.
Некоторые статьи вызываются особенно часто: управления стеком, определяющие слова, содержащие важные переменные - BASE, CONTEXT и т.д.
Другие менее важны: названия полей в отчетах, команды редактора, специализированный код (генератор случайных чисел, нахождение квадратного корня и т.д.).
Где-то надо отделить общее от частного.
***
If you establish several user dictionaries, the first entry in each will link to the system dictionary (Fig 7.1) at the same point.
Thus each user is unaware of any other user, and his dictionary search is unaffected.
***
Если вы создаете несколько пользовательских словарей, первая статья в каждом должна быть связана (через поле связи) с определенной точкой в общем словаре.
Т.о. пользовательские словари друг другу не видны.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\7. PROGRAMS THAT SHARE / ОБЩИЕ ПРОГРАММЫ\7.3. PRIVATE DICTIONARIES / ЧАСТНЫЕ СЛОВАРИ\7.3.1. MEMORY PROTECTION / ЗАЩИТА ПАМЯТИ
ТЕКСТ
If all users will fit in core simultaneously, we are finished.
You divide memory into the appropriate dictionaries.
You should provide memory protection so that one user cannot damage another.
The stack and dictionary size checking discussed earlier, should be augmented by checks on the = operator, so that a user cannot write outside his dictionary, or outside a block he has read.
If you have hardware memory protect, you will find it difficult to take advantage of.
The user must be able to read his dictionary, the system dictionary and the block buffers; he must be able to write his dictionary and the block buffers.
Several users might want to write the same block buffer; if not simultaneously, at least consecutively.
If your hardware can help, it's better than any I've seen.
But software protection can be made adequate - except against malicious mischief.
***
Если все пользователи получат одновременный доступ ко всему ОЗУ, нам конец.
Вы выделяете им память для их словарей.
Вы должны обеспечить защиту памяти одного пользователя от другого.
Проверки размеров стеков и словаря, должны быть снабжены дополнительными проверками на переполнение, чтобы исключить выход пользователя за пределы своего блока памяти.
Аппаратными методами защиты памяти воспользоваться бывает затруднительно.
Пользователь может читать свой словарь, системный словарь и буфера блоков; он может писать в свой словарь и в буфера блоков.
Несколько пользователей могут писать в один буфер блоков; если не одновременно, по крайней мере последовательно.
Если ваши аппаратные средства могут все это реализовать, идеально.
Но можно создать и адекватную программную защиту (если не учитывать злонамеренный взлом).
***
Although a user cannot hurt anyone else, he is certainly capable of destroying himself.
Thus you should have a system entry that will restore his dictionary to empty, with all control fields reset.
Such an entry will get heavy use, for it is a simple way to start over.
***
Хотя пользователь не сможет травмировать кого-либо еще, он может убиться сам.
Т.о. вы должны иметь системную статью, который восстановления пользовательских областей.
И она не будет простаивать.
***
If you have implemented fixed-size entries, you have no links to lead to the system dictionary.
Your search routine must separately search the user's dictionary and the system dictionary, since not all users can be contiguous to the system.
This should only cost a few instructions, but is another reason to prefer the linked entries.
***
Если вы используете словари со статьями фиксированной длины, у вас нет поля связи, и некуда вписать ссылку на системный словарь.
Ваша программа поиска должна отдельно искать в словаре пользователя и в системном словаре.
Это стоит всего несколько лишних инструкций, но это еще одна причина предпочесть связные списки статей.
***
If you have multiple chains in your dictionary, each chain must jump from the user's to the system dictionary.
This is only a problem when re-initializing the dictionary, and can be easily solved by keeping a copy of the chain heads for the system dictionary.
***
Если вы используете в словарях таблицы расстановки, каждый список должен быть продолжен в системном словаре.
Поэтому, для удобства инициализации, удобно хранить где-нибудь таблицу входов в списки системного словаря.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\7. PROGRAMS THAT SHARE / ОБЩИЕ ПРОГРАММЫ\7.3. PRIVATE DICTIONARIES / ЧАСТНЫЕ СЛОВАРИ\7.3.2. CONTROLLED ACCESS / КОНТРОЛЬ ДОСТУПА
ТЕКСТ
It would appear that you want the system dictionary as large as possible to avoid redundancy.
That is not necessarily the case.
There are some entries that might go into the system dictionary - except that you specifically want to deny them to some users.
Prime examples are the GET and DELETE entries that control disk allocation.
Misuse of these words by ignorant users can badly damage data stored on disk.
The best solution is to place the code in the system, without a dictionary entry.
Define a table of entry points into code of this nature.
Then if a user wants to use an entry point, he must first define it, perhaps:
***
Конечно, хотелось бы, чтобы системный словарь не был избыточным.
Кроме того, хочется запретить некоторым пользователям доступ к некоторым системным статьям.
Например, к GET и DELETE, управляющим распределением диска.
Неправильное употребление этих слов неосведомленным пользователем может ужасно повредить данные на диске.
Лучшее решение состоит в том, чтобы разместить системный код вне статей.
И использовать для доступа к нему таблицу.
Тогда, если пользователь захочет использовать такой код, он должен сначала определить точку входа:
***
17 ENTRY GET 18 ENTRY RELEASE
***
establishing the words GET and RELEASE with the code identified in the 17th and 18th table positions. Library subroutines (FORTRAN arithmetic subroutines) might be treated similarly.
***
т.е. определить слова GET и RELEASE, выполняющие код, адресуемый в 17 и 18 строках таблицы.
Подобным образом можно было бы обращаться и с другими библиотеками (например, FORTRAN-овскими).
***
Incidently, this illustrates a general method of protection: In addition to using a word, the user must define it correctly.
Clearly you can cascade the process.
The value of such protection against malicious mischief depends on secrecy, which is always the ultimate protection.
However even in the absence of secrecy, it provides valuable protection against inadvertant damage.
***
Это общий метод защиты: чтобы что-то вызвать, надо его корректно определить.
Вы можете применять несколько уровней подобной защиты.
Против злого умысла - сокрытие документации.
Однако, даже без использования тайных знаний, кое-какя защита от дурака должна присутствовать.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\7. PROGRAMS THAT SHARE / ОБЩИЕ ПРОГРАММЫ\7.4. DISK BUFFERS / ДИСКОВЫЕ БУФЕРА
ТЕКСТ
The fact that you may have several users reading disk simultaneously has no effect at all upon the disk-access subroutine.
It can search the block buffers and find an available buffer without concern as to who asked for it.
Of course you must have at least as many buffers as users.
In fact, all of core not required for dictionaries might as well be devoted to block buffers, as left idle.
However, if a block is being read, you should mark the buffer busy some way, so someone else will not assume it's there before it arrives.
If you attempt to read a busy block, you should relinquish control and try again when you're re-started.
***
То, что несколько пользователей могут читать диск одновременно, не влияет на подпрограмму доступа к диску.
Поиск свободного блока не зависит от того, кто его требует.
Конечно, каждому пользователю надо выделить хотя бы по буферу.
Фактически, все неиспользуемое пространство ОЗУ может быть использовано под буфера.
Однако, если блок кем-то читается, вы должны отметить этот буфер как занятый, чтобы не допустить одновременную запись в него.
Если вы пытаетесь читать занятый блок, вас ставят в очередь.
***
To gain exclusive use of a block, with the exception of block 1, best handled as an exception, set aside some facility que-words for this purpose.
Find a free one and store the block number it represents somewhere, then treat that block like any other facility.
When the last waiter releases the block, release the facility que-word for re-use.
Notice that this technique has no effect upon the block itself.
It may be resident in core, or not.
Anyone may read or write it.
However, no one else may have exclusive use of it.
If all users cooperate to request exclusive use when the should, it works perfectly - with no extra cost to ordinary reads/writes.
Actually, exclusive use of a block is necessary only under exceptional circumstances.
Block 1 is an example of such: The block may not be used by anyone else until another block has been read, and the available space up-dated.
***
Для разграничения доступа к диску, за исключением блока 1, удобнее всего использовать QUE-слова.
Найдите свободный блок и обращайтесь с ним, как с ресурсом.
Когда один освободит, другой сможет использовать.
Это не оказывает никогого ущемления прав работы с блоком.
Он может располагаться где угодно.
Любой может его читать или писать.
Но, никто не владеет им монопольно.
Если все пользователи более-менее сотрудничают, затраты минимальны.
Фактически, исключительное использование блока необходимо только при исключительных обстоятельствах.
Напимер, блок 1: блок не может использоваться кем-либо еще, пока в него не будут прописаны результаты текущей операции по выделению/освобождению блоков.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\7. PROGRAMS THAT SHARE / ОБЩИЕ ПРОГРАММЫ\7.5. USER SWAPPING / ПЕРЕКЛЮЧЕНИЕ ПОЛЬЗОВАТЕЛЕЙ
ТЕКСТ
So far we've had all users resident in core.
This is by far the best arrangement for handling a small number of users.
The step to allowing more users than can be simultaneously resident is a small one philosophically, but can be very difficult to implement.
Suppose we had room for 4 user's dictionaries in core, but we wanted to permit 40 users.
Clearly we can store all 40 user dictionaries on disk and load each one into core when he becomes active.
Providing disk I/O is substantially faster than message I/O there is not even a performance penalty associated.
When a user is awaiting message I/O we write him out to disk.
When he completes his message I/O we read him back into core.
Naturally, we do not move him from core when he is waiting for disk I/O, since it would take unreasonably long to write him out and read him back compared to the original delay.
***
Пока мы обсуждали случай нахождения всех пользовательских данных в ОЗУ.
Это удобно, но работает только пока пользователей мало.
Организовать работу, когда все пользователи в ОЗУ не помещаются - легче сказать, чем сделать.
Предположим, что мы имеем место в ОЗУ для четырех пользователей, но хотим работать с сорока.
Мы можем хранить все сорок пользовательских словарей на диске и загружать в ОЗУ, когда он станет активным.
Все равно, работа с диском идет быстрее, чем цикл пользовательского ввода/вывода.
Пока пользователь читает вывод, мы выгружаем его с диска.
Когда он заканчивает сообщение, мы читаем его назад в ОЗУ.
Естественно, мы не выгружаем его из ядра, когда он ожидает дискового ввода/вывода, т.к. дисковые задержки не так уж велики.
***
So far there are no problems.
The problem arises as to where to read him back into.
We have 4 buffers: if we load users always into the same buffer we have 4 classes of users, each of which can go into a single buffer.
We are begging for delays at one buffer while another is empty.
***
Пока без проблем.
Проблема возникает там, где его надо читать обратно.
Мы имеем 4 буфера: если мы должны загружать пользователя всегда в определенный буфер, мы имеем 4 класса пользователей, каждый из которых может войти только в свой буфер.
В одном будут задержки, а другой будет простаивать.
***
If we are going to the trouble anyway, we should make all buffers equivalent, and load a user into whichever one is free.
However, now a user's dictionary must be relocatable.
That is, any references to his dictionary must be relative to its origin, which is presumably stored in an index register.
This isn't too bad if we've planned from the start - way back with a single-user program - to make all dictionary references relative; it requires almost a complete re-write of the program if we did not, for all dictionary references, and they're scattered all through the program, must be indexed.
***
Надо обеспечить загрузку пользователя в любой свободный буфер.
Значит, пользовательский словарь должен быть перемещаемым.
То есть любые ссылки в нем должны быть относительными - от начала, возможно хранящегося в индексном регистре.
Это не слишком плохо, если мы спланировали все это с самого нашего однопользовательского начала, иначе надо будет полностью переписать программу, либо переиндексировать словари при каждой загрузке.
***
Actually, since any references to a block must be relative to the (variable) origin of the block, we aren't introducing a new problem; merely extending an old one.
However, there's another complication.
We now have a real distinction between our 2 dictionaries: the system dictionary is absolute and the user dictionary is relative.
Therefore the same kind of entry must be treated differently, depending on which dictionary it's in.
***
С относительными ссылками все просто.
Почти.
Мы теперь имеем реальное различие между нашими двумя словарями: системный словарь абсолютен, а пользовательский относителен.
Поэтому надо обращаться с ними по-разному.
***
For example, if we have compiled code in the parameter area, an absolute user dictionary can store the code address in the address field.
However a relative user dictionary must store the address of a routine that will, in turn, jump into the parameter field.
Or else relative addresses must be distinguished from absolute addresses, perhaps by size, and treated properly.
***
Например, если мы компилируем код в поле параметров, абсолютный пользовательский словарь может хранить адрес кода в поле адреса.
Однако, относительный пользовательский словарь должен хранить адрес программы, которая, в свою очередь, перейдет в поле параметра.
Относительные адреса могут отличаться от абсолютных адресов и размером.
***
To avoid impossible difficulties, you should be careful to write your single-user program with the following constraints:
 * Reserve an index register for a user pointer, the origin of the user's dictionary, andd use this index. That is, treat the dictionary as relative, even though you needn't.
 * Make all code re-entrant. At least all code within which a user might relinquish control - which turns out to be most code.
***
Т.е. вы сразу должны писать вашу однопользовательскую программу с учетом на расширение:
 * Зарезервируйте индексный регистр для указания начала словаря и работайте с относительными адресами.
 * Делайте весь код реентерабельным. По крайней мере весь код, который может быть прерван потерей пользователем контроля - т.е. почти весь.
***
Do this if you have the slightest intention of implementing a many-user version.
This violates the Basic Principle, but we're dealing with such basic issues as to be worth it.
***
Сделайте это, если есть хоть малейший намек на будущую многопользовательность.
Это нарушение Основного Принципа, но тут ничего не поделать.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\8. PROGRAMS THAT THINK / ПРОГРАММЫ, КОТОРЫЕ ДУМАЮТ
ТЕКСТ
The mystery of consciousness has intrigued philosophers for a long time.
It now seems apparant that just as life is a result of complex organization, so is consciousness.
It is somehow a byproduct of complex interactions among data.
Interactions so complex they only occur in mammalian brains.
***
Тайна сознания волнует философов с давних пор.
Это теперь кажется очевидным, что жизнь и сознание - результат сложной организации.
Сложные взаимодействия сложных данных.
Настолько сложные, что на них способны только наши мозги.
***
Therefore, one way of investigating the mind is to experiment with manipulating data.
The obvious way to do this is on a computer.
We now have a program with capabilities previously unattainable.
Why not use it in such a way as to probe the realm of 'thinking'?
I don't propose that you become a psychobiologist.
But you can have a lot of fun, and do some really impressive things with simple extensions to your program.
***
Поэтому, один из путей исследования разума состоит в том, чтобы экспериментировать с управлением данными.
А для чего еще нужен компьютер?
У нас теперь есть суперпрограмма.
Почему бы не использовать ее для исследования разума?
Я не предлагаю, чтобы вы занялись психологией.
Но как не позабавиться с вещами, которые нам раньше были недоступны?
***
I will describe a number of entries of unusual capability.
If you have an application that can use them, or if you can create an application to use them, by all means give them a try.
However, the Basic Principle forbids you including them without a purpose.
They are sufficiently elaborate and sufficiently specialized as to never prove unexpectedly valuable.
***
Я буду описывать необычные словарные статьи.
Если у вас есть приложение, в котором они могли бы быть полезными - попробуйте.
Однако, Основной Принцип запрещает вам, реализовывать их просто так, без цели.
Сложность и специализация, это еще не ценность.
***
I have had all the entries I describe in a single program.
This program had less than 1500 instructions so it is practical to include everything in a single program.
But I was experimenting, and never found an application that needed a fraction of them.
***
Я использовал все эти статьи в одной программе.
Эта программа имела меньше чем 1500 инструкций, так что такое было вполне возможно.
Никакого другого применения я им не нашел.

\7.НОВОСТИ\СТАРЫЕ НОВОСТИ\ПОИСК КОДА\МУР О НЕСТАНДАРТНЫХ ПОТОКАХ
\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\8. PROGRAMS THAT THINK / ПРОГРАММЫ, КОТОРЫЕ ДУМАЮТ\8.1. WORD DISSECTION / РАЗБОР СЛОВА
ТЕКСТ
One of the most awkward characteristics of our program is that words must be separated by spaces.
Very often you'd like to suffix punctuation or operator without an intervening space.
And we will soon add abilities that make prefixing desirable, too.
***
Одна из наиболее неуклюжих черт нашей программы - то, что слова должны быть разделены пробелами.
Очень часто хочется добавить суффикс или использовать операторы в роли разделителей.
И мы скоро добавим способности, которые потребуют префиксов.
***
It is not difficult to modify the word subroutine to recognise characters other than space as terminating characters.
But it is impossible to provide satisfying generality.
Inevitably, you complicate the word subroutine unduely by considering innumerable special cases.
And you can waste much ingenuity trying to achieve generality.
For example, there are no simple rules that permit all these to be words:
***
Не трудно изменить WORD, чтобы он распознавал еще что-то, кроме пробела.
Но невозможно распознавать сразу все.
Неизбежна чрезвычайная перегруженность подпрограммы специальными случаями.
И вы будете тратить впустую свою изобретательность, пытаясь достичь общности.
Например, не имеется никаких простых правил, которые могут распознать как отдельные слова:
***
HELLO GOOD-BYE 3.14 I.B.M. -.5 1.E-3
***
Likewise, there are no simple rules that separate these strings into the words intended:
***
Аналогично, не имеется никаких простых правил разбиения следующих строк:
***
-ALPHA 1+ ALPHA+BETA +X**-3 X,Y,Z; X.OR.Y
***
But don't dispair!
There is a general solution that can handle all these cases.
It is expensive in time, perhaps very expensive.
But it solves the problem so thoroughly, while demonstrating that no lesser solution is possible, that I consider it well worth the price.
Besides, the speed of processing text is not a critical factor. We maximize speed precisely so that we can afford extravagances such as this.
***
Не отчаивайтесь!
Имеется общее решение для всех этих случаев.
Оно требует очень больших затрат времени.
Но, зато, это окончательное решение.
Кроме того, скорость обработки текста - не критический фактор.
Мы можем себе это позволить, увеличивая скорость там, где это надо.
***
If you haven't already guessed: We read a word terminated by a space, search the dictionary, convert it to a number.
If it isn't a word by this defintion, we drop the last character and try again.
Eventually we strip off enough characters so that the remainder is a word.
***
Если вы еще не догадались: Мы читаем слово, ограниченное пробелом, ищем в словаре, преобразуем в число.
Если ничего не получилось, обрезаем последний символ и начинаем снова.
В конечном счете, мы обрежем суффикс, оставив только слово.
***
Let me review the cost.
We do as many dictionary searches (plus numeric conversions) as there are letters to be dropped.
This encourages fast searches and quick recognition of non-numbers.
It also encourages minimizing the length of strings that must be dissected.
But let's be practical: The number of occassions when dissection is convenient are few enough that you can afford the price.
With the exception of compiler source code.
But I'm not writing a compiler, and if you are you can probably make your word subroutine cope.
***
Оценим стоимость.
Мы делаем столько попыток распознавания, сколько букв нужно отбросить.
Это требует ускорить поиск слова и конвертирование чисел.
Это также поощряет сократить число отбрасываемых чисел.
Будем практичными: это небольшая плата.
За исключением процесса компилирования.
Но я не пишу компилятор, а, если вы пишите, вы сделаете по-другому.
***
There are several things to be careful of: As you drop characters from the aligned word, you must keep track of your current position within this word.
However, you must also back-up the input pointer so that you can start the next word correctly.
Incidently this requires an initial back-up over the terminal space that is not repeated.
***
Имеются несколько трудностей: вы должны возвращать обрезаемые литеры обратно в вводимое сообщение.
Требуется осторожность в работе с указателями.
***
Backing the input pointer is not possible with unbuffered input.
This is why I suggested that you buffer un-buffered devices back in Chapter 3.
If you aren't going to dissect, apply the Basic Principle.
***
Поддержка указателя входа невозможна при небуферизированном вводе.
Это то, почему я ратовал за буферизацию в Главе 3.
Иначе, примените Основной Принцип!
***
You must also have a way to detect that you have dropped the last character: a counter is one solution.
Another is to place a space immediately ahead of your aligned word, and to stop on the space.
I prefer the second, for I find I lack a convenient counter that is preserved over dictionary search and numeric conversion.
But this means that I must fetch each character before I deposit a space over it.
And this means that my fetch subroutine must operate backwards, the only place I ever need to fetch backwards.
It depends on your hardware.
***
Вы должны также иметь способ обнаружить, что слово исчерпалось: например, используя счетчик.
Или - иметь пробел и перед словом, и останавливаться на нем.
Я предпочитаю второй способ, поскольку регистров под счетик не хватает.
Это означает лишнюю проверку и лишние перемещения по буферу.
Все зависит от аппаратных возможностей.
***
There are 2 things we can do to refine this dissection.
They are incompatible and the choice depends on your application: We don't need to drop characters one-at-a-time.
If you have several letters in succession, or several digits, or perhaps a combination, you might drop the all and then perform a single search/conversion.
This means that you must examine each character (which suggests the second termination above).
It also means that you must be able to distinguish alphanumerics from special-characters.
This requires a 64-character table of character type tailored to your particular character set and application.
If your hardware permits, you may be able to use a 64-bit table - classic trade-off of time vs. space.
***
Имеются два способа что-то улучшить.
Они несовместимы, и выбор зависит от вашего приложения: Мы не должны отбрасывать символы "по одному".
Если в слове подряд несколько букв, или несколько цифр, или их комбинация, вы могли бы выкинуть их разом.
Т.о. вы в качестве разделителей хотите видеть спецсимволы.
Значаит, вы должны быть способны отличить обычный символ от необычного.
Это требует таблицы в 64 ячеек - определителя необычности для всех 64 литер.
Если аппаратура позволяет, используйте таблицу в 64 бита.
***
However, this means you cannot dissect letter strings and you might want to.
Plurals, for instance, can be easily accomodated by dropping the terminal 's'.
On the other hand, you can easily mis-identify words by dissecting letter strings: I once dissected the word SWAP: S was defined, W was defined and my error message was AP ?
Perhaps when dropping a single letter you should replace it with a dash to indicate a word stem.
Or perhaps it doesn't matter if unidentifiable words are mis-identified.
***
Однако, это означает, что вы не сможете рассекать буквенные последовательности.
Например отрезать букву "s" от слова в множественном числе.
С другой стороны, рассечение между букв чревато ошибками: я рассек SWAP - распознались S и W, а AP вызвало ошибку.
Возможно, имеет смысл приучить себя отделять суффиксы дефисами.
Впрочем, в этом случае, как распознать сами суффиксы?
***
One further caution: If you are going to dissect, you must not discard extra characters while initially aligning the word.
Your input pointer must be positioned so that you can backspace it correctly.
If you exceed maximum word size, stop immediately and supply a terminal space.
This means that no single word can exceed maximum size, which has now become maximum string size.
***
Если вы отбрасываете литеры, вы не должны их потерять.
Указатель ввода вам в помощь.
Заметьте, что распознавать что-то длиннее максимальной длины слова бесполезно.
***
Another optimization has to do with the size of words in the dictionary.
If you only match part of the word, you may as well start dropping characters at that point, if number format permits.
***
Другая оптимизация имеет отношение к размеру слов в словаре.
Если вы храните слово порциями, то отбрасывайте этими порциями.
***
What does word dissection mean to a program?
How does it help it 'think'? It means that your program can read your mind.
It means that no matter how you type something, the computer will extract the meaning you intended.
It will use the meaning of the longest character string it can, consistant with a left-to-right scan.
It's not infallible: if you define +1 and then type +1000 it will mis-understand.
But if you use your language consistantly, it will follow.
***
Что дает подобное распознавание слов программе?
Как это помогает думать?
Ваша программа учится понимать не то, что вы пишете, а то, что вы думаете.
Это срабатывает не всегда, но если придерживаться некой системы, то более или менее.
***
I would like to be able to say that this ability will impress people.
It will impress you - at least it should.
But ordinary people, like your boss, expect this kind of ability from computers.
They are only impressed, negatively, if they discover its absence.
***
Я хотел бы сказать, что эта способность впечатлит людей.
Это впечатлит вас, по крайней мере, должно.
Но обычные люди, подобно вашему боссу, ожидают что компьютер это и так умеет.
Они, скорее, обидятся, если ваша программа этого не сможет.

\7.НОВОСТИ\СТАРЫЕ НОВОСТИ\ИНФИКСНАЯ ЗАПИСЬ ФОРМУЛ\ОКАЗАЛОСЬ, ЧТО ОБ ЭТОМ ПИСАЛ ЕЩЕ МУР
\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\8. PROGRAMS THAT THINK / ПРОГРАММЫ, КОТОРЫЕ ДУМАЮТ\8.2. LEVEL DEFINITIONS / ОПРЕДЕЛЕНИЯ ПРИОРИТЕТА
\7.НОВОСТИ\СТАРЫЕ НОВОСТИ\СТЕК\ОСОБЫЙ СТЕК - СТЕК ПРИОРИТЕТОВ
ТЕКСТ
I am embarrassed not to know the standard terminology for what I am going to discuss.
I have never heard it discussed and I have never searched for it.
But it must be a standard aspect of compiler writing - discussed in courses dealing with compilers.
If you know the terminology, you also know most of what I'm going to say: although I hope I can get you to stretch its application.
***
К сожалению, я не знаю терминологии того, что обсуждаю.
Я никогда не встречал подобных обсуждений.
Но, при разработке компиляторов этот вопрос должен был бы возникать.
Если вы знаете терминологию, вы меня поймете.
***
Our arithmetic operators have found their arguments already on the stack.
Conventional algebraic notation uses such operators as infixes, and a left-right scan provides only 1 operand when the operator is discovered.
Consequently the operation must be deferred until the other operand is available.
***
Наши арифметические операторы ожидали, что их аргументы уже лежат на стеке.
Обычная алгебраическая нотация - инфиксная.
Следовательно, действие должно быть отсрочено, пока другой операнд не считается.
***
Moreover, we have a hierarchy of operations than control when that other operator becomes available.
For example:
***
Кроме того, мы имеем приоритет операторов.
Например:
***
A+B*C
***
the multiply must be done before the add. Moreover, parentheses are used to modify the standard heirarchy:
***
Умножение должно быть выполнено перед сложением.
Кроме того, чтобы изменить порядок вычислений, используются круглые скобки:
***
A*(B+C)
***
Such a notation is competely equivalent to ours.
It offers no advantages over the operands-preceeding-operator and has some
limitations. But people are accustomed to it and negatively-impressed by its absence.
So I will show you how to provide the capability.
***
Такая нотация, в целом, эквивалентна нашей.
Она ничем не лучше и имеет некоторые ограничения.
Но люди к ней привыкли.
Так что я покажу вам, как ее обеспечить.
***
However there is no reason to restrict our attention to the customary arithmetic and/or logical operators.
I will show you some other similar heirarchies.
The capability I describe will handle them all.
***
Однако нет никакой причины ограничиваться только общепринятым арифметическим и/или логическими операторами.
Я покажу вам как писать такую нотацию для любых операторов.
***
Let us establish a new kind of dictionary entry.
It is identical to a definition except that it has a number appended, a level number.
So let's call it a level-definition.
The rule is that a level-definition is not to be executed when it is encountered, but rather placed on a push-down stack.
It will be executed when another definition with a equal or smaller level number is encountered.
***
Введем новый тип словарных статей.
Работают как определение, только добавляют к нему число - приоритет.
Так что назовем их определениями приоритета.
Принцип в том, что определенные слова будут не столько выполняться, сколько сохранятся на стеке в ожидании понижения приоритета.
А уж тогда - выполняется весь фрагмент до того места, где приоритет так же низок.
***
A convenient format for level-definitions is:
***
Формат для определения приоритета:
***
2 :L word ... ;
***
The 2 is the level number, taken from the stack.
:L declares the next word as a level-definition.
';' marks the end.
Let's talk about + and *:
***
Здесь 2 это номер приоритета.
:L объявляет следующее слово как определение приоритета.
';' отмечает конец.
Вот сложение и умножение:
***
0 :L , ;
 1 :L + + ;
 2 :L * * ;
***
We have re-defined them in terms of their old definitions, but as level-definitions.
We defined ',' to have some way to stop.
Now we can say:
***
Мы переопределили обычные опрераторы в приоритетные.
Будем считать, что "," заканчивает действие наших соглашений.
Теперь мы можем написать:
***
3 + 4 * 5 ,
***
What happened?
3 goes onto the parameter stack, + goes onto the level-stack, 4 onto the parameter stack, * onto the level-stack (since it has a higher level number than the + already there), 5 onto the parameter stack.
Now ',' forces the * to be executed (since its level number is smaller) and * finds 5 and 4 on the parameter stack.
',' also forces + to be executed (with arguments 20 and 3) and then, because its level number is 0, is itself executed and does nothing.
***
Как это работает?
3 идет на стек параметров, + идет на стек приоритетов, 4 - на стек параметров, * - на стек приоритетов (т.к. его приоритет выше), 5 - на стек параметра.
Теперь "," вынуждает * выполнится (приоритет "," ниже) и * находит 5 и 4 на стеке параметров.
"," также вынуждает + выполнится (с аргументами 20 и 3) и затем выполняется сам и не делает ничего.
***
Clear?
I would like to assume you're familiar with this technique, but I don't quite dare.
All I'm really contributing is a way to implement with dictionary entries a technique usually built into compilers.
Perhaps the cop-out of suggesting you define the arithmetic operators and work out some examples for yourself.
Remember that equal level operators force each other out, and that a lower level operator forces out a higher.
It is strangely easy to reason out the relative levels of operators incorrectly.
***
Ясно?
Возможно, вы знакомы с такой техникой.
Все, чем я жертвую - место под статьи с кодом, который присутствует в обычных компиляторах.
Возможно вам такой подход покажется полезным.
Помните что приоритетные операторы порождают выполнение друг друга, низкоуровневые - провоцируют высокоуровневые.
Приоритеты операторов очевидны.
***
What do we have so far?
Why should you be interested in level-definitions?
You've seen a couple, their definitions are simple.
Level-definitions tend to be simple compared to ordinary definitions.
But given level-definitions you can write a compiler, for any language!
Level-definitions are necessary and sufficient to implement any context-free grammer, not only the LR-1 grammers at the base of contemporary languages.
Frankly I don't know what to do with the power they provide, but I'll toss out some suggestions later.
***
Что мы имеем?
Зачем нам нужны определения приоритета?
Вы видели простые определения.
Но они позволят вам написать компилятор для любого языка!
Определения приоритета могут работать с любой контекстно свободной грамматикой, не только LR-1, лежащей в основе современных языков.
Я сам не знаю, как распорядиться этой мощью.
***
Now back to work.
You've seen some level definitions.
I hope you've played with them some.
How do we implement them?
Well we don't.
Rather we implement a generalization: level-entries.
When I found an application for level-entries I also found out it was cheaper to implement level-definitions as such than the way I was doing.
***
Теперь назад.
Вы видели некоторые определения приоритета.
Я надеюсь, что вы поиграли с некоторыми из них.
Как мы их создаем?
Плохо.
Мы реализовали общее определение для определений приоритета.
Когда я нашел применение для определений приоритета, я также понял, что их можно было сделать лучше.
***
Every dictionary entry may be considered a virtual-computer instruction, as discussed in Chapter 5.
We consider a level-entry an instruction whose execution can be delayed - after the fashion of a level definition.
Why not?
A definition is, after all, only a particular sort of instruction.
If it may be profitably delayed, so might other instructions.
***
Каждая статья словаря рассматриваться как инструкция виртуального компьютера, как было обсуждено в Главе 5.
Мы рассматриваем приоритетную статью, как инструкцию, которая может быть отсрочена.
Почему нет?
Определение, в конце концов, только специфический вид инструкции.
Если оно может быть с пользой отсрочено, то и другие инструкции - также.
***
I'm sorry if it seems complicated.
It is!
It's going to get more complicated - you aren't getting something for nothing.
But it's worth it.
However, notice that everything we're doing now builds on everything we've done before.
Notice that the concept of a special sort of entry depends on having a dictionary available; and the extension of definitions to include level numbers depends on having definitions.
We are gradually building a tree and are in the higher branches.
We might not depend on all the lower branches, but we have to have some.
***
Мне жаль, если это кажется сложным.
Это так!
Будет и сложнее - но оно того стоит.
Однако, мы просто развиваем наши идеи.
***
How do you execute a level-entry?
Exactly the same as any other.
However, the first thing the level-entry does is execute the LEVEL routine, to give it a name, with its level number as parameter.
LEVEL tests this level number against the level-stack.
3 cases arise:
 * It may place the level number and entry on the level-stack (higher level entry) and RETURN.
 * It may replace the top of the level-stack with this entry, and execute the old top.
 * If the level-stack is empty, and the level is 0, it will execute this entry.
 All 3 cases are required!
***
Как вы выполняете приоритетное слово?
Точно так же, как любой другой.
Однако, первая вещь, которую оно делает - исполняет программы LEVEL, получающую параметр - приоритет.
LEVEL сравнивает это число с числом на стеке приоритетов.
3 случая:
 * разместить на стеке приоритетов приоритет (более высокий) и адрес статьи, RETURN.
 * заменить адрес на вершине стека приоритетов на свой, и выполнить старый адрес.
 * если стек приоритетов пуст, и приоритет - 0, выполнить свой адрес.
 Четвертого не дано!
***
Before actually executing an entry from the stack, LEVEL must set the SOURCE address to reference another routine, FORCE.
You recall that your main control loop obtains its next entry either by reading a word and searching, or by fetching from a definition.
Well here is a third source, the level-stack.
As for a definition, the old value of SOURCE and the virtual-IC must be saved - on the return-stack.
***
Перед тем, как выполнить адрес со стека, LEVEL должен установить SOURCE адрес на программу FORCE.
Вы помните, что цикл управления берет слова либо из ввода, либо из определения.
Теперь у нас третий источник - стек приоритетов.
Значит, SOURCE и виртуальный IC должны быть сохранены на стеке возвратов.
***
When you finally force execution of a level-entry, you must remember that it has already been executed, and immediately jump to LEVEL.
This re-execution must start at a different place, 1 or 2 instructions below the routine address, perhaps.
Or you might include the re-start address as a parameter, and keep it in the level-stack.
***
Когда вы запускаете приоритетную статью, вы должны помнить, что это она уже выполнялась - выполнив LEVEL.
Это новое выполнение должно начаться с другого места - на одну-две инструкции дальше начального адреса.
Или вы могли бы держать на стеке приоритетов адрес повторного запуска.
***
When a level-entry is done, it will RETURN and your control loop will go to FORCE.
The only way you can get to FORCE is by completing a level-entry.
Its function is to check the level stack and see if any other entry can be forced off by the one on top.
3 cases arise:
 * It may leave the level-stack alone (higher level on top), and restore SOURCE and virtual-IC from return-stack, and RETURN.
 * It may execute the lower entry, replacing it with the top - thus dropping the level-stack.
 * If there is no lower entry, and the level is 0, it will execute the top entry - thus emptying the level-stack. At this time it will restore from the return-stack.
***
Когда приоритетная статья отработает, выполнится RETURN, и цикл управления перейдет к FORCE.
FORCE должно заканчивать выполнение приоритетной статьи.
Его функция - проверить, нельзя ли выполнить еще что-либо со стека приоритетов.
3 случая:
 * Оставить стек, как есть, и восстановить SOURCE и виртуальный IC со стека возвратов, RETURN.
 * Выполнить и удалить адрес под вершиной стека приоритетов.
 * Если в стеке нет адресов, кроме этого и приоритет - 0, это выполнить последний адрес, очищая стек приоритетов. Восстановить стек возвратов.
***
Let me emphasize the importance of the return-stack, and the necessity of saving SOURCE.
If a level-entry is in fact a definition, SOURCE will be reset yet again.
It may be some time before we return and encounter FORCE once again.
For in fact, a level-definition may occur within a definition; and it may execute other definitions - indeed, other level definitions.
The whole process may become incomprehensibly enmeshed, and indeed it does in practice.
But it will sort itself out.
The beauty of definitions, level-definitions particularly, is similar to that of recursive functions.
You need consider only the simple case when making the definition; complex cases take care of themselves.
***
Позвольте мне подчеркнуть важность стека возвратов и сохранения SOURCE.
Если приоритетная статья  - фактически определение, SOURCE будет переустановлен.
Пройдет немного времени и мы снова будем должны перейти к FORCE.
Возможно, мы будем использовать определения уровня внутри определений или исполнять другие определения.
Вложений может быть много.
Но, благодаря сохранениям на стеке возвратов, все они разрешаются.
Вы должны рассмотреть только простой случай при создании определения; сложные случаи получаются автоматически.
***
Now you should be able to implement level-entries, definitions among them. What can you do with them?
 * You can define the customary arithmetic operations: + - * / MOD **.
 * You can define the customary logical operations: OR AND NOT IMPL.
 * You can define infix relations: = &lt; &gt; &lt;= &gt;= /=.
 * You can define an infix replacement: = := (one that works in either direction).
 * You can define all the above.
***
Теперь Вы должны уметь создавать приоритетные статьи.
Что с ними делать?
 * Вы можете определять общепринятые арифметические действия: + - * / MOD **.
 * Вы можете определять общепринятые логические действия: OR AND NOT IMPL.
 * Вы можете определять общепринятые отношения: = &lt; &gt; &lt;= &gt;= /=.
 * Вы можете определять общепринятое присваивание: = :=.
 * Вы можете определять все перечисленное.
***
It depends on your application.
 * You can define words like PLUS MINUS TIMES DIVIDED-BY EQUALS; an English language arithmetic.
 * You can define phrases like MOVE .. TO .. or DIVIDE .. INTO .. or ADD .. TO .. A COBOL language arithmetic.
***
В зависимости от от того, что требуется.
 * Вы можете определить арифметику по-английски:  PLUS MINUS TIMES DIVIDED-BY EQUALS.
 * Вы можете определять арифметику по-COBOL-ски: MOVE .. TO .. или DIVIDE .. INTO .. или ADD .. TO .. .
***
But let me mention 2 particular uses:
***
Два специфических использования.
***
Consider a statement with the form
***
Запись условного оператора в виде
***
IF relation THEN statement ELSE statement ;
***
Define IF so it will be forced out by THEN and generate a conditional branch.
Define THEN so it will be forced out by ELSE and fix-up the adddress left dangling by IF.
Define ELSE so it will first generate an unconditional branch, then force out THEN, and then await being forced out itself.
Define ; to force out ELSE and fix-up the forward branch.
***
IF будет компилировать условный переходд и запускаться THEN.
THEN будет разрешать переход от IF и запускаться ELSE.
ELSE будет компилировать безусловный переход, разрешать переход от THEN и запускаться ";".
";" будет разрешать переход от ELSE и запускать его.
***
With a few statements you can implement any such compiler construct.
***
И готов компилятор!
***
Consider a statement like
***
Или так:
***
1800. FT / SEC ** 2
***
Define a kind of entry UNIT that puts a constant on the stack immediately and acts like a multiply when it's forced to.
Define / to put a 1. on the stack immediately and divide when it's forced to.
Define ** as an infix, and FT and SEC as UNITs.
This expression and any others you construct will be evaluated correctly.
***
Такая, вот разновидность UNIT.
***
I pass the ball to you.
If you have an application that could profit from a natural language input format, you have the capability with level definitions to implement it.
For example, it would not be hard to teach your program to solve the problems at the end of a high-school physics text.
***
Теперь ваша очередь.
Прдложенного достаточно, чтобы, например, построить решатель школьных задач по физике.
***
Keep in mind, that level-entries do not enhance the power of the computer.
They merely let you specify instructons in what, to the computer, is an unnatural order.
You are well advised to get your application working, and then to append a fancy control language.
How does this relate to a program 'thinking'?
Solely by deferring to the human-oriented format of control languages.
Not even this is impressive to anyone but us!
And even how impressed are you by FORTRAN's expression evaluator any longer?
***
Имейте в виду, что определения приоритета не увеличивают мощность компьютера.
Они просто позволяют вам изменять порядок вычисления.
Т.е. вы можете разнообразить свой язык управления.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\8. PROGRAMS THAT THINK / ПРОГРАММЫ, КОТОРЫЕ ДУМАЮТ\8.3. INFINITE DICTIONARY / БЕСКОНЕЧНЫЙ СЛОВАРЬ
\7.НОВОСТИ\СТАРЫЕ НОВОСТИ\БЛОКОВАЯ ПАМЯТЬ\БЛОКИ ПО МУРУ
\7.НОВОСТИ\СТАРЫЕ НОВОСТИ\ПОИСК КОДА\МУР О ПОИСКЕ НА ДИСКЕ
ТЕКСТ
I would guess that your dictionary will average several hundred entries.
Even a small amount of data seems to generate a large number of fields - to mention one source.
However some applications need much larger vocabularies.
Perhaps you need to identify one of 10,000 customers; or maybe you want the symbols for 104 elements available; or the names of 1000 approved additives.
***
Я предполагаю, что ваш словарь составит в среднем несколько сотен статей.
Даже простые данные могут порождать значительно количество слов, для обозначения, например, полей.
Однако некоторые приложения требуют значительно больших словарей.
Допустим, вы должны идентифицировать одного из 10000 клиентов; или возможно вы хотите символы для 104 элементов; или названия 1000 одобренных пищевых добавок.
***
Clearly such volume must be stored on disk.
Also clearly, you don't want to have to search disk explicitely.
There is a gratifyingly effective solution: If you can't find the word in the core dictionary, and it's not a number, search a block on disk.
Now the question reduces to: Which block?
***
Ясно, такое надо хранить на диске.
Также ясно, что искать что-то полным перебором на диске бессмысленно.
Решение: Если вы не находите слово в основном словаре, и это - не число, то ищем блок на диске.
Теперь проблема сокращается до: Который блок?
***
Establish a field called CONTEXT.
Treat it like you did a block address: it both identifies a block and suggests where it might be in core.
Search this block.
By changing CONTEXT you can search different disk dictionaries.
By linking several blocks together, you can search larger amounts of disk; or search several dictionaries in sequence.
***
Введем переменную CONTEXT.
Работает как адрес блока: оба идентифицируют блок и его предполагаемое место в ОЗУ.
Изменяя CONTEXT, вы можете искать в различных словарях.
Связывая несколько блоков вместе, вы можете искать на большом фрагменте диска; или в нескольких словарях подряд.
***
You can afford to search a fair amount of disk, because if you can't find the word you're going to generate an error message.
A delay in typing that message to make sure you can't find the word, is an excellent investment.
Still for really large vocabularies - thousands of entries - such an approach is inadequate.
***
Вы можете позволить себе искать на изрядном куске диска, потому что, если вы не найдете слово, то это будет ошибка.
Задержка печати сообщения об ошибке дает вам паузу.
Но для тысяч статей такой подход неадекватен.
***
For very large dictionaries, scramble the word into a block address and search that block.
By that I mean compute a block address from the letters in a word, just as we did for multiple chains in the core dictionary, though you'll probably want a different algorithm.
You can search one of a thousand blocks and be assured that if the word is anywhere, it's in that block.
Because you used the same scramble technique to put it there as you use to find it.
Since many words will scramble into the same block, you of course search for an exact match.
Again, just as in core.
With such a large disk dictionary, you want to be careful of several things.
First, once you choose a scrambling algorithm you can never change it; so make a good choice before you define lots of entries.
Second, try to keep the number of entries roughly the same in all blocks; and roughly equal to half the capacity of a block - to compensate for the first "roughly".
Or else provide for overflow by linking blocks together.
***
Для очень больших словарей используйте хэш-функцию, ассоциирующую со словом адрес блока.
Как для поиска в словаре.
Вы можете быть уверены, что если слово есть, оно в этом блоке.
Поскольку помещали вы его по тому же алгоритму.
В блок заведомо влезут все слова с одинаковым значением хэш-функции.
Снова, также, как в ОЗУ.
С таким большим словарем диска, вы должны быть осторожными в нескольких вещах.
Вам нужна быстрая хэш-функция.
Попытайтесь придумать алгоритм, держащий все блоки одинаково наполовину пустыми.
Иначе есть возможность переполнения и блоки придется связывать.
***
Such a disk dictionary can be really impressive - even to non-computer folk - because you have fast access to a prodigous vocabulary.
Fast means you can search tens-of-thousands of entries in a single disk access.
***
Такой дисковый словарь может быть действительно внушителен - даже для некомпьютерщика - потому, что вы можете обеспечить быстрый доступ.
До десятков тысяч статей.
***
What do disk dictionary entries look like?
I have found that 2 fields are sufficient: the word field, the same size as the core dictionary word field; and a parameter field, 1 word long.
If you find a match on disk, you put the parameter on the stack.
Remember that you can't afford to store absolute addresses on disk, so you can't have an address field as in core.
You could provide a coded address field, but it seems adequate to treat disk entries as constants.
***
Что напоминают статьи дискового словаря?
Я нашел, что достаточно двух полей: поле слова, такая же, как в обычном словаря; и поле параметров, 1 слово.
Если вы находите слово на диске, вы помещаете параметр в стек.
Помните, что вы не можете позволять себе хранить абсолютные адреса на диске, так что вы не можете иметь поле адреса, как в ОЗУ.
Вы могли перерасчитывать адрес, но лучше иметь дело с константами.
***
For instance you can name blocks.
When you type the name of a block its address is moved from the parameter field onto the stack.
That is an excellent place for it, because if you type the block number itself that's where it would be placed.
You can use block numbers and block names interchangeably.
Thus when you type an account number the block associated with that account is placed onto the stack, whereupon you store it into the base word that its fields reference.
An illegal account will cause an error message, in the ordinary way.
Or you might name the instructions for your computer.
Then typing its name will place a 1-word instruction on the stack, ready for further processing.
***
Например, вы можете поименовать блоки.
Когда вы напечатаете имя блока, его адрес перемещается из поля параметров на стек.
По идее, этого бы и ждете.
Вы можете использовать номера блока и их имена попеременно.
Или вы могли бы поименовать инструкции вашего компьютера.
***
Although I spoke of account numbers, notice that you can't number blocks.
That is, the name of a disk dictionary entry cannot be a number.
For if you type a number it will be converted onto the stack, and never sought on disk.
And you must attempt to convert before searching disk or you'll search disk for every literal you type.
But then "numbers" often don't look much like the numbers defined by NUMBER.
They tend to have embedded dashes, letters and such; or else you can prefix a letter or suffix a # character.
***
Заметьте, что вы не можете именовать блоки их номерами.
То есть имя статьи дискового словаря не может быть числом.
Потому, что поиск на диске происходит только, если слово не удалось распознать как число.
Или искать на диске все литералы?
Можно использовать числа с каким-либо довеском, который не пройдет в NUMBER.
Например, с суффиксом #.
***
How do you put an entry on disk?
A special defining entry:
***
Как создать статью на диске?
Специальное определение:
***
0 NAME ZERO
***
analogous to CONSTANT.
Alternatively you might set a flag and let the dictionary entry subroutine decide whether to use disk or core.
This latter is preferable if you have several dfferent kinds of entries that might go either to disk or core.
You will also need a way to forget disk entries:
***
аналогичное CONSTANT.
Альтернативно вы могли бы устанавливать флаг и позволять подпрограмме ENTRY решать, использовать ли диск или ОЗУ.
Это удобно, если хотите хранить на диске разные виды слов.
Вам также нужен способ забыть статью на диске:
***
FORGET ZERO
***
FORGET must call WORD as defining entries do, since this is a non-typical use of the word ZERO.
When it finds the entry, it simple clears it without trying to pack.
Your entry routine should first search disk to see if the word is already there.
You don't want multiple definitions on disk, even though there're useful in core.
Then it should search for a hole.
If it finds the word already there, or if it can't find a hole?
You guessed it, an error message.
***
FORGET вызывает WORD для чтения слова, которое нужно удалить, так, что это не типичный вызов ZERO.
Статья просто удаляется, без всякой упаковки.
Когда Вы будете создавать статью на диске, вы сначала ищете это слово на диске.
Многократные переопределения полезны в обычном словаре, но не на диске, там их нет.
Потом вы ищете дырку.
А если слово уже на диске, или дырки нет?
Придумайте сообщение об этой ошибке.
***
Let's talk about a refinement.
With a thousand names on disk it's easy to run out of mnemonics.
Let's re-use the field CONTEXT: after you scramble the word into a block address, add the contents of CONTEXT and search that block.
If CONTEXT is 0, no difference.
But if CONTEXT is non-zero, you're searching a different block.
If CONTEXT can vary from 0 to 15, you can have 16 different definitions of the same word.
You'll find the one that had the same value of CONTEXT when you defined it.
If there is no entry for a word under a given CONTEXT, you won't get a match.
A block containing a definition for the same word under a different CONTEXT won't be searched.
***
О реализации.
С тысячей имен на диске легко исчерпать мнемонику.
Переопределите CONTEXT: добавляйте его к номеру блока, полученного хэш-функцией.
Если CONTEXT - 0, все как обычно.
Но если CONTEXT отличен от нуля, вы получите другой блок.
Если CONTEXT может измениться от 0 до 15, вы можете иметь 16 различных определений того же самого слова.
Только надо помнить, с каким CONTEXT вы его определяли.
Если не найдется никакого совпадения в блоке с данным CONTEXT, вы не найдете статью.
Поиск в блоках с другим CONTEXT производится не будет.
***
For example, stock numbers might look the same for different sales-lines.
By setting CONTEXT you can distinguish them.
You can use the same name for a report screen that you use for its instruction screen; distinguish them by CONTEXT.
If you're scrambling anyway, you may as well add in CONTEXT (modulo a power of 2); it costs nothing, and vastly extends the universe of names.
In fact, you can use CONTEXT in both the ways we've discussed, simultaneously.
For as an aditive constant it tends to be small; and as a block number, large.
So your search routine can decide whether to scramble or not based on its size.
***
Например, индексы можно просматривать для различных каталогов.
Устанавливая CONTEXT, вы можете различать их.
Вы можете использовать то же самое имя для SCREEN-а кода и SCREEN-а комментариев, различая их по CONTEXT.
Чтобы не конфликтовать с хэш-функцией CONTEXT надо умножать на достаточную степень двойки.
Вы можете использовать CONTEXT в обоих случаях, которые мы обсудили, одновременно.
Как смещение блока, если маленький, или как номер блока, если большой.
Так что ваша программа поиска может решать, считать хэш-функцию или нет.
***
A problem arises if you plan to dissect words.
All those extra dictionary searches are augmented by disk searches and their attendant disk accesses.
Several solutions are possible: Scramble with only the first couple of characters, so at least the disk searches are in the same block - which will be in core.
Or use only non-zero values of CONTEXT and let 0 inhibit the disk search.
That is, make dissection and disk searching mutually exclusive.
As is often the case, the problem is serious only if you aren't aware of it.
***
Проблема возникает, если вы планируете обрезать слова.
Задержка вырастет неимоверно.
Несколько решений возможны: Хеширование по начальным символам.
Или CONTEXT, равный 0, для запрета поиска на диске.
Сделайте разбор и дисковый поиск взаимноисключающими.
Главное, решите, что вам надо.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\8. PROGRAMS THAT THINK / ПРОГРАММЫ, КОТОРЫЕ ДУМАЮТ\8.4. INFINITE MEMORY / БЕСКОНЕЧНАЯ ПАМЯТЬ
ТЕКСТ
Of course you can't really have infinite memory.
Not even unlimited memory.
But you can access directly the entire random memory available to your computer.
A small augmentation of the field entries introduced in Chapter 4 will do it.
I postponed the discussion to here because it has no particular connection with output, and because it's impressive enough to relate to 'thinking'.
***
Конечно, бесконечная память невозможна.
Невозможна даже неограниченная память.
Но вы можете иметь доступ ко всей памяти вашего компьютера, как к памяти произвольного доступа.
Для этого можно усовершенствовать статьи полей, представленные в Главе 4.
Я говорю об этом здесь потому, что такая техника ближе к разумному поведению, чем к процедурам вывода.
***
The problem of what to do with infinite memory, I leave up to you.
You will have to organize it somehow.
Examine different parts of it, move fields around, what you will.
All I can do is show you how to eliminate any explicit reference to disk.
***
Проблему того, что делать с бесконечной памятью, я оставлю вам.
Вы будете должны организовать ее так или иначе.
Экспериментируйте.
Все, что я могу делать - показать, как обойтись без ссылок на диск.
***
Let's include in our field a parameter that points to a disk address.
The field is assumed to be relative to that address; that is, contained in the disk block.
The program will automatically read the block to obtain the field.
Of course a number of fields will point to the same block address.
***
Давайте добавим к полю параметр - дисковый адрес.
Поле будет располагаться в этом блоке на диске.
Программа будет автоматически читать блок, чтобы получить поле.
Конечно, в одном блоке может лежать много полей.
***
Before you start objecting, let me rush on.
Stored with the block address is the location of the core buffer that block last occuppied.
So the program needn't actually read disk, or even search core buffers for the block, unless the block has been overlaid.
Hence repeated accesses to the same block cost little.
***
Прежде, чем вы начнете возражать, позволять мне объяснить.
Программа помнит блоки, считанные последними.
Так что, если блок уже в памяти, программа не будет его читать заново.
Следовательно, повторные доступы к тому же самому блоку стоят недорого.
***
Several trade-offs are involved: You should have a generous number of core buffers to minimize overlays.
You should choose you block size with this use in mind.
Accessing such disk-resident fields is slower than if you deliberately read the block into a fixed location and access it there; but the ease with which you can address data scattered on disk, and the beauty of being able to forget that some data is on disk and other data in core, to me make up for the loss in speed.
Besides, it's your problem to implement the feature in a way that is efficient.
***
Конечно нужно достаточное число блоковых буферов, для минимизации перекачек.
Нужен подходящий размер блоков.
Конечно, некоторые потери будут, но удобство того стоит.
Попробуйте сделать лучше!
***
Suppose you want to scan a portion of disk.
All you have to do is define the fields and establish a loop: start with the first block address, store it in the base location where the fields expect it and increment it each time through the loop.
All right, your advantage is marginal.
All you save is a read instruction.
But if that block links to another one, all you need do is store the link in the base location for other fields, and forget that a link is involved.
If you access fields in the link it will automatically be read.
If not, it won't be.
The more complex your data, the greater the advantage.
***
Предположим, что вы хотите просмотреть часть диска.
Все, что вы должны сделать - определить подходящие поля и перебирать их в цикле.
Реальный выигрыш минимален.
Все, что вы экономите - инструкция чтения.
Но если блоки как-то связаны, то сделав связь отдельным полем, можно использовать ее в цикле не задумываясь.
Чем сложнее организация ваших данных, тем больше выигрыш.
***
Of course, you don't have to worry about writing blocks either.
Chapter 6 talked about flagging blocks that need writing, rather than writing them immediately.
Pays off here!
If you change a field, its block will be re-written; if you don't, it won't.
Just make sure that when you say GOOD-BY your program writes all changed blocks.
***
Конечно, тем же способом можно и писать блоки.
В Главе 6 говорилось об отложенной записи блоков.
Т.е. платить опять не надо!
А если вы ничего не изменили, и записи не будет.
Только удостоверитесь, что, когда вы покидаете вашу программу, все измененные блоки записываются.
***
You can make these field entries identical with those accessing core, by making the pointer to the base address 0.
If you don't point to a disk address, you must mean core.
***
Вы можете сделать полевые статьи универсальными, считая, что дисковый адрес 0 обозначает работу с ОЗУ.
***
Notice that this addition of a base to a field entry defines a data structure very much like the levels in COBOL's data division: 01 level corresponding to the disk address; 02 levels to the fields themselves.
For a few extra instructions you can add higher levels: If the pointer does not reference a disk address, but another field description, you have the equivalent of 03 level, etc.
***
Заметьте, что подобные полевые статьи определяет структуру данных очень похоже на уровни доступа COBOL: 01 уровень - диск; 02 - поля.
Для других инструкций Вы можете добавлять более высокие уровни: указатель на поле в ОЗУ - 03 и т.д.
***
Consider how the field reference actually works.
In the field entry you have a word parameter that tells which word the field is in (or starts in).
If this field references another, you add the word parameters together.
When you find the core address of the disk block, you add the word offset and voila': you have the word you want.
Going through intermediate fields has little advangage unless the intermediate fields change.
Why not?
By incrementing a base field address, you can access different rows of a matrix or different records in a block.
Or you can access different sub-records of a record.
Very useful!
It's enough to make me think COBOL is a pretty good language.
Of course you can do the same thing with core fields, you just never point to a disk address at the very end.
***
Как это работает.
В полевой статье вы имеете параметр, означающий стартовый адрес.
Если это поле ссылается на другое, вы складываете параметры.
Когда вы находите основной адрес блока диска, вы добавляете полученное смещение и voila': вы нашли нужные данные.
Нужны ли промежуточные поля (хранящие другие поля)?
Почему нет?
Так удобно получать доступ к разного рода таблицам и записям.
Или к под-записям записей.
Очень полезно!
Все, как на COBOL, только проще и удобнее.
***
A word of warning!
Don't try to gain efficiency by putting the core address of a block in an index register.
It's too hard to keep track of which block, if any, the index is currently identifying.
You simply have to go through a fair bit of code to provide useful generality.
Of course, you hardware might have some special features: maybe microprogramming?
Even indirect addressing might be helpful.
***
Предупреждение!
Не пробуйте повысить эффективность, помещая адрес блока в индексный регистр.
Слишком трудно будет отследить, на какой блок регистр показывает в данный момент.
Немного кода и вы всегда получите то, что нужно.
Конечно, аппаратные средства могут иметь некоторые специальные особенности: возможно при микропрограммировании?
Даже косвенное адресация может быть полезна.
***
Given such elaborate addressing capabilities, you can use some help debugging your screens.
Memory protection is easy to provide, and very helpful.
Include with each field entry a maximum size (in words) for that field.
When you calculate an address that purports to be in that field, make sure it is.
The upper limit for the final block reference is of course the block size.
The upper limit for a core reference is also known.
A simple error message stating OVERFLOW will catch trouble before it has a chance to propagate.
***
Вы можете использовать сложные способы адресации для отладки.
Например, огранизовать защиту памяти.
Добавьте в поля предельное значение адреса.
И проверяйте при обращении к полям выход за их пределы.
Верхний предел для последнего поля блока - конечно размер блока.
Верхний предел для поля в ОЗУ тоже можно определить.
Простое сообщение об ошибке OVERFLOW покажет вам, что что-то не так, раньше, чем все рухнет.
***
You might want to implement an additional kind of field entry.
This one has a link.
If you make a reference that lies outside the field, it will follow this link and attempt to satisfy your request.
In particular, a record entry that points to a block: If you increment the record offset beyond the end of the block, you can pick up a link from the block, change the block address, reset the record offset and access the new, overflow block.
Automatically!
This makes for a very attractive implementation of variable length records (actually blocks), providing the records are composed of fixed-length pieces.
***
Возможен еще один вид полевой статьи.
Со ссылкой.
Когда вы будете выходить за пределы поля, будет выполнен переход по ссылке с целью удовлетворить запрос.
Например, для поля записи в блок: если вы выходите за пределы блока, вы по связи можете переходить в следующий блоки и продолжать там.
Автоматически!
Это позволит создавать записи переменной длины из записей фиксированной длины.
***
If you want such an overflow capability, you must provide a way of constructing the links.
You need an entry that will search a block (chain) for a record-size hole - of course all holes are the same size.
If you can't find a hold, you must GET a new block, link it, and then you have a block full of holes.
A hole should be identified by a 0 in the first word, character or bit, so that when GET clears the new block to 0, all record positions are empty.
Naturally you have no guarantee that overflow blocks will be near each other.
Almost certainly they won't be.
Either you don't care, or you initially allocate each block chain sequentially, up to mean size.
***
Если вы хотите подобным способам обрабатывать переполнение, вы должны научиться работать с ссылками.
Нужна статья, которая будет искать блок с подходящей дырой.
Если не получиться, выполнить GET - получить и привязать новый пустой блок.
Дыра в блоке должна идентифицироваться нулями в первом слове, чтобы новый блок (затираемый нулями) весь состоял из одних дыр.
Естественно, вы не имеете никакой гарантии что блоки будут идти подряд.
Почти никогда так не будет.
Или вас это не волнует, или вы выделяете блоки целыми группами.
***
It is easy to remove a record.
You create a hole by storing 0 in the first word.
It is hard to discover whether by doing this you have caused an empty block which can be un-chained.
Unless you expect your data to shrink and need to recover space, don't bother.
How can data shrink?
Also, don't move records around - to squeeze out holes perhaps.
Just as we want to use absolute block addresses, we want to use absolute record addresses (if we use record addresses at all).
***
Запись легко удалить
Вы создаете дыру, записывая 0 в первое слове.
Освободился ли при этом целый блок, выяснить трудно.
Если вы не стремитесь упаковывать данные, вас это не волнует.
Использование абсолютных адресов блоков и записей важнее.
***
So, we can have automatic access to fields scattered all over disk and in variable size records at that.
Basic Principle!
***
Так, мы можем иметь автоматический доступ к полям, рассеянным на всем протяжении диска и в записях переменной длины.
Основной Принцип!
***
One thing!
If field entries can address other field entries, you need some way to distinguish a field from a disk address.
I have no suggestion.
***
Замечание!
Если полевые статьи могут адресовать другие полевые статьи, вы нуждаетесь в некотором способе отличить поле от адреса диска.
Я такого способа не знаю.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\9. PROGRAMS THAT BOOTSTRAP / ЗАГРУЗКА
ТЕКСТ
It's sometimes hard to appreciate how it all gets started.
We have been tacitly assuming that your computer has a compiler and that you used it to compile your program.
But how did your compiler get written?
Today the answer is certainly that it was prepared by another compiler on another computer.
We've achieved parity with the biological maxim: all life comes from previously existing life.
For practical purposes, all programs are prepared by previously existing programs.
***
Иногда трудно оценить, как это все начинается.
Мы молчаливо предположили, что ваш компьютер имеет компилятор и что вы используете его, чтобы скомпилировать вашу программу.
Но как написан ваш компилятор?
При помощи дугого компилятора на другом компьютере.
Как биологии: живое происходит от живого.
Все программы сделаны другими программами.
***
Although this makes life somewhat easier for compiler writers, expecially when the target computer isn't built yet, it has a drawback.
You can never drop you ultimate dependence on the pre-existing program.
If you use a compiler that generates certain instructions, or assumes a certain disk format, you are constrained to be compatible.
Consider that a simple version of our program, providing it includes compiler verbs, is perfectly capable of compiling itself.
It can do this with greater freedom than the standard compiler, but more important, you can then discard the standard compiler.
***
Это здорово облегчает жизнь авторов компиляторов, конечно если целевой компьютер уже существует.
Вы всегда зависите от уже написанных программ.
Использование компилятора налагает некоторые требования совместимости с его форматами.
Если вы включите в свою программу куски компилятора, то она сама сможет компилировать.
Она будет гибче стандартного компилятора, но, главное, она сможет вообще отказаться от стандартного компилятора.
***
In Chapter 1, I discussed the sad state of software quality.
Although we can prepare an excellent object program, we are obliged to maintain it as a source program for an unhappy compromise of a compiler.
I must admit that this is the most expedient way to get the program started.
However, I question whether it is most efficient over the long haul of re-compiling and modifying.
***
В Главе 1, я обсуждал грустное состояние качества программного обеспечения.
Мы можем написать очень хорошую программу, а компилятор может ее сделать очень плохой.
Начать нам придется именно с этого.
Однако, дальнейшие компиляции лучше выполнять уже своими силами.
***
Let us imagine a situation in which you have access to your computer.
I mean sole user sitting at the board with all the lights, for some hours at a time.
This is admittedly an a-typical situation, but one that can always be arranged if you are competent, press hard, and will work odd hours.
Can you and the computer write a program?
Can you write a program that didn't descend from a pre-existing program?
You can learn a bit and have a lot of fun trying.
***
Какой доступ вы имеете к компьютеру?
Понадобится сидение за ним в одиночку долгими часами.
Придется побороться и работать в нерабочее время.
Вы и компьютер можете написать программу?
Вы можете написать программу, которая не будет зависеть от существующих программ?
Вы можете немного поработать и получить замечательное развлечение.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\9. PROGRAMS THAT BOOTSTRAP / ЗАГРУЗКА\9.1. GETTING STARTED / НАЧАЛО
ТЕКСТ
First you'll have to know some things: how to turn the computer on and off (odd hours), how to enter and display data from the console switches, and how to avoid damaging data stored on disk.
You may have to corner operators or engineers to discover such information; it is so rarely of interest it doesn't get written down.
***
Сначала вы будете должны узнать некоторые вещи: как включать и выключать компьютер (в нерабочее время), как работать с пультом и как избежать порчи данных на диске.
Вам, вероятно, придется попытать операторов или инженеров, чтобы обнаружить такую информацию; очень редко ее оформляют письменно.
***
So now you're face to face with the computer.
What do you do?
First an exercise.
Initialize the interrupt locations in such a way that the computer will run, will execute an endless loop, when you start it.
OK?
Then modify your loop so that it will clear memory.
OK?
You've probably learned a lot.
***
Так, теперь вы - лицом к лицу с компьютером.
Что вы делаете?
Сначала упражнение.
Инициализируйте прерывания таким образом, чтобы компьютер перешел после включения в бесконечный цикл.
Получилось?
Тогда измените вашу цикл так, чтобы он очистил память.
Получилось?
Вероятно, вы уже много узнали.
***
Now we're going to start for real.
We're going to start building your dictionary, even though you can't use it yet.
You must choose your entry format now; variable-sized entries are required, but you can decide about word-size and layout.
The first entry is SAVE; it will save your program on disk.
Lacking a control loop you'll have to jump to it manually, but at least you can minimize re-doing a lot of work.
The second entry is LOAD; it will re-load your program from disk.
You may have a hardware load button, if you can store your program compatibly with it, fine.
You might want to punch a load card, to provide initial load otherwise.
But it's always convenient to be able to re-start from core.
***
Теперь мы сделать что-то полезное.
Мы собираемся начинать строить ваш словарь, даже при том, что вы не сможете его использовать.
Вы должны выбрать ваш формат статьи; требуется переменная длина, но вы можете решать относительно размера слова и выравнивания.
Первая статья - SAVE; она будет сохранять вашу программу на диске.
При отсутствии цикла управления, вам придется запускать ее вручную, но она все равно сэкономит кучу работы.
Вторая статья - LOAD; она загрузит вашу программу с диска.
Если удастся привязать ее запуск к кнопке аппаратной загрузки, и вы сумеете поддержать необходимый формат, прекрасно.
Иначе придется изготовить загрузочную перфокарту.
Но всегда удобно иметь возможность рестартовать из ОЗУ.
***
The third entry is DUMP; it will dump core onto the printer.
It needn't be very fast to be a lot faster than looking with the switches.
This probably isn't a trivial routine, but it oughtn't take more than a dozen instructions.
You might want to postpone it just a bit.
***
Третья статья - DUMP; вывод ядра на принтер.
Читать бумагу все-таки проще, чем лампочки на пульте.
Это, вероятно, не тривиальная программа, но не должна занять более, чем дюжину инструкций.
Вы можете отложить ее написание, но не надолго.
***
So, with a couple hours work - providing you read the manual first - you have an operating system (SAVE, LOAD) and debugging package (DUMP).
And you know a lot about your computer.
***
Итак, пара часов работы - если вы сначала прочли инструкцию - и вы имеет операционную систему (SAVE и LOAD) и отладочный пакет (DUMP).
И вы уже много узнали о компьютере.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\9. PROGRAMS THAT BOOTSTRAP / ЗАГРУЗКА\9.2. THE ROOTS / КОРНИ
ТЕКСТ
Lest you worry, I have gone through this process myself.
I've done it twice, actually, and I'm not describing it as I did it, but as I now think I should have done it.
So you've room for improvisation.
***
Не волнуйтесь, я все проверил на себе.
И даже дважды, правда, я не вел записей и теперь об этом жалею.
Так что вы имеете простор для импровизации.
***
In a sense we're building a tree.
We've now reached a point where we can start making the roots.
For a while everything will be concealed but we'll eventually reach daylight and start on branches.
***
В некотором смысле мы строим дерево.
И достигли места, где мы можем начинать создавать корни.
Некоторое время все будет скрыто, но мы в конечном счете достигнем дневного света и перейдем к ветвям.
***
I presume you can LOAD your program and DUMP core.
It's time to get away from the switches and use the typewriter.
So set up a message buffer from which you can send and receive text.
Presumably when awaiting text your program sits in an endless loop somewhere.
Learn to recognise that loop.
You'll spend most of your running time there and it's reassuring to know that everything's allright.
***
Вы уже можете LOAD вашу программу и DUMP ядро.
Это - время, чтобы отойти от пульта с тумблерами и начать использовать телетайп.
Организуйте буфер сообщений.
Возможно, в ожидании ввода ваша программа висит в бесконечной цикле.
Найдите ее.
Вы там будете проводить большую часть времени.
***
No dictionary entry is associated with message I/O.
You could define one, but we won't need it.
In general we will construct entries only when they'll be needed.
We can always add any entry we need, later.
***
Никакая словарная статья не связана с вводом/выводом сообщений.
Вы могли бы определить одну, но мы не будем нуждаться в ней.
Вообще, мы будем строить статьи только, когда они станут необходимы.
Мы можем всегда добавить любую статью, когда она понадобится.
***
Your're doing great.
Now establish the stacks, the dictionary search subroutine and entries for WORD and NUMBER.
Be very careful to do it right the first time; that is, don't simplify NUMBER and plan to re-do it later.
The total amount of work is greater, even using the switches.
***
Сделано много.
Теперь установите стеки, подпрограмму поиска в словаре, статьи WORD и NUMBER.
Будьте очень осторожны, делая это в первый раз; NUMBER можно немного упростить, перепишете его позже.
Работа большая, даже если использовать тумблеры.
***
Now write a control loop.
You might test the stack, but jump to an unspecified error routine.
And run.
DUMP is still our only output routine, but you should be able to read and execute words like DUMP, SAVE and LOAD.
***
Теперь пишите цикл управления.
Вы могли бы проверять стек, но переходы к процедуре ошибки пока остаются неразрешенными.
Запустите.
DUMP - все еще наша единственная программа вывода, но вы должны быть способны прочесть и выполнить слова DUMP, SAVE и LOAD.
***
Write an entry for ENTRY, the subroutine that constructs dictionary entries.
I haven't specified the code executed for WORD, NUMBER and ENTRY.
These are subroutines, and the only time we'll use their names is when compiling code.
So they should execute code that generates a call instruction.
We haven't written that code yet.
***
Напишите статью для ENTRY, подпрограммы которая строит словарные статьи.
Я не определил код, выполненный для WORD, NUMBER и ENTRY.
Они - подпрограммы, и единственный случай, когда мы будем использовать их имена, это, когда компилируем код.
Выполнить их, означает поставить инструкцию вызова.
Этот код мы тоже не написали.
***
Now define the code-entry, the word that names code; and the deposit word, the word that places the stack in core.
Now you can type octal numbers and store them in the dictionary.
No more switches.
You can also construct new dictionary entries, for code.
***
Теперь определите статью кода, слово, которое называет код; и слово размещения, слово, которое размещает значение со стека в словарь.
Теперь вы можете вводить восьмеричные числа и грузить их в словарь.
Нет больше тумблеров.
Вы можете строить код новых словарных статей.

\6.ПЕРВОИСТОЧНИКИ\CHARLES H.MOORE PROGRAMMING A PROBLEM-ORIENTED-LANGUAGE\9. PROGRAMS THAT BOOTSTRAP / ЗАГРУЗКА\9.3. THE BRANCHES / ВЕТВИ
ТЕКСТ
We've reached a milestone.
The invisible work is done and we can have a written record of what remains.
There are many things to do and the order not so obvious.
We've reached the position of having a source language, and we need to be able to modify it and re-compile without re-doing everything.
Here we're forced to generate temporary code that will become obsolete, but it will save a lot of effort.
***
Мы достигли поверхности.
Невидимая работа сделана, и мы можем видеть что делаем.
Сделать надо много и порядок неочевиден.
Мы создали исходный язык, и мы должны быть способными изменить его и заново собирать без того, чтобы переделать все.
Здесь мы вынуждены создать временный код, который станет устаревшим, но это будет сэкономит много усилий.
***
First a READ and WRITE entry to provide disk-access to a single core buffer.
Then a simple T and R to type and replace lines of text in that block.
These entries will later become obsolete, so keep them simple.
***
Сначала статьи READ и WRITE, чтобы обеспечить доступ к диску через единственный буфер.
Теперь простые T и R, чтобы напечатать текст в блоке.
Они скоро устареют, так что пишите их просто.
***
We now need the READ and ;S verbs for screens.
Specify a block number and we can read the text in that block.
***
Теперь нужны READ и ;S глаголы для SCREEN-ов.
Определите номер блока, и мы можем читать текст в том блоке.
***
Now we write screens that provide definitions, an improved compiler, improved block handler, improved text-editor and we can proceed with our application.
We want a REMEMBER entry.
We haven't needed it so far bacause we could always reach in and reset the dictionary manually.
***
Теперь мы пишем SCREEN-ы: новые определения, улучшенный компилятор, улучшенная работа с блоками, улучшенный редактор текста, и мы можем продолжать наше приложение.
Пишем статью REMEMBER.
Без нее приходилось переустанавливать словарь вручную.
***
I'm sure you've noticed the difficulty with modifying code in the root.
A powerful tool is to be able to shift the dictionary in core.
If the root doesn't use absolute addresses, define a SHIFT entry and use it.
Otherwise minimize the number of absolute addresses and define a more elaborate SHIFT verb that adjusts them.
***
Я уверен, что вы заметили трудность изменениея кода в корнях.
Мощным инструментом будет способность перемещать словарь в памяти.
Если корень не использует абсолютные адреса, определите статью SHIFT и используйте ее.
Иначе минимизируйте число абсолютных адресов, и определите более сложный глагол SHIFT, который их перерасчитывает.
***
Be careful SAVEing your program.
Keep a back-up of your old version before SAVEing a new one, just in case.
***
Будьте осторожны, делая SAVE вашей программы.
Делайте, на всякий случай, копию вашего предыдущего сохранения, прежде чем сохраниться снова.
